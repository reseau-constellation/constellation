(self["webpackChunkconstellation"]=self["webpackChunkconstellation"]||[]).push([[550],{19824:function(e,t,r){"use strict";var s=r(25108);const n=-8,i=-4,o=0,a=1,c=1,l=2,u=5,h=1024,d=2048,p=8192,f=0,y=4,g=8,m=12,w=12,b=16,_="undefined"!==typeof BigUint64Array,E=Symbol(),v=1024;function S(e,t){const r=new Uint32Array(e),s=new Uint16Array(e);var n=r[t+i>>>2]>>>1,o=t>>>1;if(n<=v)return String.fromCharCode.apply(String,s.subarray(o,o+n));const a=[];do{const e=s[o+v-1],t=e>=55296&&e<56320?v-1:v;a.push(String.fromCharCode.apply(String,s.subarray(o,o+=t))),n-=t}while(n>v);return a.join("")+String.fromCharCode.apply(String,s.subarray(o,o+n))}function I(e){const t={};function r(e,t){return e?S(e.buffer,t):"<yet unknown>"}const n=e.env=e.env||{};return n.abort=n.abort||function(e,s,i,o){const a=t.memory||n.memory;throw Error("abort: "+r(a,e)+" at "+r(a,s)+":"+i+":"+o)},n.trace=n.trace||function(e,i){const o=t.memory||n.memory;s.log("trace: "+r(o,e)+(i?" ":"")+Array.prototype.slice.call(arguments,2,2+i).join(", "))},e.Math=e.Math||Math,e.Date=e.Date||Date,t}function k(e,t){const r=t.exports,s=r.memory,E=r.table,v=r["__alloc"],I=r["__retain"],k=r["__rtti_base"]||-1;function R(e){const t=new Uint32Array(s.buffer),r=t[k>>>2];if((e>>>=0)>=r)throw Error("invalid id: "+e);return t[(k+4>>>2)+2*e]}function T(e){const t=new Uint32Array(s.buffer),r=t[k>>>2];if((e>>>=0)>=r)throw Error("invalid id: "+e);return t[(k+4>>>2)+2*e+1]}function A(e){return 31-Math.clz32(e>>>u&31)}function C(e){const t=e.length,r=v(t<<1,a),n=new Uint16Array(s.buffer);for(var i=0,o=r>>>1;i<t;++i)n[o+i]=e.charCodeAt(i);return r}function D(e){const t=s.buffer,r=new Uint32Array(t)[e+n>>>2];if(r!==a)throw Error("not a string: "+e);return S(t,e)}function N(e,t,r){const n=s.buffer;if(r)switch(e){case 2:return new Float32Array(n);case 3:return new Float64Array(n)}else switch(e){case 0:return new(t?Int8Array:Uint8Array)(n);case 1:return new(t?Int16Array:Uint16Array)(n);case 2:return new(t?Int32Array:Uint32Array)(n);case 3:return new(t?BigInt64Array:BigUint64Array)(n)}throw Error("unsupported align: "+e)}function O(e,t){const r=R(e);if(!(r&(c|l)))throw Error("not an array: "+e+" @ "+r);const n=A(r),i=t.length,a=v(i<<n,o),u=v(r&l?b:m,e),_=new Uint32Array(s.buffer);_[u+f>>>2]=I(a),_[u+y>>>2]=a,_[u+g>>>2]=i<<n,r&l&&(_[u+w>>>2]=i);const E=N(n,r&h,r&d);if(r&p)for(let s=0;s<i;++s)E[(a>>>n)+s]=I(t[s]);else E.set(t,a>>>n);return u}function L(e){const t=new Uint32Array(s.buffer),r=t[e+n>>>2],o=R(r);if(!(o&c))throw Error("not an array: "+r);const a=A(o);var u=t[e+y>>>2];const p=o&l?t[e+w>>>2]:t[u+i>>>2]>>>a;return N(a,o&h,o&d).subarray(u>>>=a,u+p)}function x(e){const t=L(e),r=t.length,s=new Array(r);for(let n=0;n<r;n++)s[n]=t[n];return s}function M(e){const t=s.buffer,r=new Uint32Array(t)[e+i>>>2];return t.slice(e,e+r)}function B(e,t,r){return new e(U(e,t,r))}function U(e,t,r){const n=s.buffer,o=new Uint32Array(n),a=o[r+y>>>2];return new e(n,a,o[a+i>>>2]>>>t)}function j(e,t){const r=new Uint32Array(s.buffer);var i=r[e+n>>>2];if(i<=r[k>>>2])do{if(i==t)return!0}while(i=T(i));return!1}return e.__allocString=C,e.__getString=D,e.__allocArray=O,e.__getArrayView=L,e.__getArray=x,e.__getArrayBuffer=M,e.__getInt8Array=B.bind(null,Int8Array,0),e.__getInt8ArrayView=U.bind(null,Int8Array,0),e.__getUint8Array=B.bind(null,Uint8Array,0),e.__getUint8ArrayView=U.bind(null,Uint8Array,0),e.__getUint8ClampedArray=B.bind(null,Uint8ClampedArray,0),e.__getUint8ClampedArrayView=U.bind(null,Uint8ClampedArray,0),e.__getInt16Array=B.bind(null,Int16Array,1),e.__getInt16ArrayView=U.bind(null,Int16Array,1),e.__getUint16Array=B.bind(null,Uint16Array,1),e.__getUint16ArrayView=U.bind(null,Uint16Array,1),e.__getInt32Array=B.bind(null,Int32Array,2),e.__getInt32ArrayView=U.bind(null,Int32Array,2),e.__getUint32Array=B.bind(null,Uint32Array,2),e.__getUint32ArrayView=U.bind(null,Uint32Array,2),_&&(e.__getInt64Array=B.bind(null,BigInt64Array,3),e.__getInt64ArrayView=U.bind(null,BigInt64Array,3),e.__getUint64Array=B.bind(null,BigUint64Array,3),e.__getUint64ArrayView=U.bind(null,BigUint64Array,3)),e.__getFloat32Array=B.bind(null,Float32Array,2),e.__getFloat32ArrayView=U.bind(null,Float32Array,2),e.__getFloat64Array=B.bind(null,Float64Array,3),e.__getFloat64ArrayView=U.bind(null,Float64Array,3),e.__instanceof=j,e.memory=e.memory||s,e.table=e.table||E,P(r,e)}function R(e){return"undefined"!==typeof Response&&e instanceof Response}async function T(e,t){return R(e=await e)?C(e,t):k(I(t||(t={})),await WebAssembly.instantiate(e instanceof WebAssembly.Module?e:await WebAssembly.compile(e),t))}function A(e,t){return k(I(t||(t={})),new WebAssembly.Instance(e instanceof WebAssembly.Module?e:new WebAssembly.Module(e),t))}async function C(e,t){return WebAssembly.instantiateStreaming?k(I(t||(t={})),(await WebAssembly.instantiateStreaming(e,t)).instance):T(R(e=await e)?e.arrayBuffer():e,t)}function P(e,t){var r=t?Object.create(t):{},s=e["__argumentsLength"]?function(t){e["__argumentsLength"].value=t}:e["__setArgumentsLength"]||e["__setargc"]||function(){};for(let n in e){if(!Object.prototype.hasOwnProperty.call(e,n))continue;const t=e[n];let i=n.split("."),o=r;while(i.length>1){let e=i.shift();Object.prototype.hasOwnProperty.call(o,e)||(o[e]={}),o=o[e]}let a=i[0],c=a.indexOf("#");if(c>=0){let r=a.substring(0,c),i=o[r];if("undefined"===typeof i||!i.prototype){let e=function(...t){return e.wrap(e.prototype.constructor(0,...t))};e.prototype={valueOf:function(){return this[E]}},e.wrap=function(t){return Object.create(e.prototype,{[E]:{value:t,writable:!1}})},i&&Object.getOwnPropertyNames(i).forEach((t=>Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t)))),o[r]=e}if(a=a.substring(c+1),o=o[r].prototype,/^(get|set):/.test(a)){if(!Object.prototype.hasOwnProperty.call(o,a=a.substring(4))){let t=e[n.replace("set:","get:")],r=e[n.replace("get:","set:")];Object.defineProperty(o,a,{get:function(){return t(this[E])},set:function(e){r(this[E],e)},enumerable:!0})}}else"constructor"===a?(o[a]=(...e)=>(s(e.length),t(...e))).original=t:(o[a]=function(...e){return s(e.length),t(this[E],...e)}).original=t}else/^(get|set):/.test(a)?Object.prototype.hasOwnProperty.call(o,a=a.substring(4))||Object.defineProperty(o,a,{get:e[n.replace("set:","get:")],set:e[n.replace("get:","set:")],enumerable:!0}):"function"===typeof t&&t!==s?(o[a]=(...e)=>(s(e.length),t(...e))).original=t:o[a]=t}return r}t.instantiate=T,t.instantiateSync=A,t.instantiateStreaming=C,t.demangle=P},42450:function(e,t,r){"use strict";e.exports=r(10077)},10077:function(e,t,r){"use strict";var s=t;function n(){s.util._configure(),s.Writer._configure(s.BufferWriter),s.Reader._configure(s.BufferReader)}s.build="minimal",s.Writer=r(88482),s.BufferWriter=r(95628),s.Reader=r(29958),s.BufferReader=r(73055),s.util=r(61436),s.rpc=r(13971),s.roots=r(59149),s.configure=n,n()},29958:function(e,t,r){"use strict";e.exports=c;var s,n=r(61436),i=n.LongBits,o=n.utf8;function a(e,t){return RangeError("index out of range: "+e.pos+" + "+(t||1)+" > "+e.len)}function c(e){this.buf=e,this.pos=0,this.len=e.length}var l="undefined"!==typeof Uint8Array?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new c(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new c(e);throw Error("illegal buffer")},u=function(){return n.Buffer?function(e){return(c.create=function(e){return n.Buffer.isBuffer(e)?new s(e):l(e)})(e)}:l};function h(){var e=new i(0,0),t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw a(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw a(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}function d(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}function p(){if(this.pos+8>this.len)throw a(this,8);return new i(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}c.create=u(),c.prototype._slice=n.Array.prototype.subarray||n.Array.prototype.slice,c.prototype.uint32=function(){var e=4294967295;return function(){if(e=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return e;if(e=(e|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return e;if((this.pos+=5)>this.len)throw this.pos=this.len,a(this,10);return e}}(),c.prototype.int32=function(){return 0|this.uint32()},c.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(1&e)|0},c.prototype.bool=function(){return 0!==this.uint32()},c.prototype.fixed32=function(){if(this.pos+4>this.len)throw a(this,4);return d(this.buf,this.pos+=4)},c.prototype.sfixed32=function(){if(this.pos+4>this.len)throw a(this,4);return 0|d(this.buf,this.pos+=4)},c.prototype.float=function(){if(this.pos+4>this.len)throw a(this,4);var e=n.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e},c.prototype.double=function(){if(this.pos+8>this.len)throw a(this,4);var e=n.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e},c.prototype.bytes=function(){var e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw a(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(t,r):t===r?new this.buf.constructor(0):this._slice.call(this.buf,t,r)},c.prototype.string=function(){var e=this.bytes();return o.read(e,0,e.length)},c.prototype.skip=function(e){if("number"===typeof e){if(this.pos+e>this.len)throw a(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw a(this)}while(128&this.buf[this.pos++]);return this},c.prototype.skipType=function(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:while(4!==(e=7&this.uint32()))this.skipType(e);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+e+" at offset "+this.pos)}return this},c._configure=function(e){s=e,c.create=u(),s._configure();var t=n.Long?"toLong":"toNumber";n.merge(c.prototype,{int64:function(){return h.call(this)[t](!1)},uint64:function(){return h.call(this)[t](!0)},sint64:function(){return h.call(this).zzDecode()[t](!1)},fixed64:function(){return p.call(this)[t](!0)},sfixed64:function(){return p.call(this)[t](!1)}})}},73055:function(e,t,r){"use strict";e.exports=i;var s=r(29958);(i.prototype=Object.create(s.prototype)).constructor=i;var n=r(61436);function i(e){s.call(this,e)}i._configure=function(){n.Buffer&&(i.prototype._slice=n.Buffer.prototype.slice)},i.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))},i._configure()},59149:function(e){"use strict";e.exports={}},13971:function(e,t,r){"use strict";var s=t;s.Service=r(98295)},98295:function(e,t,r){"use strict";e.exports=n;var s=r(61436);function n(e,t,r){if("function"!==typeof e)throw TypeError("rpcImpl must be a function");s.EventEmitter.call(this),this.rpcImpl=e,this.requestDelimited=Boolean(t),this.responseDelimited=Boolean(r)}(n.prototype=Object.create(s.EventEmitter.prototype)).constructor=n,n.prototype.rpcCall=function e(t,r,n,i,o){if(!i)throw TypeError("request must be specified");var a=this;if(!o)return s.asPromise(e,a,t,r,n,i);if(a.rpcImpl)try{return a.rpcImpl(t,r[a.requestDelimited?"encodeDelimited":"encode"](i).finish(),(function(e,r){if(e)return a.emit("error",e,t),o(e);if(null!==r){if(!(r instanceof n))try{r=n[a.responseDelimited?"decodeDelimited":"decode"](r)}catch(e){return a.emit("error",e,t),o(e)}return a.emit("data",r,t),o(null,r)}a.end(!0)}))}catch(c){return a.emit("error",c,t),void setTimeout((function(){o(c)}),0)}else setTimeout((function(){o(Error("already ended"))}),0)},n.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},19961:function(e,t,r){"use strict";e.exports=n;var s=r(61436);function n(e,t){this.lo=e>>>0,this.hi=t>>>0}var i=n.zero=new n(0,0);i.toNumber=function(){return 0},i.zzEncode=i.zzDecode=function(){return this},i.length=function(){return 1};var o=n.zeroHash="\0\0\0\0\0\0\0\0";n.fromNumber=function(e){if(0===e)return i;var t=e<0;t&&(e=-e);var r=e>>>0,s=(e-r)/4294967296>>>0;return t&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new n(r,s)},n.from=function(e){if("number"===typeof e)return n.fromNumber(e);if(s.isString(e)){if(!s.Long)return n.fromNumber(parseInt(e,10));e=s.Long.fromString(e)}return e.low||e.high?new n(e.low>>>0,e.high>>>0):i},n.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var t=1+~this.lo>>>0,r=~this.hi>>>0;return t||(r=r+1>>>0),-(t+4294967296*r)}return this.lo+4294967296*this.hi},n.prototype.toLong=function(e){return s.Long?new s.Long(0|this.lo,0|this.hi,Boolean(e)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(e)}};var a=String.prototype.charCodeAt;n.fromHash=function(e){return e===o?i:new n((a.call(e,0)|a.call(e,1)<<8|a.call(e,2)<<16|a.call(e,3)<<24)>>>0,(a.call(e,4)|a.call(e,5)<<8|a.call(e,6)<<16|a.call(e,7)<<24)>>>0)},n.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},n.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this},n.prototype.zzDecode=function(){var e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this},n.prototype.length=function(){var e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return 0===r?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}},61436:function(e,t,r){"use strict";var s=t;function n(e,t,r){for(var s=Object.keys(t),n=0;n<s.length;++n)void 0!==e[s[n]]&&r||(e[s[n]]=t[s[n]]);return e}function i(e){function t(e,r){if(!(this instanceof t))return new t(e,r);Object.defineProperty(this,"message",{get:function(){return e}}),Error.captureStackTrace?Error.captureStackTrace(this,t):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),r&&n(this,r)}return(t.prototype=Object.create(Error.prototype)).constructor=t,Object.defineProperty(t.prototype,"name",{get:function(){return e}}),t.prototype.toString=function(){return this.name+": "+this.message},t}s.asPromise=r(34537),s.base64=r(97419),s.EventEmitter=r(19211),s.float=r(10945),s.inquire=r(67199),s.utf8=r(94997),s.pool=r(76662),s.LongBits=r(19961),s.isNode=Boolean("undefined"!==typeof r.g&&r.g&&r.g.process&&r.g.process.versions&&r.g.process.versions.node),s.global=s.isNode&&r.g||"undefined"!==typeof window&&window||"undefined"!==typeof self&&self||this,s.emptyArray=Object.freeze?Object.freeze([]):[],s.emptyObject=Object.freeze?Object.freeze({}):{},s.isInteger=Number.isInteger||function(e){return"number"===typeof e&&isFinite(e)&&Math.floor(e)===e},s.isString=function(e){return"string"===typeof e||e instanceof String},s.isObject=function(e){return e&&"object"===typeof e},s.isset=s.isSet=function(e,t){var r=e[t];return!(null==r||!e.hasOwnProperty(t))&&("object"!==typeof r||(Array.isArray(r)?r.length:Object.keys(r).length)>0)},s.Buffer=function(){try{var e=s.inquire("buffer").Buffer;return e.prototype.utf8Write?e:null}catch(t){return null}}(),s._Buffer_from=null,s._Buffer_allocUnsafe=null,s.newBuffer=function(e){return"number"===typeof e?s.Buffer?s._Buffer_allocUnsafe(e):new s.Array(e):s.Buffer?s._Buffer_from(e):"undefined"===typeof Uint8Array?e:new Uint8Array(e)},s.Array="undefined"!==typeof Uint8Array?Uint8Array:Array,s.Long=s.global.dcodeIO&&s.global.dcodeIO.Long||s.global.Long||s.inquire("long"),s.key2Re=/^true|false|0|1$/,s.key32Re=/^-?(?:0|[1-9][0-9]*)$/,s.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,s.longToHash=function(e){return e?s.LongBits.from(e).toHash():s.LongBits.zeroHash},s.longFromHash=function(e,t){var r=s.LongBits.fromHash(e);return s.Long?s.Long.fromBits(r.lo,r.hi,t):r.toNumber(Boolean(t))},s.merge=n,s.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)},s.newError=i,s.ProtocolError=i("ProtocolError"),s.oneOfGetter=function(e){for(var t={},r=0;r<e.length;++r)t[e[r]]=1;return function(){for(var e=Object.keys(this),r=e.length-1;r>-1;--r)if(1===t[e[r]]&&void 0!==this[e[r]]&&null!==this[e[r]])return e[r]}},s.oneOfSetter=function(e){return function(t){for(var r=0;r<e.length;++r)e[r]!==t&&delete this[e[r]]}},s.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},s._configure=function(){var e=s.Buffer;e?(s._Buffer_from=e.from!==Uint8Array.from&&e.from||function(t,r){return new e(t,r)},s._Buffer_allocUnsafe=e.allocUnsafe||function(t){return new e(t)}):s._Buffer_from=s._Buffer_allocUnsafe=null}},88482:function(e,t,r){"use strict";e.exports=h;var s,n=r(61436),i=n.LongBits,o=n.base64,a=n.utf8;function c(e,t,r){this.fn=e,this.len=t,this.next=void 0,this.val=r}function l(){}function u(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}function h(){this.len=0,this.head=new c(l,0,0),this.tail=this.head,this.states=null}var d=function(){return n.Buffer?function(){return(h.create=function(){return new s})()}:function(){return new h}};function p(e,t,r){t[r]=255&e}function f(e,t,r){while(e>127)t[r++]=127&e|128,e>>>=7;t[r]=e}function y(e,t){this.len=e,this.next=void 0,this.val=t}function g(e,t,r){while(e.hi)t[r++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;while(e.lo>127)t[r++]=127&e.lo|128,e.lo=e.lo>>>7;t[r++]=e.lo}function m(e,t,r){t[r]=255&e,t[r+1]=e>>>8&255,t[r+2]=e>>>16&255,t[r+3]=e>>>24}h.create=d(),h.alloc=function(e){return new n.Array(e)},n.Array!==Array&&(h.alloc=n.pool(h.alloc,n.Array.prototype.subarray)),h.prototype._push=function(e,t,r){return this.tail=this.tail.next=new c(e,t,r),this.len+=t,this},y.prototype=Object.create(c.prototype),y.prototype.fn=f,h.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new y((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this},h.prototype.int32=function(e){return e<0?this._push(g,10,i.fromNumber(e)):this.uint32(e)},h.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)},h.prototype.uint64=function(e){var t=i.from(e);return this._push(g,t.length(),t)},h.prototype.int64=h.prototype.uint64,h.prototype.sint64=function(e){var t=i.from(e).zzEncode();return this._push(g,t.length(),t)},h.prototype.bool=function(e){return this._push(p,1,e?1:0)},h.prototype.fixed32=function(e){return this._push(m,4,e>>>0)},h.prototype.sfixed32=h.prototype.fixed32,h.prototype.fixed64=function(e){var t=i.from(e);return this._push(m,4,t.lo)._push(m,4,t.hi)},h.prototype.sfixed64=h.prototype.fixed64,h.prototype.float=function(e){return this._push(n.float.writeFloatLE,4,e)},h.prototype.double=function(e){return this._push(n.float.writeDoubleLE,8,e)};var w=n.Array.prototype.set?function(e,t,r){t.set(e,r)}:function(e,t,r){for(var s=0;s<e.length;++s)t[r+s]=e[s]};h.prototype.bytes=function(e){var t=e.length>>>0;if(!t)return this._push(p,1,0);if(n.isString(e)){var r=h.alloc(t=o.length(e));o.decode(e,r,0),e=r}return this.uint32(t)._push(w,t,e)},h.prototype.string=function(e){var t=a.length(e);return t?this.uint32(t)._push(a.write,t,e):this._push(p,1,0)},h.prototype.fork=function(){return this.states=new u(this),this.head=this.tail=new c(l,0,0),this.len=0,this},h.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new c(l,0,0),this.len=0),this},h.prototype.ldelim=function(){var e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),r&&(this.tail.next=e.next,this.tail=t,this.len+=r),this},h.prototype.finish=function(){var e=this.head.next,t=this.constructor.alloc(this.len),r=0;while(e)e.fn(e.val,t,r),r+=e.len,e=e.next;return t},h._configure=function(e){s=e,h.create=d(),s._configure()}},95628:function(e,t,r){"use strict";e.exports=i;var s=r(88482);(i.prototype=Object.create(s.prototype)).constructor=i;var n=r(61436);function i(){s.call(this)}function o(e,t,r){e.length<40?n.utf8.write(e,t,r):t.utf8Write?t.utf8Write(e,r):t.write(e,r)}i._configure=function(){i.alloc=n._Buffer_allocUnsafe,i.writeBytesBuffer=n.Buffer&&n.Buffer.prototype instanceof Uint8Array&&"set"===n.Buffer.prototype.set.name?function(e,t,r){t.set(e,r)}:function(e,t,r){if(e.copy)e.copy(t,r,0,e.length);else for(var s=0;s<e.length;)t[r++]=e[s++]}},i.prototype.bytes=function(e){n.isString(e)&&(e=n._Buffer_from(e,"base64"));var t=e.length>>>0;return this.uint32(t),t&&this._push(i.writeBytesBuffer,t,e),this},i.prototype.string=function(e){var t=n.Buffer.byteLength(e);return this.uint32(t),t&&this._push(o,t,e),this},i._configure()},63573:function(e,t){"use strict";const r=Math.exp;e.exports=function(e){if("number"!==typeof e)throw new Error("must provide a timespan to the moving average constructor");if(e<=0)throw new Error("must provide a timespan > 0 to the moving average constructor");let t,s,n=0,i=0,o=0,a={};function c(t,s){return 1-r(-(t-s)/e)}return a.push=function(e,r){if(s){const a=c(e,s),l=r-t,u=a*l;t=a*r+(1-a)*t,n=(1-a)*(n+l*u),i=Math.sqrt(n),o=t+a*l}else t=r;s=e},a.movingAverage=function(){return t},a.variance=function(){return n},a.deviation=function(){return i},a.forecast=function(){return o},a}},19464:function(e,t,r){"use strict";const{fromCallback:s}=r(16957),n=r(94473),{getCallback:i,getOptions:o}=r(92520),a=Symbol("promise"),c=Symbol("status"),l=Symbol("operations"),u=Symbol("finishClose"),h=Symbol("closeCallbacks");class d{constructor(e){if("object"!==typeof e||null===e){const t=null===e?"null":typeof e;throw new TypeError(`The first argument must be an abstract-level database, received ${t}`)}this[l]=[],this[h]=[],this[c]="open",this[u]=this[u].bind(this),this.db=e,this.db.attachResource(this),this.nextTick=e.nextTick}get length(){return this[l].length}put(e,t,r){if("open"!==this[c])throw new n("Batch is not open: cannot call put() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});const s=this.db._checkKey(e)||this.db._checkValue(t);if(s)throw s;const i=r&&null!=r.sublevel?r.sublevel:this.db,o=r,a=i.keyEncoding(r&&r.keyEncoding),u=i.valueEncoding(r&&r.valueEncoding),h=a.format;r={...r,keyEncoding:h,valueEncoding:u.format},i!==this.db&&(r.sublevel=null);const d=i.prefixKey(a.encode(e),h),p=u.encode(t);return this._put(d,p,r),this[l].push({...o,type:"put",key:e,value:t}),this}_put(e,t,r){}del(e,t){if("open"!==this[c])throw new n("Batch is not open: cannot call del() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});const r=this.db._checkKey(e);if(r)throw r;const s=t&&null!=t.sublevel?t.sublevel:this.db,i=t,o=s.keyEncoding(t&&t.keyEncoding),a=o.format;return t={...t,keyEncoding:a},s!==this.db&&(t.sublevel=null),this._del(s.prefixKey(o.encode(e),a),t),this[l].push({...i,type:"del",key:e}),this}_del(e,t){}clear(){if("open"!==this[c])throw new n("Batch is not open: cannot call clear() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"});return this._clear(),this[l]=[],this}_clear(){}write(e,t){return t=i(e,t),t=s(t,a),e=o(e),"open"!==this[c]?this.nextTick(t,new n("Batch is not open: cannot call write() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"})):0===this.length?this.close(t):(this[c]="writing",this._write(e,(e=>{this[c]="closing",this[h].push((()=>t(e))),e||this.db.emit("batch",this[l]),this._close(this[u])}))),t[a]}_write(e,t){}close(e){return e=s(e,a),"closing"===this[c]?this[h].push(e):"closed"===this[c]?this.nextTick(e):(this[h].push(e),"writing"!==this[c]&&(this[c]="closing",this._close(this[u]))),e[a]}_close(e){this.nextTick(e)}[u](){this[c]="closed",this.db.detachResource(this);const e=this[h];this[h]=[];for(const t of e)t()}}t.AbstractChainedBatch=d},33961:function(e,t,r){"use strict";var s=r(25108);const{fromCallback:n}=r(16957),i=r(94473),{getOptions:o,getCallback:a}=r(92520),c=Symbol("promise"),l=Symbol("callback"),u=Symbol("working"),h=Symbol("handleOne"),d=Symbol("handleMany"),p=Symbol("autoClose"),f=Symbol("finishWork"),y=Symbol("returnMany"),g=Symbol("closing"),m=Symbol("handleClose"),w=Symbol("closed"),b=Symbol("closeCallbacks"),_=Symbol("keyEncoding"),E=Symbol("valueEncoding"),v=Symbol("abortOnClose"),S=Symbol("legacy"),I=Symbol("keys"),k=Symbol("values"),R=Symbol("limit"),T=Symbol("count"),A=Object.freeze({}),C=()=>{};let P=!1;class D{constructor(e,t,r){if("object"!==typeof e||null===e){const t=null===e?"null":typeof e;throw new TypeError(`The first argument must be an abstract-level database, received ${t}`)}if("object"!==typeof t||null===t)throw new TypeError("The second argument must be an options object");this[w]=!1,this[b]=[],this[u]=!1,this[g]=!1,this[p]=!1,this[l]=null,this[h]=this[h].bind(this),this[d]=this[d].bind(this),this[m]=this[m].bind(this),this[_]=t[_],this[E]=t[E],this[S]=r,this[R]=Number.isInteger(t.limit)&&t.limit>=0?t.limit:1/0,this[T]=0,this[v]=!!t.abortOnClose,this.db=e,this.db.attachResource(this),this.nextTick=e.nextTick}get count(){return this[T]}get limit(){return this[R]}next(e){let t;if(void 0===e)t=new Promise(((t,r)=>{e=(e,s,n)=>{e?r(e):this[S]?void 0===s&&void 0===n?t():t([s,n]):t(s)}}));else if("function"!==typeof e)throw new TypeError("Callback must be a function");return this[g]?this.nextTick(e,new i("Iterator is not open: cannot call next() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[u]?this.nextTick(e,new i("Iterator is busy: cannot call next() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(this[u]=!0,this[l]=e,this[T]>=this[R]?this.nextTick(this[h],null):this._next(this[h])),t}_next(e){this.nextTick(e)}nextv(e,t,r){return r=a(t,r),r=n(r,c),t=o(t,A),Number.isInteger(e)?(this[g]?this.nextTick(r,new i("Iterator is not open: cannot call nextv() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[u]?this.nextTick(r,new i("Iterator is busy: cannot call nextv() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(e<1&&(e=1),this[R]<1/0&&(e=Math.min(e,this[R]-this[T])),this[u]=!0,this[l]=r,e<=0?this.nextTick(this[d],null,[]):this._nextv(e,t,this[d])),r[c]):(this.nextTick(r,new TypeError("The first argument 'size' must be an integer")),r[c])}_nextv(e,t,r){const s=[],n=(t,i,o)=>t?r(t):(this[S]?void 0===i&&void 0===o:void 0===i)?r(null,s):(s.push(this[S]?[i,o]:i),void(s.length===e?r(null,s):this._next(n)));this._next(n)}all(e,t){return t=a(e,t),t=n(t,c),e=o(e,A),this[g]?this.nextTick(t,new i("Iterator is not open: cannot call all() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"})):this[u]?this.nextTick(t,new i("Iterator is busy: cannot call all() until previous call has completed",{code:"LEVEL_ITERATOR_BUSY"})):(this[u]=!0,this[l]=t,this[p]=!0,this[T]>=this[R]?this.nextTick(this[d],null,[]):this._all(e,this[d])),t[c]}_all(e,t){let r=this[T];const s=[],n=()=>{const e=this[R]<1/0?Math.min(1e3,this[R]-r):1e3;e<=0?this.nextTick(t,null,s):this._nextv(e,A,i)},i=(e,i)=>{e?t(e):0===i.length?t(null,s):(s.push.apply(s,i),r+=i.length,n())};n()}[f](){const e=this[l];return this[v]&&null===e?C:(this[u]=!1,this[l]=null,this[g]&&this._close(this[m]),e)}[y](e,t,r){this[p]?this.close(e.bind(null,t,r)):e(t,r)}seek(e,t){if(t=o(t,A),this[g]);else{if(this[u])throw new i("Iterator is busy: cannot call seek() until next() has completed",{code:"LEVEL_ITERATOR_BUSY"});{const r=this.db.keyEncoding(t.keyEncoding||this[_]),s=r.format;t.keyEncoding!==s&&(t={...t,keyEncoding:s});const n=this.db.prefixKey(r.encode(e),s);this._seek(n,t)}}}_seek(e,t){throw new i("Iterator does not support seek()",{code:"LEVEL_NOT_SUPPORTED"})}close(e){if(e=n(e,c),this[w])this.nextTick(e);else if(this[g])this[b].push(e);else if(this[g]=!0,this[b].push(e),this[u]){if(this[v]){const e=this[f]();e(new i("Aborted on iterator close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))}}else this._close(this[m]);return e[c]}_close(e){this.nextTick(e)}[m](){this[w]=!0,this.db.detachResource(this);const e=this[b];this[b]=[];for(const t of e)t()}async*[Symbol.asyncIterator](){try{let e;while(void 0!==(e=await this.next()))yield e}finally{this[w]||await this.close()}}}class N extends D{constructor(e,t){super(e,t,!0),this[I]=!1!==t.keys,this[k]=!1!==t.values}[h](e,t,r){const s=this[f]();if(e)return s(e);try{t=this[I]&&void 0!==t?this[_].decode(t):void 0,r=this[k]&&void 0!==r?this[E].decode(r):void 0}catch(e){return s(new x("entry",e))}void 0===t&&void 0===r||this[T]++,s(null,t,r)}[d](e,t){const r=this[f]();if(e)return this[y](r,e);try{for(const e of t){const t=e[0],r=e[1];e[0]=this[I]&&void 0!==t?this[_].decode(t):void 0,e[1]=this[k]&&void 0!==r?this[E].decode(r):void 0}}catch(e){return this[y](r,new x("entries",e))}this[T]+=t.length,this[y](r,null,t)}end(e){return P||"undefined"===typeof s||(P=!0,s.warn(new i("The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",{code:"LEVEL_LEGACY"}))),this.close(e)}}class O extends D{constructor(e,t){super(e,t,!1)}[h](e,t){const r=this[f]();if(e)return r(e);try{t=void 0!==t?this[_].decode(t):void 0}catch(e){return r(new x("key",e))}void 0!==t&&this[T]++,r(null,t)}[d](e,t){const r=this[f]();if(e)return this[y](r,e);try{for(let e=0;e<t.length;e++){const r=t[e];t[e]=void 0!==r?this[_].decode(r):void 0}}catch(e){return this[y](r,new x("keys",e))}this[T]+=t.length,this[y](r,null,t)}}class L extends D{constructor(e,t){super(e,t,!1)}[h](e,t){const r=this[f]();if(e)return r(e);try{t=void 0!==t?this[E].decode(t):void 0}catch(e){return r(new x("value",e))}void 0!==t&&this[T]++,r(null,t)}[d](e,t){const r=this[f]();if(e)return this[y](r,e);try{for(let e=0;e<t.length;e++){const r=t[e];t[e]=void 0!==r?this[E].decode(r):void 0}}catch(e){return this[y](r,new x("values",e))}this[T]+=t.length,this[y](r,null,t)}}class x extends i{constructor(e,t){super(`Iterator could not decode ${e}`,{code:"LEVEL_DECODE_ERROR",cause:t})}}for(const M of["_ended property","_nexting property","_end method"])Object.defineProperty(N.prototype,M.split(" ")[0],{get(){throw new i(`The ${M} has been removed`,{code:"LEVEL_LEGACY"})},set(){throw new i(`The ${M} has been removed`,{code:"LEVEL_LEGACY"})}});N.keyEncoding=_,N.valueEncoding=E,t.AbstractIterator=N,t.AbstractKeyIterator=O,t.AbstractValueIterator=L},69071:function(e,t,r){"use strict";const{supports:s}=r(3658),{Transcoder:n}=r(46943),{EventEmitter:i}=r(17187),{fromCallback:o}=r(16957),a=r(94473),{AbstractIterator:c}=r(33961),{DefaultKeyIterator:l,DefaultValueIterator:u}=r(95429),{DeferredIterator:h,DeferredKeyIterator:d,DeferredValueIterator:p}=r(30593),{DefaultChainedBatch:f}=r(4765),{getCallback:y,getOptions:g}=r(92520),m=r(70056),w=Symbol("promise"),b=Symbol("landed"),_=Symbol("resources"),E=Symbol("closeResources"),v=Symbol("operations"),S=Symbol("undefer"),I=Symbol("deferOpen"),k=Symbol("options"),R=Symbol("status"),T=Symbol("defaultOptions"),A=Symbol("transcoder"),C=Symbol("keyEncoding"),P=Symbol("valueEncoding"),D=()=>{};class N extends i{constructor(e,t){if(super(),"object"!==typeof e||null===e)throw new TypeError("The first argument 'manifest' must be an object");t=g(t);const{keyEncoding:r,valueEncoding:i,passive:o,...a}=t;this[_]=new Set,this[v]=[],this[I]=!0,this[k]=a,this[R]="opening",this.supports=s(e,{status:!0,promises:!0,clear:!0,getMany:!0,deferredOpen:!0,snapshots:!1!==e.snapshots,permanence:!1!==e.permanence,keyIterator:!0,valueIterator:!0,iteratorNextv:!0,iteratorAll:!0,encodings:e.encodings||{},events:Object.assign({},e.events,{opening:!0,open:!0,closing:!0,closed:!0,put:!0,del:!0,batch:!0,clear:!0})}),this[A]=new n(x(this)),this[C]=this[A].encoding(r||"utf8"),this[P]=this[A].encoding(i||"utf8");for(const s of this[A].encodings())this.supports.encodings[s.commonName]||(this.supports.encodings[s.commonName]=!0);this[T]={empty:Object.freeze({}),entry:Object.freeze({keyEncoding:this[C].commonName,valueEncoding:this[P].commonName}),key:Object.freeze({keyEncoding:this[C].commonName})},this.nextTick((()=>{this[I]&&this.open({passive:!1},D)}))}get status(){return this[R]}keyEncoding(e){return this[A].encoding(null!=e?e:this[C])}valueEncoding(e){return this[A].encoding(null!=e?e:this[P])}open(e,t){t=y(e,t),t=o(t,w),e={...this[k],...g(e)},e.createIfMissing=!1!==e.createIfMissing,e.errorIfExists=!!e.errorIfExists;const r=e=>{"closing"===this[R]||"opening"===this[R]?this.once(b,e?()=>r(e):r):"open"!==this[R]?t(new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN",cause:e})):t()};return e.passive?"opening"===this[R]?this.once(b,r):this.nextTick(r):"closed"===this[R]||this[I]?(this[I]=!1,this[R]="opening",this.emit("opening"),this._open(e,(e=>{if(e)return this[R]="closed",this[E]((()=>{this.emit(b),r(e)})),void this[S]();this[R]="open",this[S](),this.emit(b),"open"===this[R]&&this.emit("open"),"open"===this[R]&&this.emit("ready"),r()}))):"open"===this[R]?this.nextTick(r):this.once(b,(()=>this.open(e,t))),t[w]}_open(e,t){this.nextTick(t)}close(e){e=o(e,w);const t=r=>{"opening"===this[R]||"closing"===this[R]?this.once(b,r?t(r):t):"closed"!==this[R]?e(new a("Database is not closed",{code:"LEVEL_DATABASE_NOT_CLOSED",cause:r})):e()};if("open"===this[R]){this[R]="closing",this.emit("closing");const e=e=>{this[R]="open",this[S](),this.emit(b),t(e)};this[E]((()=>{this._close((r=>{if(r)return e(r);this[R]="closed",this[S](),this.emit(b),"closed"===this[R]&&this.emit("closed"),t()}))}))}else"closed"===this[R]?this.nextTick(t):this.once(b,(()=>this.close(e)));return e[w]}[E](e){if(0===this[_].size)return this.nextTick(e);let t=this[_].size,r=!0;const s=()=>{0===--t&&(r?this.nextTick(e):e())};for(const n of this[_])n.close(s);r=!1,this[_].clear()}_close(e){this.nextTick(e)}get(e,t,r){if(r=y(t,r),r=o(r,w),t=g(t,this[T].entry),"opening"===this[R])return this.defer((()=>this.get(e,t,r))),r[w];if(L(this,r))return r[w];const s=this._checkKey(e);if(s)return this.nextTick(r,s),r[w];const n=this.keyEncoding(t.keyEncoding),i=this.valueEncoding(t.valueEncoding),c=n.format,l=i.format;return t.keyEncoding===c&&t.valueEncoding===l||(t=Object.assign({},t,{keyEncoding:c,valueEncoding:l})),this._get(this.prefixKey(n.encode(e),c),t,((e,t)=>{if(e)return("LEVEL_NOT_FOUND"===e.code||e.notFound||/NotFound/i.test(e))&&(e.code||(e.code="LEVEL_NOT_FOUND"),e.notFound||(e.notFound=!0),e.status||(e.status=404)),r(e);try{t=i.decode(t)}catch(e){return r(new a("Could not decode value",{code:"LEVEL_DECODE_ERROR",cause:e}))}r(null,t)})),r[w]}_get(e,t,r){this.nextTick(r,new Error("NotFound"))}getMany(e,t,r){if(r=y(t,r),r=o(r,w),t=g(t,this[T].entry),"opening"===this[R])return this.defer((()=>this.getMany(e,t,r))),r[w];if(L(this,r))return r[w];if(!Array.isArray(e))return this.nextTick(r,new TypeError("The first argument 'keys' must be an array")),r[w];if(0===e.length)return this.nextTick(r,null,[]),r[w];const s=this.keyEncoding(t.keyEncoding),n=this.valueEncoding(t.valueEncoding),i=s.format,c=n.format;t.keyEncoding===i&&t.valueEncoding===c||(t=Object.assign({},t,{keyEncoding:i,valueEncoding:c}));const l=new Array(e.length);for(let o=0;o<e.length;o++){const t=e[o],n=this._checkKey(t);if(n)return this.nextTick(r,n),r[w];l[o]=this.prefixKey(s.encode(t),i)}return this._getMany(l,t,((e,t)=>{if(e)return r(e);try{for(let e=0;e<t.length;e++)void 0!==t[e]&&(t[e]=n.decode(t[e]))}catch(e){return r(new a(`Could not decode one or more of ${t.length} value(s)`,{code:"LEVEL_DECODE_ERROR",cause:e}))}r(null,t)})),r[w]}_getMany(e,t,r){this.nextTick(r,null,new Array(e.length).fill(void 0))}put(e,t,r,s){if(s=y(r,s),s=o(s,w),r=g(r,this[T].entry),"opening"===this[R])return this.defer((()=>this.put(e,t,r,s))),s[w];if(L(this,s))return s[w];const n=this._checkKey(e)||this._checkValue(t);if(n)return this.nextTick(s,n),s[w];const i=this.keyEncoding(r.keyEncoding),a=this.valueEncoding(r.valueEncoding),c=i.format,l=a.format;r.keyEncoding===c&&r.valueEncoding===l||(r=Object.assign({},r,{keyEncoding:c,valueEncoding:l}));const u=this.prefixKey(i.encode(e),c),h=a.encode(t);return this._put(u,h,r,(r=>{if(r)return s(r);this.emit("put",e,t),s()})),s[w]}_put(e,t,r,s){this.nextTick(s)}del(e,t,r){if(r=y(t,r),r=o(r,w),t=g(t,this[T].key),"opening"===this[R])return this.defer((()=>this.del(e,t,r))),r[w];if(L(this,r))return r[w];const s=this._checkKey(e);if(s)return this.nextTick(r,s),r[w];const n=this.keyEncoding(t.keyEncoding),i=n.format;return t.keyEncoding!==i&&(t=Object.assign({},t,{keyEncoding:i})),this._del(this.prefixKey(n.encode(e),i),t,(t=>{if(t)return r(t);this.emit("del",e),r()})),r[w]}_del(e,t,r){this.nextTick(r)}batch(e,t,r){if(!arguments.length){if("opening"===this[R])return new f(this);if("open"!==this[R])throw new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._chainedBatch()}if(r="function"===typeof e?e:y(t,r),r=o(r,w),t=g(t,this[T].empty),"opening"===this[R])return this.defer((()=>this.batch(e,t,r))),r[w];if(L(this,r))return r[w];if(!Array.isArray(e))return this.nextTick(r,new TypeError("The first argument 'operations' must be an array")),r[w];if(0===e.length)return this.nextTick(r),r[w];const s=new Array(e.length),{keyEncoding:n,valueEncoding:i,...c}=t;for(let o=0;o<e.length;o++){if("object"!==typeof e[o]||null===e[o])return this.nextTick(r,new TypeError("A batch operation must be an object")),r[w];const t=Object.assign({},e[o]);if("put"!==t.type&&"del"!==t.type)return this.nextTick(r,new TypeError("A batch operation must have a type property that is 'put' or 'del'")),r[w];const a=this._checkKey(t.key);if(a)return this.nextTick(r,a),r[w];const c=null!=t.sublevel?t.sublevel:this,l=c.keyEncoding(t.keyEncoding||n),u=l.format;if(t.key=c.prefixKey(l.encode(t.key),u),t.keyEncoding=u,"put"===t.type){const e=this._checkValue(t.value);if(e)return this.nextTick(r,e),r[w];const s=c.valueEncoding(t.valueEncoding||i);t.value=s.encode(t.value),t.valueEncoding=s.format}c!==this&&(t.sublevel=null),s[o]=t}return this._batch(s,c,(t=>{if(t)return r(t);this.emit("batch",e),r()})),r[w]}_batch(e,t,r){this.nextTick(r)}sublevel(e,t){return this._sublevel(e,O.defaults(t))}_sublevel(e,t){return new O(this,e,t)}prefixKey(e,t){return e}clear(e,t){if(t=y(e,t),t=o(t,w),e=g(e,this[T].empty),"opening"===this[R])return this.defer((()=>this.clear(e,t))),t[w];if(L(this,t))return t[w];const r=e,s=this.keyEncoding(e.keyEncoding);return e=m(e,s),e.keyEncoding=s.format,0===e.limit?this.nextTick(t):this._clear(e,(e=>{if(e)return t(e);this.emit("clear",r),t()})),t[w]}_clear(e,t){this.nextTick(t)}iterator(e){const t=this.keyEncoding(e&&e.keyEncoding),r=this.valueEncoding(e&&e.valueEncoding);if(e=m(e,t),e.keys=!1!==e.keys,e.values=!1!==e.values,e[c.keyEncoding]=t,e[c.valueEncoding]=r,e.keyEncoding=t.format,e.valueEncoding=r.format,"opening"===this[R])return new h(this,e);if("open"!==this[R])throw new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._iterator(e)}_iterator(e){return new c(this,e)}keys(e){const t=this.keyEncoding(e&&e.keyEncoding),r=this.valueEncoding(e&&e.valueEncoding);if(e=m(e,t),e[c.keyEncoding]=t,e[c.valueEncoding]=r,e.keyEncoding=t.format,e.valueEncoding=r.format,"opening"===this[R])return new d(this,e);if("open"!==this[R])throw new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._keys(e)}_keys(e){return new l(this,e)}values(e){const t=this.keyEncoding(e&&e.keyEncoding),r=this.valueEncoding(e&&e.valueEncoding);if(e=m(e,t),e[c.keyEncoding]=t,e[c.valueEncoding]=r,e.keyEncoding=t.format,e.valueEncoding=r.format,"opening"===this[R])return new p(this,e);if("open"!==this[R])throw new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"});return this._values(e)}_values(e){return new u(this,e)}defer(e){if("function"!==typeof e)throw new TypeError("The first argument must be a function");this[v].push(e)}[S](){if(0===this[v].length)return;const e=this[v];this[v]=[];for(const t of e)t()}attachResource(e){if("object"!==typeof e||null===e||"function"!==typeof e.close)throw new TypeError("The first argument must be a resource object");this[_].add(e)}detachResource(e){this[_].delete(e)}_chainedBatch(){return new f(this)}_checkKey(e){if(null===e||void 0===e)return new a("Key cannot be null or undefined",{code:"LEVEL_INVALID_KEY"})}_checkValue(e){if(null===e||void 0===e)return new a("Value cannot be null or undefined",{code:"LEVEL_INVALID_VALUE"})}}N.prototype.nextTick=r(56909);const{AbstractSublevel:O}=r(59650)({AbstractLevel:N});t.AbstractLevel=N,t.AbstractSublevel=O;const L=function(e,t){return"open"!==e[R]&&(e.nextTick(t,new a("Database is not open",{code:"LEVEL_DATABASE_NOT_OPEN"})),!0)},x=function(e){return Object.keys(e.supports.encodings).filter((t=>!!e.supports.encodings[t]))}},50875:function(e,t,r){"use strict";t.AbstractLevel=r(69071).AbstractLevel,t.AbstractSublevel=r(69071).AbstractSublevel,t.AbstractIterator=r(33961).AbstractIterator,t.AbstractKeyIterator=r(33961).AbstractKeyIterator,t.AbstractValueIterator=r(33961).AbstractValueIterator,t.AbstractChainedBatch=r(19464).AbstractChainedBatch},82970:function(e,t,r){"use strict";const{AbstractIterator:s,AbstractKeyIterator:n,AbstractValueIterator:i}=r(33961),o=Symbol("unfix"),a=Symbol("iterator"),c=Symbol("handleOne"),l=Symbol("handleMany"),u=Symbol("callback");class h extends s{constructor(e,t,r,s){super(e,t),this[a]=r,this[o]=s,this[c]=this[c].bind(this),this[l]=this[l].bind(this),this[u]=null}[c](e,t,r){const s=this[u];if(e)return s(e);void 0!==t&&(t=this[o](t)),s(e,t,r)}[l](e,t){const r=this[u];if(e)return r(e);for(const s of t){const e=s[0];void 0!==e&&(s[0]=this[o](e))}r(e,t)}}class d extends n{constructor(e,t,r,s){super(e,t),this[a]=r,this[o]=s,this[c]=this[c].bind(this),this[l]=this[l].bind(this),this[u]=null}[c](e,t){const r=this[u];if(e)return r(e);void 0!==t&&(t=this[o](t)),r(e,t)}[l](e,t){const r=this[u];if(e)return r(e);for(let s=0;s<t.length;s++){const e=t[s];void 0!==e&&(t[s]=this[o](e))}r(e,t)}}class p extends i{constructor(e,t,r){super(e,t),this[a]=r}}for(const f of[h,d])f.prototype._next=function(e){this[u]=e,this[a].next(this[c])},f.prototype._nextv=function(e,t,r){this[u]=r,this[a].nextv(e,t,this[l])},f.prototype._all=function(e,t){this[u]=t,this[a].all(e,this[l])};for(const f of[p])f.prototype._next=function(e){this[a].next(e)},f.prototype._nextv=function(e,t,r){this[a].nextv(e,t,r)},f.prototype._all=function(e,t){this[a].all(e,t)};for(const f of[h,d,p])f.prototype._seek=function(e,t){this[a].seek(e,t)},f.prototype._close=function(e){this[a].close(e)};t.AbstractSublevelIterator=h,t.AbstractSublevelKeyIterator=d,t.AbstractSublevelValueIterator=p},59650:function(e,t,r){"use strict";const s=r(94473),{Buffer:n}=r(48764)||{},{AbstractSublevelIterator:i,AbstractSublevelKeyIterator:o,AbstractSublevelValueIterator:a}=r(82970),c=Symbol("prefix"),l=Symbol("upperBound"),u=Symbol("prefixRange"),h=Symbol("parent"),d=Symbol("unfix"),p=new TextEncoder,f={separator:"!"};e.exports=function({AbstractLevel:e}){class t extends e{static defaults(e){if("string"===typeof e)throw new s("The subleveldown string shorthand for { separator } has been removed",{code:"LEVEL_LEGACY"});if(e&&e.open)throw new s("The subleveldown open option has been removed",{code:"LEVEL_LEGACY"});return null==e?f:e.separator?e:{...e,separator:"!"}}constructor(e,r,n){const{separator:i,manifest:o,...a}=t.defaults(n);r=b(r,i);const u=i.charCodeAt(0)+1,f=e[h]||e;if(!p.encode(r).every((e=>e>u&&e<127)))throw new s(`Prefix must use bytes > ${u} < 127`,{code:"LEVEL_INVALID_PREFIX"});super(y(f,o),a);const g=(e.prefix||"")+i+r+i,_=g.slice(0,-1)+String.fromCharCode(u);this[h]=f,this[c]=new m(g),this[l]=new m(_),this[d]=new w,this.nextTick=f.nextTick}prefixKey(e,t){if("utf8"===t)return this[c].utf8+e;if(0===e.byteLength)return this[c][t];if("view"===t){const t=this[c].view,r=new Uint8Array(t.byteLength+e.byteLength);return r.set(t,0),r.set(e,t.byteLength),r}{const t=this[c].buffer;return n.concat([t,e],t.byteLength+e.byteLength)}}[u](e,t){void 0!==e.gte?e.gte=this.prefixKey(e.gte,t):void 0!==e.gt?e.gt=this.prefixKey(e.gt,t):e.gte=this[c][t],void 0!==e.lte?e.lte=this.prefixKey(e.lte,t):void 0!==e.lt?e.lt=this.prefixKey(e.lt,t):e.lte=this[l][t]}get prefix(){return this[c].utf8}get db(){return this[h]}_open(e,t){this[h].open({passive:!0},t)}_put(e,t,r,s){this[h].put(e,t,r,s)}_get(e,t,r){this[h].get(e,t,r)}_getMany(e,t,r){this[h].getMany(e,t,r)}_del(e,t,r){this[h].del(e,t,r)}_batch(e,t,r){this[h].batch(e,t,r)}_clear(e,t){this[u](e,e.keyEncoding),this[h].clear(e,t)}_iterator(e){this[u](e,e.keyEncoding);const t=this[h].iterator(e),r=this[d].get(this[c].utf8.length,e.keyEncoding);return new i(this,e,t,r)}_keys(e){this[u](e,e.keyEncoding);const t=this[h].keys(e),r=this[d].get(this[c].utf8.length,e.keyEncoding);return new o(this,e,t,r)}_values(e){this[u](e,e.keyEncoding);const t=this[h].values(e);return new a(this,e,t)}}return{AbstractSublevel:t}};const y=function(e,t){return{...e.supports,createIfMissing:!1,errorIfExists:!1,events:{},additionalMethods:{},...t,encodings:{utf8:g(e,"utf8"),buffer:g(e,"buffer"),view:g(e,"view")}}},g=function(e,t){return!!e.supports.encodings[t]&&e.keyEncoding(t).name===t};class m{constructor(e){this.utf8=e,this.view=p.encode(e),this.buffer=n?n.from(this.view.buffer,0,this.view.byteLength):{}}}class w{constructor(){this.cache=new Map}get(e,t){let r=this.cache.get(t);return void 0===r&&(r="view"===t?function(e,t){return t.subarray(e)}.bind(null,e):function(e,t){return t.slice(e)}.bind(null,e),this.cache.set(t,r)),r}}const b=function(e,t){let r=0,s=e.length;while(r<s&&e[r]===t)r++;while(s>r&&e[s-1]===t)s--;return e.slice(r,s)}},92520:function(e,t){"use strict";t.getCallback=function(e,t){return"function"===typeof e?e:t},t.getOptions=function(e,t){return"object"===typeof e&&null!==e?e:void 0!==t?t:{}}},4765:function(e,t,r){"use strict";const{AbstractChainedBatch:s}=r(19464),n=r(94473),i=Symbol("encoded");class o extends s{constructor(e){super(e),this[i]=[]}_put(e,t,r){this[i].push({...r,type:"put",key:e,value:t})}_del(e,t){this[i].push({...t,type:"del",key:e})}_clear(){this[i]=[]}_write(e,t){"opening"===this.db.status?this.db.defer((()=>this._write(e,t))):"open"===this.db.status?0===this[i].length?this.nextTick(t):this.db._batch(this[i],e,t):this.nextTick(t,new n("Batch is not open: cannot call write() after write() or close()",{code:"LEVEL_BATCH_NOT_OPEN"}))}}t.DefaultChainedBatch=o},95429:function(e,t,r){"use strict";const{AbstractKeyIterator:s,AbstractValueIterator:n}=r(33961),i=Symbol("iterator"),o=Symbol("callback"),a=Symbol("handleOne"),c=Symbol("handleMany");class l extends s{constructor(e,t){super(e,t),this[i]=e.iterator({...t,keys:!0,values:!1}),this[a]=this[a].bind(this),this[c]=this[c].bind(this)}}class u extends n{constructor(e,t){super(e,t),this[i]=e.iterator({...t,keys:!1,values:!0}),this[a]=this[a].bind(this),this[c]=this[c].bind(this)}}for(const h of[l,u]){const e=h===l,t=e?e=>e[0]:e=>e[1];h.prototype._next=function(e){this[o]=e,this[i].next(this[a])},h.prototype[a]=function(t,r,s){const n=this[o];t?n(t):n(null,e?r:s)},h.prototype._nextv=function(e,t,r){this[o]=r,this[i].nextv(e,t,this[c])},h.prototype._all=function(e,t){this[o]=t,this[i].all(e,this[c])},h.prototype[c]=function(e,r){const s=this[o];e?s(e):s(null,r.map(t))},h.prototype._seek=function(e,t){this[i].seek(e,t)},h.prototype._close=function(e){this[i].close(e)}}t.DefaultKeyIterator=l,t.DefaultValueIterator=u},30593:function(e,t,r){"use strict";const{AbstractIterator:s,AbstractKeyIterator:n,AbstractValueIterator:i}=r(33961),o=r(94473),a=Symbol("nut"),c=Symbol("undefer"),l=Symbol("factory");class u extends s{constructor(e,t){super(e,t),this[a]=null,this[l]=()=>e.iterator(t),this.db.defer((()=>this[c]()))}}class h extends n{constructor(e,t){super(e,t),this[a]=null,this[l]=()=>e.keys(t),this.db.defer((()=>this[c]()))}}class d extends i{constructor(e,t){super(e,t),this[a]=null,this[l]=()=>e.values(t),this.db.defer((()=>this[c]()))}}for(const p of[u,h,d])p.prototype[c]=function(){"open"===this.db.status&&(this[a]=this[l]())},p.prototype._next=function(e){null!==this[a]?this[a].next(e):"opening"===this.db.status?this.db.defer((()=>this._next(e))):this.nextTick(e,new o("Iterator is not open: cannot call next() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},p.prototype._nextv=function(e,t,r){null!==this[a]?this[a].nextv(e,t,r):"opening"===this.db.status?this.db.defer((()=>this._nextv(e,t,r))):this.nextTick(r,new o("Iterator is not open: cannot call nextv() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},p.prototype._all=function(e,t){null!==this[a]?this[a].all(t):"opening"===this.db.status?this.db.defer((()=>this._all(e,t))):this.nextTick(t,new o("Iterator is not open: cannot call all() after close()",{code:"LEVEL_ITERATOR_NOT_OPEN"}))},p.prototype._seek=function(e,t){null!==this[a]?this[a]._seek(e,t):"opening"===this.db.status&&this.db.defer((()=>this._seek(e,t)))},p.prototype._close=function(e){null!==this[a]?this[a].close(e):"opening"===this.db.status?this.db.defer((()=>this._close(e))):this.nextTick(e)};t.DeferredIterator=u,t.DeferredKeyIterator=h,t.DeferredValueIterator=d},56909:function(e,t,r){"use strict";const s=r(54375);e.exports=function(e,...t){0===t.length?s(e):s((()=>e(...t)))}},70056:function(e,t,r){"use strict";const s=r(94473),n=Object.prototype.hasOwnProperty,i=new Set(["lt","lte","gt","gte"]);e.exports=function(e,t){const r={};for(const o in e)if(n.call(e,o)&&"keyEncoding"!==o&&"valueEncoding"!==o){if("start"===o||"end"===o)throw new s(`The legacy range option '${o}' has been removed`,{code:"LEVEL_LEGACY"});if("encoding"===o)throw new s("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead",{code:"LEVEL_LEGACY"});i.has(o)?r[o]=t.encode(e[o]):r[o]=e[o]}return r.reverse=!!r.reverse,r.limit=Number.isInteger(r.limit)&&r.limit>=0?r.limit:-1,r}},3658:function(e,t){"use strict";t.supports=function(...e){const t=e.reduce(((e,t)=>Object.assign(e,t)),{});return Object.assign(t,{snapshots:t.snapshots||!1,permanence:t.permanence||!1,seek:t.seek||!1,clear:t.clear||!1,getMany:t.getMany||!1,keyIterator:t.keyIterator||!1,valueIterator:t.valueIterator||!1,iteratorNextv:t.iteratorNextv||!1,iteratorAll:t.iteratorAll||!1,status:t.status||!1,createIfMissing:t.createIfMissing||!1,errorIfExists:t.errorIfExists||!1,deferredOpen:t.deferredOpen||!1,promises:t.promises||!1,streams:t.streams||!1,encodings:Object.assign({},t.encodings),events:Object.assign({},t.events),additionalMethods:Object.assign({},t.additionalMethods)})}},9668:function(e,t,r){"use strict";const{Buffer:s}=r(48764),n=Symbol.for("BufferList");function i(e){if(!(this instanceof i))return new i(e);i._init.call(this,e)}i._init=function(e){Object.defineProperty(this,n,{value:!0}),this._bufs=[],this.length=0,e&&this.append(e)},i.prototype._new=function(e){return new i(e)},i.prototype._offset=function(e){if(0===e)return[0,0];let t=0;for(let r=0;r<this._bufs.length;r++){const s=t+this._bufs[r].length;if(e<s||r===this._bufs.length-1)return[r,e-t];t=s}},i.prototype._reverseOffset=function(e){const t=e[0];let r=e[1];for(let s=0;s<t;s++)r+=this._bufs[s].length;return r},i.prototype.get=function(e){if(e>this.length||e<0)return;const t=this._offset(e);return this._bufs[t[0]][t[1]]},i.prototype.slice=function(e,t){return"number"===typeof e&&e<0&&(e+=this.length),"number"===typeof t&&t<0&&(t+=this.length),this.copy(null,0,e,t)},i.prototype.copy=function(e,t,r,n){if(("number"!==typeof r||r<0)&&(r=0),("number"!==typeof n||n>this.length)&&(n=this.length),r>=this.length)return e||s.alloc(0);if(n<=0)return e||s.alloc(0);const i=!!e,o=this._offset(r),a=n-r;let c=a,l=i&&t||0,u=o[1];if(0===r&&n===this.length){if(!i)return 1===this._bufs.length?this._bufs[0]:s.concat(this._bufs,this.length);for(let t=0;t<this._bufs.length;t++)this._bufs[t].copy(e,l),l+=this._bufs[t].length;return e}if(c<=this._bufs[o[0]].length-u)return i?this._bufs[o[0]].copy(e,t,u,u+c):this._bufs[o[0]].slice(u,u+c);i||(e=s.allocUnsafe(a));for(let s=o[0];s<this._bufs.length;s++){const t=this._bufs[s].length-u;if(!(c>t)){this._bufs[s].copy(e,l,u,u+c),l+=t;break}this._bufs[s].copy(e,l,u),l+=t,c-=t,u&&(u=0)}return e.length>l?e.slice(0,l):e},i.prototype.shallowSlice=function(e,t){if(e=e||0,t="number"!==typeof t?this.length:t,e<0&&(e+=this.length),t<0&&(t+=this.length),e===t)return this._new();const r=this._offset(e),s=this._offset(t),n=this._bufs.slice(r[0],s[0]+1);return 0===s[1]?n.pop():n[n.length-1]=n[n.length-1].slice(0,s[1]),0!==r[1]&&(n[0]=n[0].slice(r[1])),this._new(n)},i.prototype.toString=function(e,t,r){return this.slice(t,r).toString(e)},i.prototype.consume=function(e){if(e=Math.trunc(e),Number.isNaN(e)||e<=0)return this;while(this._bufs.length){if(!(e>=this._bufs[0].length)){this._bufs[0]=this._bufs[0].slice(e),this.length-=e;break}e-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift()}return this},i.prototype.duplicate=function(){const e=this._new();for(let t=0;t<this._bufs.length;t++)e.append(this._bufs[t]);return e},i.prototype.append=function(e){if(null==e)return this;if(e.buffer)this._appendBuffer(s.from(e.buffer,e.byteOffset,e.byteLength));else if(Array.isArray(e))for(let t=0;t<e.length;t++)this.append(e[t]);else if(this._isBufferList(e))for(let t=0;t<e._bufs.length;t++)this.append(e._bufs[t]);else"number"===typeof e&&(e=e.toString()),this._appendBuffer(s.from(e));return this},i.prototype._appendBuffer=function(e){this._bufs.push(e),this.length+=e.length},i.prototype.indexOf=function(e,t,r){if(void 0===r&&"string"===typeof t&&(r=t,t=void 0),"function"===typeof e||Array.isArray(e))throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if("number"===typeof e?e=s.from([e]):"string"===typeof e?e=s.from(e,r):this._isBufferList(e)?e=e.slice():Array.isArray(e.buffer)?e=s.from(e.buffer,e.byteOffset,e.byteLength):s.isBuffer(e)||(e=s.from(e)),t=Number(t||0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),0===e.length)return t>this.length?this.length:t;const n=this._offset(t);let i=n[0],o=n[1];for(;i<this._bufs.length;i++){const t=this._bufs[i];while(o<t.length){const r=t.length-o;if(r>=e.length){const r=t.indexOf(e,o);if(-1!==r)return this._reverseOffset([i,r]);o=t.length-e.length+1}else{const t=this._reverseOffset([i,o]);if(this._match(t,e))return t;o++}}o=0}return-1},i.prototype._match=function(e,t){if(this.length-e<t.length)return!1;for(let r=0;r<t.length;r++)if(this.get(e+r)!==t[r])return!1;return!0},function(){const e={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(const t in e)(function(t){null===e[t]?i.prototype[t]=function(e,r){return this.slice(e,e+r)[t](0,r)}:i.prototype[t]=function(r=0){return this.slice(r,r+e[t])[t](0)}})(t)}(),i.prototype._isBufferList=function(e){return e instanceof i||i.isBufferList(e)},i.isBufferList=function(e){return null!=e&&e[n]},e.exports=i},23294:function(e,t,r){"use strict";const s=r(86154);function n(e){return"function"===typeof e.stream?s(e.stream()):s(new Response(e).body)}e.exports=n},11708:function(e,t,r){"use strict";const{AbstractLevel:s}=r(50875),n=r(94473),i=r(29967),{fromCallback:o}=r(16957),{Iterator:a}=r(8212),c=r(89687),l=r(89968),u=r(21217),h="level-js-",d=Symbol("idb"),p=Symbol("namePrefix"),f=Symbol("location"),y=Symbol("version"),g=Symbol("store"),m=Symbol("onComplete"),w=Symbol("promise");class b extends s{constructor(e,t,r){if("function"===typeof t||"function"===typeof r)throw new n("The levelup-style callback argument has been removed",{code:"LEVEL_LEGACY"});const{prefix:s,version:i,...o}=t||{};if(super({encodings:{view:!0},snapshots:!1,createIfMissing:!1,errorIfExists:!1,seek:!0},o),"string"!==typeof e)throw new Error("constructor requires a location string argument");this[f]=e,this[p]=null==s?h:s,this[y]=parseInt(i||1,10),this[d]=null}get location(){return this[f]}get namePrefix(){return this[p]}get version(){return this[y]}get db(){return this[d]}get type(){return"browser-level"}_open(e,t){const r=indexedDB.open(this[p]+this[f],this[y]);r.onerror=function(){t(r.error||new Error("unknown error"))},r.onsuccess=()=>{this[d]=r.result,t()},r.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains(this[f])||t.createObjectStore(this[f])}}[g](e){const t=this[d].transaction([this[f]],e);return t.objectStore(this[f])}[m](e,t){const r=e.transaction;r.onabort=function(){t(r.error||new Error("aborted by user"))},r.oncomplete=function(){t(null,e.result)}}_get(e,t,r){const s=this[g]("readonly");let i;try{i=s.get(e)}catch(o){return this.nextTick(r,o)}this[m](i,(function(e,t){return e?r(e):void 0===t?r(new n("Entry not found",{code:"LEVEL_NOT_FOUND"})):void r(null,c(t))}))}_getMany(e,t,r){const s=this[g]("readonly"),n=e.map((e=>t=>{let r;try{r=s.get(e)}catch(n){return t(n)}r.onsuccess=()=>{const e=r.result;t(null,void 0===e?e:c(e))},r.onerror=e=>{e.stopPropagation(),t(r.error)}}));i(n,16,r)}_del(e,t,r){const s=this[g]("readwrite");let n;try{n=s.delete(e)}catch(i){return this.nextTick(r,i)}this[m](n,r)}_put(e,t,r,s){const n=this[g]("readwrite");let i;try{i=n.put(t,e)}catch(o){return this.nextTick(s,o)}this[m](i,s)}_iterator(e){return new a(this,this[f],e)}_batch(e,t,r){const s=this[g]("readwrite"),n=s.transaction;let i,o=0;function a(){const t=e[o++],r=t.key;let c;try{c="del"===t.type?s.delete(r):s.put(t.value,r)}catch(l){return i=l,void n.abort()}o<e.length?c.onsuccess=a:"function"===typeof n.commit&&n.commit()}n.onabort=function(){r(i||n.error||new Error("aborted by user"))},n.oncomplete=function(){r()},a()}_clear(e,t){let r,s;try{r=u(e)}catch(n){return this.nextTick(t)}if(e.limit>=0)return l(this,this[f],r,e,t);try{const e=this[g]("readwrite");s=r?e.delete(r):e.clear()}catch(i){return this.nextTick(t,i)}this[m](s,t)}_close(e){this[d].close(),this.nextTick(e)}}b.destroy=function(e,t,r){"function"===typeof t&&(r=t,t=h),r=o(r,w);const s=indexedDB.deleteDatabase(t+e);return s.onsuccess=function(){r()},s.onerror=function(e){r(e)},r[w]},t.BrowserLevel=b},8212:function(e,t,r){"use strict";const{AbstractIterator:s}=r(50875),n=r(21217),i=r(89687),o=Symbol("cache"),a=Symbol("finished"),c=Symbol("options"),l=Symbol("currentOptions"),u=Symbol("position"),h=Symbol("location"),d=Symbol("first"),p={};class f extends s{constructor(e,t,r){super(e,r),this[o]=[],this[a]=0===this.limit,this[c]=r,this[l]={...r},this[u]=void 0,this[h]=t,this[d]=!0}_nextv(e,t,r){if(this[d]=!1,this[a])return this.nextTick(r,null,[]);if(this[o].length>0)return e=Math.min(e,this[o].length),this.nextTick(r,null,this[o].splice(0,e));let s;void 0!==this[u]&&(this[c].reverse?(this[l].lt=this[u],this[l].lte=void 0):(this[l].gt=this[u],this[l].gte=void 0));try{s=n(this[l])}catch(m){return this[a]=!0,this.nextTick(r,null,[])}const p=this.db.db.transaction([this[h]],"readonly"),f=p.objectStore(this[h]),g=[];if(this[c].reverse){const t=!this[c].values&&f.openKeyCursor?"openKeyCursor":"openCursor";f[t](s,"prev").onsuccess=t=>{const r=t.target.result;if(r){const{key:t,value:s}=r;this[u]=t,g.push([this[c].keys&&void 0!==t?i(t):void 0,this[c].values&&void 0!==s?i(s):void 0]),g.length<e?r.continue():y(p)}else this[a]=!0}}else{let t,r;const n=()=>{if(void 0===t||void 0===r)return;const s=Math.max(t.length,r.length);0===s||e===1/0?this[a]=!0:this[u]=t[s-1],g.length=s;for(let e=0;e<s;e++){const s=t[e],n=r[e];g[e]=[this[c].keys&&void 0!==s?i(s):void 0,this[c].values&&void 0!==n?i(n):void 0]}y(p)};this[c].keys||e<1/0?f.getAllKeys(s,e<1/0?e:void 0).onsuccess=e=>{t=e.target.result,n()}:(t=[],this.nextTick(n)),this[c].values?f.getAll(s,e<1/0?e:void 0).onsuccess=e=>{r=e.target.result,n()}:(r=[],this.nextTick(n))}p.onabort=()=>{r(p.error||new Error("aborted by user")),r=null},p.oncomplete=()=>{r(null,g),r=null}}_next(e){if(this[o].length>0){const[t,r]=this[o].shift();this.nextTick(e,null,t,r)}else if(this[a])this.nextTick(e);else{let t=Math.min(100,this.limit-this.count);this[d]&&(this[d]=!1,t=1),this._nextv(t,p,((t,r)=>{if(t)return e(t);this[o]=r,this._next(e)}))}}_all(e,t){this[d]=!1;const r=this[o].splice(0,this[o].length),s=this.limit-this.count-r.length;if(s<=0)return this.nextTick(t,null,r);this._nextv(s,p,((e,s)=>{if(e)return t(e);r.length>0&&(s=r.concat(s)),t(null,s)}))}_seek(e,t){let r;this[d]=!0,this[o]=[],this[a]=!1,this[u]=void 0,this[l]={...this[c]};try{r=n(this[c])}catch(s){return void(this[a]=!0)}null===r||r.includes(e)?this[c].reverse?this[l].lte=e:this[l].gte=e:this[a]=!0}}function y(e){"function"===typeof e.commit&&e.commit()}t.Iterator=f},89968:function(e){"use strict";e.exports=function(e,t,r,s,n){if(0===s.limit)return e.nextTick(n);const i=e.db.transaction([t],"readwrite"),o=i.objectStore(t);let a=0;i.oncomplete=function(){n()},i.onabort=function(){n(i.error||new Error("aborted by user"))};const c=o.openKeyCursor?"openKeyCursor":"openCursor",l=s.reverse?"prev":"next";o[c](r,l).onsuccess=function(e){const t=e.target.result;t&&(o.delete(t.key).onsuccess=function(){(s.limit<=0||++a<s.limit)&&t.continue()})}}},89687:function(e){"use strict";const t=new TextEncoder;e.exports=function(e){return e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):t.encode(e)}},21217:function(e){"use strict";e.exports=function(e){const t=void 0!==e.gte?e.gte:void 0!==e.gt?e.gt:void 0,r=void 0!==e.lte?e.lte:void 0!==e.lt?e.lt:void 0,s=void 0===e.gte,n=void 0===e.lte;return void 0!==t&&void 0!==r?IDBKeyRange.bound(t,r,s,n):void 0!==t?IDBKeyRange.lowerBound(t,s):void 0!==r?IDBKeyRange.upperBound(r,n):null}},86154:function(e){"use strict";async function*t(e,t={}){const r=e.getReader();try{while(1){const e=await r.read();if(e.done)return;yield e.value}}finally{!0!==t.preventCancel&&r.cancel(),r.releaseLock()}}e.exports=t},79830:function(e){"use strict";
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */e.exports=i,e.exports.format=o,e.exports.parse=a;var t=/\B(?=(\d{3})+(?!\d))/g,r=/(?:\.0*|(\.[^0]+)0+)$/,s={b:1,kb:1024,mb:1<<20,gb:1<<30,tb:Math.pow(1024,4),pb:Math.pow(1024,5)},n=/^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;function i(e,t){return"string"===typeof e?a(e):"number"===typeof e?o(e,t):null}function o(e,n){if(!Number.isFinite(e))return null;var i=Math.abs(e),o=n&&n.thousandsSeparator||"",a=n&&n.unitSeparator||"",c=n&&void 0!==n.decimalPlaces?n.decimalPlaces:2,l=Boolean(n&&n.fixedDecimals),u=n&&n.unit||"";u&&s[u.toLowerCase()]||(u=i>=s.pb?"PB":i>=s.tb?"TB":i>=s.gb?"GB":i>=s.mb?"MB":i>=s.kb?"KB":"B");var h=e/s[u.toLowerCase()],d=h.toFixed(c);return l||(d=d.replace(r,"$1")),o&&(d=d.split(".").map((function(e,r){return 0===r?e.replace(t,o):e})).join(".")),d+a+u}function a(e){if("number"===typeof e&&!isNaN(e))return e;if("string"!==typeof e)return null;var t,r=n.exec(e),i="b";return r?(t=parseFloat(r[1]),i=r[4].toLowerCase()):(t=parseInt(e,10),i="b"),isNaN(t)?null:Math.floor(s[i]*t)}},69202:function(e,t,r){t.Level=r(11708).BrowserLevel},45001:function(e){"use strict";function t(e,t){t=t||{};this._head=0,this._tail=0,this._capacity=t.capacity,this._capacityMask=3,this._list=new Array(4),Array.isArray(e)&&this._fromArray(e)}t.prototype.peekAt=function(e){var t=e;if(t===(0|t)){var r=this.size();if(!(t>=r||t<-r))return t<0&&(t+=r),t=this._head+t&this._capacityMask,this._list[t]}},t.prototype.get=function(e){return this.peekAt(e)},t.prototype.peek=function(){if(this._head!==this._tail)return this._list[this._head]},t.prototype.peekFront=function(){return this.peek()},t.prototype.peekBack=function(){return this.peekAt(-1)},Object.defineProperty(t.prototype,"length",{get:function(){return this.size()}}),t.prototype.size=function(){return this._head===this._tail?0:this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.unshift=function(e){if(void 0===e)return this.size();var t=this._list.length;return this._head=this._head-1+t&this._capacityMask,this._list[this._head]=e,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.pop(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.shift=function(){var e=this._head;if(e!==this._tail){var t=this._list[e];return this._list[e]=void 0,this._head=e+1&this._capacityMask,e<2&&this._tail>1e4&&this._tail<=this._list.length>>>2&&this._shrinkArray(),t}},t.prototype.push=function(e){if(void 0===e)return this.size();var t=this._tail;return this._list[t]=e,this._tail=t+1&this._capacityMask,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.shift(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)},t.prototype.pop=function(){var e=this._tail;if(e!==this._head){var t=this._list.length;this._tail=e-1+t&this._capacityMask;var r=this._list[this._tail];return this._list[this._tail]=void 0,this._head<2&&e>1e4&&e<=t>>>2&&this._shrinkArray(),r}},t.prototype.removeOne=function(e){var t=e;if(t===(0|t)&&this._head!==this._tail){var r=this.size(),s=this._list.length;if(!(t>=r||t<-r)){t<0&&(t+=r),t=this._head+t&this._capacityMask;var n,i=this._list[t];if(e<r/2){for(n=e;n>0;n--)this._list[t]=this._list[t=t-1+s&this._capacityMask];this._list[t]=void 0,this._head=this._head+1+s&this._capacityMask}else{for(n=r-1-e;n>0;n--)this._list[t]=this._list[t=t+1+s&this._capacityMask];this._list[t]=void 0,this._tail=this._tail-1+s&this._capacityMask}return i}}},t.prototype.remove=function(e,t){var r,s=e,n=t;if(s===(0|s)&&this._head!==this._tail){var i=this.size(),o=this._list.length;if(!(s>=i||s<-i||t<1)){if(s<0&&(s+=i),1===t||!t)return r=new Array(1),r[0]=this.removeOne(s),r;if(0===s&&s+t>=i)return r=this.toArray(),this.clear(),r;var a;for(s+t>i&&(t=i-s),r=new Array(t),a=0;a<t;a++)r[a]=this._list[this._head+s+a&this._capacityMask];if(s=this._head+s&this._capacityMask,e+t===i){for(this._tail=this._tail-t+o&this._capacityMask,a=t;a>0;a--)this._list[s=s+1+o&this._capacityMask]=void 0;return r}if(0===e){for(this._head=this._head+t+o&this._capacityMask,a=t-1;a>0;a--)this._list[s=s+1+o&this._capacityMask]=void 0;return r}if(s<i/2){for(this._head=this._head+e+t+o&this._capacityMask,a=e;a>0;a--)this.unshift(this._list[s=s-1+o&this._capacityMask]);s=this._head-1+o&this._capacityMask;while(n>0)this._list[s=s-1+o&this._capacityMask]=void 0,n--;e<0&&(this._tail=s)}else{for(this._tail=s,s=s+t+o&this._capacityMask,a=i-(t+e);a>0;a--)this.push(this._list[s++]);s=this._tail;while(n>0)this._list[s=s+1+o&this._capacityMask]=void 0,n--}return this._head<2&&this._tail>1e4&&this._tail<=o>>>2&&this._shrinkArray(),r}}},t.prototype.splice=function(e,t){var r=e;if(r===(0|r)){var s=this.size();if(r<0&&(r+=s),!(r>s)){if(arguments.length>2){var n,i,o,a=arguments.length,c=this._list.length,l=2;if(!s||r<s/2){for(i=new Array(r),n=0;n<r;n++)i[n]=this._list[this._head+n&this._capacityMask];0===t?(o=[],r>0&&(this._head=this._head+r+c&this._capacityMask)):(o=this.remove(r,t),this._head=this._head+r+c&this._capacityMask);while(a>l)this.unshift(arguments[--a]);for(n=r;n>0;n--)this.unshift(i[n-1])}else{i=new Array(s-(r+t));var u=i.length;for(n=0;n<u;n++)i[n]=this._list[this._head+r+t+n&this._capacityMask];0===t?(o=[],r!=s&&(this._tail=this._head+r+c&this._capacityMask)):(o=this.remove(r,t),this._tail=this._tail-u+c&this._capacityMask);while(l<a)this.push(arguments[l++]);for(n=0;n<u;n++)this.push(i[n])}return o}return this.remove(r,t)}}},t.prototype.clear=function(){this._head=0,this._tail=0},t.prototype.isEmpty=function(){return this._head===this._tail},t.prototype.toArray=function(){return this._copyArray(!1)},t.prototype._fromArray=function(e){for(var t=0;t<e.length;t++)this.push(e[t])},t.prototype._copyArray=function(e){var t,r=[],s=this._list,n=s.length;if(e||this._head>this._tail){for(t=this._head;t<n;t++)r.push(s[t]);for(t=0;t<this._tail;t++)r.push(s[t])}else for(t=this._head;t<this._tail;t++)r.push(s[t]);return r},t.prototype._growArray=function(){this._head&&(this._list=this._copyArray(!0),this._head=0),this._tail=this._list.length,this._list.length<<=1,this._capacityMask=this._capacityMask<<1|1},t.prototype._shrinkArray=function(){this._list.length>>>=1,this._capacityMask>>>=1},e.exports=t},26905:function(e){!function(t,r){e.exports=function(e,t,r,s,n){for(t=t.split?t.split("."):t,s=0;s<t.length;s++)e=e?e[t[s]]:n;return e===n?r:e}}()},96132:function(e,t){"use strict";function r(e,t=r.BASE){const s=e.length;for(let r=0;r<s;r++)t^=e.charCodeAt(r),t+=(t<<1)+(t<<4)+(t<<7)+(t<<8)+(t<<24);return t>>>0}Object.defineProperty(t,"__esModule",{value:!0}),r.BASE=2166136261,t["default"]=r,e.exports=r},106:function(e,t,r){"use strict";var s=r(34155);const n=r(59134),i="object"===typeof window&&"object"===typeof document&&9===document.nodeType,o=n(),a=i&&!o,c=o&&!i,l=o&&i,u="undefined"!==typeof s&&"undefined"!==typeof s.release&&"node"===s.release.name&&!o,h="function"===typeof importScripts&&"undefined"!==typeof self&&"undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope,d="undefined"!==typeof s&&!1,p="undefined"!==typeof navigator&&"ReactNative"===navigator.product;e.exports={isTest:d,isElectron:o,isElectronMain:c,isElectronRenderer:l,isNode:u,isBrowser:a,isWebWorker:h,isEnvWithDom:i,isReactNative:p}},46953:function(e,t,r){"use strict";const s=r(67137),n=(e,t)=>({path:decodeURIComponent(new URL(e).pathname.split("/").pop()||""),content:i(e,t)});async function*i(e,t){const r=new s,n=await r.get(e,t);yield*n.iterator()}e.exports=n},82734:function(e){"use strict";var t=/^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;e.exports=function(e,r){if(null==r&&(r=!1),e.length<2)return!1;if(e.length>255)return!1;var s=e[e.length-1];if(r){if("."!==s)return!1}else if("."===s)return!1;return t.test(e)}},71993:function(e){"use strict";e.exports={RTLD_LAZY:1,RTLD_NOW:2,RTLD_GLOBAL:256,RTLD_LOCAL:0,RTLD_DEEPBIND:8,E2BIG:7,EACCES:13,EADDRINUSE:98,EADDRNOTAVAIL:99,EAFNOSUPPORT:97,EAGAIN:11,EALREADY:114,EBADF:9,EBADMSG:74,EBUSY:16,ECANCELED:125,ECHILD:10,ECONNABORTED:103,ECONNREFUSED:111,ECONNRESET:104,EDEADLK:35,EDESTADDRREQ:89,EDOM:33,EDQUOT:122,EEXIST:17,EFAULT:14,EFBIG:27,EHOSTUNREACH:113,EIDRM:43,EILSEQ:84,EINPROGRESS:115,EINTR:4,EINVAL:22,EIO:5,EISCONN:106,EISDIR:21,ELOOP:40,EMFILE:24,EMLINK:31,EMSGSIZE:90,EMULTIHOP:72,ENAMETOOLONG:36,ENETDOWN:100,ENETRESET:102,ENETUNREACH:101,ENFILE:23,ENOBUFS:105,ENODATA:61,ENODEV:19,ENOENT:2,ENOEXEC:8,ENOLCK:37,ENOLINK:67,ENOMEM:12,ENOMSG:42,ENOPROTOOPT:92,ENOSPC:28,ENOSR:63,ENOSTR:60,ENOSYS:38,ENOTCONN:107,ENOTDIR:20,ENOTEMPTY:39,ENOTSOCK:88,ENOTSUP:95,ENOTTY:25,ENXIO:6,EOPNOTSUPP:95,EOVERFLOW:75,EPERM:1,EPIPE:32,EPROTO:71,EPROTONOSUPPORT:93,EPROTOTYPE:91,ERANGE:34,EROFS:30,ESPIPE:29,ESRCH:3,ESTALE:116,ETIME:62,ETIMEDOUT:110,ETXTBSY:26,EWOULDBLOCK:11,EXDEV:18,PRIORITY_LOW:19,PRIORITY_BELOW_NORMAL:10,PRIORITY_NORMAL:0,PRIORITY_ABOVE_NORMAL:-7,PRIORITY_HIGH:-14,PRIORITY_HIGHEST:-20,SIGHUP:1,SIGINT:2,SIGQUIT:3,SIGILL:4,SIGTRAP:5,SIGABRT:6,SIGIOT:6,SIGBUS:7,SIGFPE:8,SIGKILL:9,SIGUSR1:10,SIGSEGV:11,SIGUSR2:12,SIGPIPE:13,SIGALRM:14,SIGTERM:15,SIGCHLD:17,SIGSTKFLT:16,SIGCONT:18,SIGSTOP:19,SIGTSTP:20,SIGTTIN:21,SIGTTOU:22,SIGURG:23,SIGXCPU:24,SIGXFSZ:25,SIGVTALRM:26,SIGPROF:27,SIGWINCH:28,SIGIO:29,SIGPOLL:29,SIGPWR:30,SIGSYS:31,SIGUNUSED:31,UV_FS_SYMLINK_DIR:1,UV_FS_SYMLINK_JUNCTION:2,O_RDONLY:0,O_WRONLY:1,O_RDWR:2,UV_DIRENT_UNKNOWN:0,UV_DIRENT_FILE:1,UV_DIRENT_DIR:2,UV_DIRENT_LINK:3,UV_DIRENT_FIFO:4,UV_DIRENT_SOCKET:5,UV_DIRENT_CHAR:6,UV_DIRENT_BLOCK:7,S_IFMT:61440,S_IFREG:32768,S_IFDIR:16384,S_IFCHR:8192,S_IFBLK:24576,S_IFIFO:4096,S_IFLNK:40960,S_IFSOCK:49152,O_CREAT:64,O_EXCL:128,UV_FS_O_FILEMAP:0,O_NOCTTY:256,O_TRUNC:512,O_APPEND:1024,O_DIRECTORY:65536,O_NOATIME:262144,O_NOFOLLOW:131072,O_SYNC:1052672,O_DSYNC:4096,O_DIRECT:16384,O_NONBLOCK:2048,S_IRWXU:448,S_IRUSR:256,S_IWUSR:128,S_IXUSR:64,S_IRWXG:56,S_IRGRP:32,S_IWGRP:16,S_IXGRP:8,S_IRWXO:7,S_IROTH:4,S_IWOTH:2,S_IXOTH:1,F_OK:0,R_OK:4,W_OK:2,X_OK:1,UV_FS_COPYFILE_EXCL:1,COPYFILE_EXCL:1,UV_FS_COPYFILE_FICLONE:2,COPYFILE_FICLONE:2,UV_FS_COPYFILE_FICLONE_FORCE:4,COPYFILE_FICLONE_FORCE:4,OPENSSL_VERSION_NUMBER:269488495,SSL_OP_ALL:2147485780,SSL_OP_ALLOW_NO_DHE_KEX:1024,SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION:262144,SSL_OP_CIPHER_SERVER_PREFERENCE:4194304,SSL_OP_CISCO_ANYCONNECT:32768,SSL_OP_COOKIE_EXCHANGE:8192,SSL_OP_CRYPTOPRO_TLSEXT_BUG:2147483648,SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS:2048,SSL_OP_EPHEMERAL_RSA:0,SSL_OP_LEGACY_SERVER_CONNECT:4,SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER:0,SSL_OP_MICROSOFT_SESS_ID_BUG:0,SSL_OP_MSIE_SSLV2_RSA_PADDING:0,SSL_OP_NETSCAPE_CA_DN_BUG:0,SSL_OP_NETSCAPE_CHALLENGE_BUG:0,SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG:0,SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG:0,SSL_OP_NO_COMPRESSION:131072,SSL_OP_NO_ENCRYPT_THEN_MAC:524288,SSL_OP_NO_QUERY_MTU:4096,SSL_OP_NO_RENEGOTIATION:1073741824,SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION:65536,SSL_OP_NO_SSLv2:0,SSL_OP_NO_SSLv3:33554432,SSL_OP_NO_TICKET:16384,SSL_OP_NO_TLSv1:67108864,SSL_OP_NO_TLSv1_1:268435456,SSL_OP_NO_TLSv1_2:134217728,SSL_OP_NO_TLSv1_3:536870912,SSL_OP_PKCS1_CHECK_1:0,SSL_OP_PKCS1_CHECK_2:0,SSL_OP_PRIORITIZE_CHACHA:2097152,SSL_OP_SINGLE_DH_USE:0,SSL_OP_SINGLE_ECDH_USE:0,SSL_OP_SSLEAY_080_CLIENT_DH_BUG:0,SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG:0,SSL_OP_TLS_BLOCK_PADDING_BUG:0,SSL_OP_TLS_D5_BUG:0,SSL_OP_TLS_ROLLBACK_BUG:8388608,ENGINE_METHOD_RSA:1,ENGINE_METHOD_DSA:2,ENGINE_METHOD_DH:4,ENGINE_METHOD_RAND:8,ENGINE_METHOD_EC:2048,ENGINE_METHOD_CIPHERS:64,ENGINE_METHOD_DIGESTS:128,ENGINE_METHOD_PKEY_METHS:512,ENGINE_METHOD_PKEY_ASN1_METHS:1024,ENGINE_METHOD_ALL:65535,ENGINE_METHOD_NONE:0,DH_CHECK_P_NOT_SAFE_PRIME:2,DH_CHECK_P_NOT_PRIME:1,DH_UNABLE_TO_CHECK_GENERATOR:4,DH_NOT_SUITABLE_GENERATOR:8,ALPN_ENABLED:1,RSA_PKCS1_PADDING:1,RSA_SSLV23_PADDING:2,RSA_NO_PADDING:3,RSA_PKCS1_OAEP_PADDING:4,RSA_X931_PADDING:5,RSA_PKCS1_PSS_PADDING:6,RSA_PSS_SALTLEN_DIGEST:-1,RSA_PSS_SALTLEN_MAX_SIGN:-2,RSA_PSS_SALTLEN_AUTO:-2,defaultCoreCipherList:"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",TLS1_VERSION:769,TLS1_1_VERSION:770,TLS1_2_VERSION:771,TLS1_3_VERSION:772,POINT_CONVERSION_COMPRESSED:2,POINT_CONVERSION_UNCOMPRESSED:4,POINT_CONVERSION_HYBRID:6}},31303:function(e){"use strict";const t=async e=>{const t=[];for await(const r of e)t.push(r);return t};e.exports=t},78165:function(e){"use strict";async function*t(e,t=1){let r=[];t<1&&(t=1);for await(const s of e){r.push(s);while(r.length>=t)yield r.slice(0,t),r=r.slice(t)}while(r.length)yield r.slice(0,t),r=r.slice(t)}e.exports=t},55565:function(e){"use strict";const t=async function*(e,t){for await(const r of e)await t(r)&&(yield r)};e.exports=t},4321:function(e){"use strict";const t=async function*(e,t){for await(const r of e)await t(r),yield r};e.exports=t},93093:function(e){"use strict";const t=async e=>{let t;for await(const r of e)t=r;return t};e.exports=t},84810:function(e,t,r){"use strict";const s=r(78165);async function*n(e,t=1){for await(const r of s(e,t)){const e=r.map((e=>e().then((e=>({ok:!0,value:e})),(e=>({ok:!1,err:e})))));for(let t=0;t<e.length;t++){const r=await e[t];if(!r.ok)throw r.err;yield r.value}}}e.exports=n},28132:function(e){"use strict";function t(e){const[t,r]=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],s=[];return{peek:()=>t.next(),push:e=>{s.push(e)},next:()=>s.length?{done:!1,value:s.shift()}:t.next(),[r](){return this}}}e.exports=t},97515:function(e,t,r){"use strict";const s=r(31303),n=async function*(e,t){const r=await s(e);yield*r.sort(t)};e.exports=n},46943:function(e,t,r){"use strict";const s=r(94473),n=r(8002),{Encoding:i}=r(8266),{BufferFormat:o,ViewFormat:a,UTF8Format:c}=r(82376),l=Symbol("formats"),u=Symbol("encodings"),h=new Set(["buffer","view","utf8"]);class d{constructor(e){if(!Array.isArray(e))throw new TypeError("The first argument 'formats' must be an array");if(!e.every((e=>h.has(e))))throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");this[u]=new Map,this[l]=new Set(e);for(const r in n)try{this.encoding(r)}catch(t){if("LEVEL_ENCODING_NOT_SUPPORTED"!==t.code)throw t}}encodings(){return Array.from(new Set(this[u].values()))}encoding(e){let t=this[u].get(e);if(void 0===t){if("string"===typeof e&&""!==e){if(t=g[e],!t)throw new s(`Encoding '${e}' is not found`,{code:"LEVEL_ENCODING_NOT_FOUND"})}else{if("object"!==typeof e||null===e)throw new TypeError("First argument 'encoding' must be a string or object");t=p(e)}const{name:r,format:n}=t;if(!this[l].has(n))if(this[l].has("view"))t=t.createViewTranscoder();else if(this[l].has("buffer"))t=t.createBufferTranscoder();else{if(!this[l].has("utf8"))throw new s(`Encoding '${r}' cannot be transcoded`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"});t=t.createUTF8Transcoder()}for(const s of[e,r,t.name,t.commonName])this[u].set(s,t)}return t}}function p(e){if(e instanceof i)return e;const t="type"in e&&"string"===typeof e.type?e.type:void 0,r=e.name||t||"anonymous-"+m++;switch(f(e)){case"view":return new a({...e,name:r});case"utf8":return new c({...e,name:r});case"buffer":return new o({...e,name:r});default:throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'")}}function f(e){return"format"in e&&void 0!==e.format?e.format:"buffer"in e&&"boolean"===typeof e.buffer?e.buffer?"buffer":"utf8":"code"in e&&Number.isInteger(e.code)?"view":"buffer"}t.Transcoder=d;const y={binary:n.buffer,"utf-8":n.utf8},g={...n,...y};let m=0},8266:function(e,t,r){"use strict";const s=r(94473),n=new Set(["buffer","view","utf8"]);class i{constructor(e){if(this.encode=e.encode||this.encode,this.decode=e.decode||this.decode,this.name=e.name||this.name,this.format=e.format||this.format,"function"!==typeof this.encode)throw new TypeError("The 'encode' property must be a function");if("function"!==typeof this.decode)throw new TypeError("The 'decode' property must be a function");if(this.encode=this.encode.bind(this),this.decode=this.decode.bind(this),"string"!==typeof this.name||""===this.name)throw new TypeError("The 'name' property must be a string");if("string"!==typeof this.format||!n.has(this.format))throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");e.createViewTranscoder&&(this.createViewTranscoder=e.createViewTranscoder),e.createBufferTranscoder&&(this.createBufferTranscoder=e.createBufferTranscoder),e.createUTF8Transcoder&&(this.createUTF8Transcoder=e.createUTF8Transcoder)}get commonName(){return this.name.split("+")[0]}createBufferTranscoder(){throw new s(`Encoding '${this.name}' cannot be transcoded to 'buffer'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}createViewTranscoder(){throw new s(`Encoding '${this.name}' cannot be transcoded to 'view'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}createUTF8Transcoder(){throw new s(`Encoding '${this.name}' cannot be transcoded to 'utf8'`,{code:"LEVEL_ENCODING_NOT_SUPPORTED"})}}t.Encoding=i},8002:function(e,t,r){"use strict";const{Buffer:s}=r(48764)||{Buffer:{isBuffer:()=>!1}},{textEncoder:n,textDecoder:i}=r(85850)(),{BufferFormat:o,ViewFormat:a,UTF8Format:c}=r(82376),l=e=>e;t.utf8=new c({encode:function(e){return s.isBuffer(e)?e.toString("utf8"):ArrayBuffer.isView(e)?i.decode(e):String(e)},decode:l,name:"utf8",createViewTranscoder(){return new a({encode:function(e){return ArrayBuffer.isView(e)?e:n.encode(e)},decode:function(e){return i.decode(e)},name:`${this.name}+view`})},createBufferTranscoder(){return new o({encode:function(e){return s.isBuffer(e)?e:ArrayBuffer.isView(e)?s.from(e.buffer,e.byteOffset,e.byteLength):s.from(String(e),"utf8")},decode:function(e){return e.toString("utf8")},name:`${this.name}+buffer`})}}),t.json=new c({encode:JSON.stringify,decode:JSON.parse,name:"json"}),t.buffer=new o({encode:function(e){return s.isBuffer(e)?e:ArrayBuffer.isView(e)?s.from(e.buffer,e.byteOffset,e.byteLength):s.from(String(e),"utf8")},decode:l,name:"buffer",createViewTranscoder(){return new a({encode:function(e){return ArrayBuffer.isView(e)?e:s.from(String(e),"utf8")},decode:function(e){return s.from(e.buffer,e.byteOffset,e.byteLength)},name:`${this.name}+view`})}}),t.view=new a({encode:function(e){return ArrayBuffer.isView(e)?e:n.encode(e)},decode:l,name:"view",createBufferTranscoder(){return new o({encode:function(e){return s.isBuffer(e)?e:ArrayBuffer.isView(e)?s.from(e.buffer,e.byteOffset,e.byteLength):s.from(String(e),"utf8")},decode:l,name:`${this.name}+buffer`})}}),t.hex=new o({encode:function(e){return s.isBuffer(e)?e:s.from(String(e),"hex")},decode:function(e){return e.toString("hex")},name:"hex"}),t.base64=new o({encode:function(e){return s.isBuffer(e)?e:s.from(String(e),"base64")},decode:function(e){return e.toString("base64")},name:"base64"})},82376:function(e,t,r){"use strict";const{Buffer:s}=r(48764)||{},{Encoding:n}=r(8266),i=r(85850);class o extends n{constructor(e){super({...e,format:"buffer"})}createViewTranscoder(){return new a({encode:this.encode,decode:e=>this.decode(s.from(e.buffer,e.byteOffset,e.byteLength)),name:`${this.name}+view`})}createBufferTranscoder(){return this}}class a extends n{constructor(e){super({...e,format:"view"})}createBufferTranscoder(){return new o({encode:e=>{const t=this.encode(e);return s.from(t.buffer,t.byteOffset,t.byteLength)},decode:this.decode,name:`${this.name}+buffer`})}createViewTranscoder(){return this}}class c extends n{constructor(e){super({...e,format:"utf8"})}createBufferTranscoder(){return new o({encode:e=>s.from(this.encode(e),"utf8"),decode:e=>this.decode(e.toString("utf8")),name:`${this.name}+buffer`})}createViewTranscoder(){const{textEncoder:e,textDecoder:t}=i();return new a({encode:t=>e.encode(this.encode(t)),decode:e=>this.decode(t.decode(e)),name:`${this.name}+view`})}createUTF8Transcoder(){return this}}t.BufferFormat=o,t.ViewFormat=a,t.UTF8Format=c},85850:function(e){"use strict";let t=null;e.exports=function(){return null===t&&(t={textEncoder:new TextEncoder,textDecoder:new TextDecoder}),t}},94473:function(e){"use strict";e.exports=class extends Error{constructor(e,t){super(e||""),"object"===typeof t&&null!==t&&(t.code&&(this.code=String(t.code)),t.expected&&(this.expected=!0),t.transient&&(this.transient=!0),t.cause&&(this.cause=t.cause)),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}}},57824:function(e){var t=1e3,r=60*t,s=60*r,n=24*s,i=7*n,o=365.25*n;function a(e){if(e=String(e),!(e.length>100)){var a=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(a){var c=parseFloat(a[1]),l=(a[2]||"ms").toLowerCase();switch(l){case"years":case"year":case"yrs":case"yr":case"y":return c*o;case"weeks":case"week":case"w":return c*i;case"days":case"day":case"d":return c*n;case"hours":case"hour":case"hrs":case"hr":case"h":return c*s;case"minutes":case"minute":case"mins":case"min":case"m":return c*r;case"seconds":case"second":case"secs":case"sec":case"s":return c*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return c;default:return}}}}function c(e){var i=Math.abs(e);return i>=n?Math.round(e/n)+"d":i>=s?Math.round(e/s)+"h":i>=r?Math.round(e/r)+"m":i>=t?Math.round(e/t)+"s":e+"ms"}function l(e){var i=Math.abs(e);return i>=n?u(e,i,n,"day"):i>=s?u(e,i,s,"hour"):i>=r?u(e,i,r,"minute"):i>=t?u(e,i,t,"second"):e+" ms"}function u(e,t,r,s){var n=t>=1.5*r;return Math.round(e/r)+" "+s+(n?"s":"")}e.exports=function(e,t){t=t||{};var r=typeof e;if("string"===r&&e.length>0)return a(e);if("number"===r&&isFinite(e))return t.long?l(e):c(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},40469:function(e,t,r){e.exports=r(18027)},18027:function(e,t){(function(r,s){"use strict";var n={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function i(e){if(!Array.isArray(e)&&!ArrayBuffer.isView(e))return!1;for(var t=0;t<e.length;t++)if(!Number.isInteger(e[t])||e[t]<0||e[t]>255)return!1;return!0}function o(e,t){return(65535&e)*t+(((e>>>16)*t&65535)<<16)}function a(e,t){return e<<t|e>>>32-t}function c(e){return e^=e>>>16,e=o(e,2246822507),e^=e>>>13,e=o(e,3266489909),e^=e>>>16,e}function l(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var r=[0,0,0,0];return r[3]+=e[3]+t[3],r[2]+=r[3]>>>16,r[3]&=65535,r[2]+=e[2]+t[2],r[1]+=r[2]>>>16,r[2]&=65535,r[1]+=e[1]+t[1],r[0]+=r[1]>>>16,r[1]&=65535,r[0]+=e[0]+t[0],r[0]&=65535,[r[0]<<16|r[1],r[2]<<16|r[3]]}function u(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var r=[0,0,0,0];return r[3]+=e[3]*t[3],r[2]+=r[3]>>>16,r[3]&=65535,r[2]+=e[2]*t[3],r[1]+=r[2]>>>16,r[2]&=65535,r[2]+=e[3]*t[2],r[1]+=r[2]>>>16,r[2]&=65535,r[1]+=e[1]*t[3],r[0]+=r[1]>>>16,r[1]&=65535,r[1]+=e[2]*t[2],r[0]+=r[1]>>>16,r[1]&=65535,r[1]+=e[3]*t[1],r[0]+=r[1]>>>16,r[1]&=65535,r[0]+=e[0]*t[3]+e[1]*t[2]+e[2]*t[1]+e[3]*t[0],r[0]&=65535,[r[0]<<16|r[1],r[2]<<16|r[3]]}function h(e,t){return t%=64,32===t?[e[1],e[0]]:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t|e[0]>>>32-t]:(t-=32,[e[1]<<t|e[0]>>>32-t,e[0]<<t|e[1]>>>32-t])}function d(e,t){return t%=64,0===t?e:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t]:[e[1]<<t-32,0]}function p(e,t){return[e[0]^t[0],e[1]^t[1]]}function f(e){return e=p(e,[0,e[0]>>>1]),e=u(e,[4283543511,3981806797]),e=p(e,[0,e[0]>>>1]),e=u(e,[3301882366,444984403]),e=p(e,[0,e[0]>>>1]),e}n.x86.hash32=function(e,t){if(n.inputValidation&&!i(e))return s;t=t||0;for(var r=e.length%4,l=e.length-r,u=t,h=0,d=3432918353,p=461845907,f=0;f<l;f+=4)h=e[f]|e[f+1]<<8|e[f+2]<<16|e[f+3]<<24,h=o(h,d),h=a(h,15),h=o(h,p),u^=h,u=a(u,13),u=o(u,5)+3864292196;switch(h=0,r){case 3:h^=e[f+2]<<16;case 2:h^=e[f+1]<<8;case 1:h^=e[f],h=o(h,d),h=a(h,15),h=o(h,p),u^=h}return u^=e.length,u=c(u),u>>>0},n.x86.hash128=function(e,t){if(n.inputValidation&&!i(e))return s;t=t||0;for(var r=e.length%16,l=e.length-r,u=t,h=t,d=t,p=t,f=0,y=0,g=0,m=0,w=597399067,b=2869860233,_=951274213,E=2716044179,v=0;v<l;v+=16)f=e[v]|e[v+1]<<8|e[v+2]<<16|e[v+3]<<24,y=e[v+4]|e[v+5]<<8|e[v+6]<<16|e[v+7]<<24,g=e[v+8]|e[v+9]<<8|e[v+10]<<16|e[v+11]<<24,m=e[v+12]|e[v+13]<<8|e[v+14]<<16|e[v+15]<<24,f=o(f,w),f=a(f,15),f=o(f,b),u^=f,u=a(u,19),u+=h,u=o(u,5)+1444728091,y=o(y,b),y=a(y,16),y=o(y,_),h^=y,h=a(h,17),h+=d,h=o(h,5)+197830471,g=o(g,_),g=a(g,17),g=o(g,E),d^=g,d=a(d,15),d+=p,d=o(d,5)+2530024501,m=o(m,E),m=a(m,18),m=o(m,w),p^=m,p=a(p,13),p+=u,p=o(p,5)+850148119;switch(f=0,y=0,g=0,m=0,r){case 15:m^=e[v+14]<<16;case 14:m^=e[v+13]<<8;case 13:m^=e[v+12],m=o(m,E),m=a(m,18),m=o(m,w),p^=m;case 12:g^=e[v+11]<<24;case 11:g^=e[v+10]<<16;case 10:g^=e[v+9]<<8;case 9:g^=e[v+8],g=o(g,_),g=a(g,17),g=o(g,E),d^=g;case 8:y^=e[v+7]<<24;case 7:y^=e[v+6]<<16;case 6:y^=e[v+5]<<8;case 5:y^=e[v+4],y=o(y,b),y=a(y,16),y=o(y,_),h^=y;case 4:f^=e[v+3]<<24;case 3:f^=e[v+2]<<16;case 2:f^=e[v+1]<<8;case 1:f^=e[v],f=o(f,w),f=a(f,15),f=o(f,b),u^=f}return u^=e.length,h^=e.length,d^=e.length,p^=e.length,u+=h,u+=d,u+=p,h+=u,d+=u,p+=u,u=c(u),h=c(h),d=c(d),p=c(p),u+=h,u+=d,u+=p,h+=u,d+=u,p+=u,("00000000"+(u>>>0).toString(16)).slice(-8)+("00000000"+(h>>>0).toString(16)).slice(-8)+("00000000"+(d>>>0).toString(16)).slice(-8)+("00000000"+(p>>>0).toString(16)).slice(-8)},n.x64.hash128=function(e,t){if(n.inputValidation&&!i(e))return s;t=t||0;for(var r=e.length%16,o=e.length-r,a=[0,t],c=[0,t],y=[0,0],g=[0,0],m=[2277735313,289559509],w=[1291169091,658871167],b=0;b<o;b+=16)y=[e[b+4]|e[b+5]<<8|e[b+6]<<16|e[b+7]<<24,e[b]|e[b+1]<<8|e[b+2]<<16|e[b+3]<<24],g=[e[b+12]|e[b+13]<<8|e[b+14]<<16|e[b+15]<<24,e[b+8]|e[b+9]<<8|e[b+10]<<16|e[b+11]<<24],y=u(y,m),y=h(y,31),y=u(y,w),a=p(a,y),a=h(a,27),a=l(a,c),a=l(u(a,[0,5]),[0,1390208809]),g=u(g,w),g=h(g,33),g=u(g,m),c=p(c,g),c=h(c,31),c=l(c,a),c=l(u(c,[0,5]),[0,944331445]);switch(y=[0,0],g=[0,0],r){case 15:g=p(g,d([0,e[b+14]],48));case 14:g=p(g,d([0,e[b+13]],40));case 13:g=p(g,d([0,e[b+12]],32));case 12:g=p(g,d([0,e[b+11]],24));case 11:g=p(g,d([0,e[b+10]],16));case 10:g=p(g,d([0,e[b+9]],8));case 9:g=p(g,[0,e[b+8]]),g=u(g,w),g=h(g,33),g=u(g,m),c=p(c,g);case 8:y=p(y,d([0,e[b+7]],56));case 7:y=p(y,d([0,e[b+6]],48));case 6:y=p(y,d([0,e[b+5]],40));case 5:y=p(y,d([0,e[b+4]],32));case 4:y=p(y,d([0,e[b+3]],24));case 3:y=p(y,d([0,e[b+2]],16));case 2:y=p(y,d([0,e[b+1]],8));case 1:y=p(y,[0,e[b]]),y=u(y,m),y=h(y,31),y=u(y,w),a=p(a,y)}return a=p(a,[0,e.length]),c=p(c,[0,e.length]),a=l(a,c),c=l(c,a),a=f(a),c=f(c),a=l(a,c),c=l(c,a),("00000000"+(a[0]>>>0).toString(16)).slice(-8)+("00000000"+(a[1]>>>0).toString(16)).slice(-8)+("00000000"+(c[0]>>>0).toString(16)).slice(-8)+("00000000"+(c[1]>>>0).toString(16)).slice(-8)},e.exports&&(t=e.exports=n),t.murmurHash3=n})()},99633:function(e){"use strict";function t(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)}e.exports=function(e){var r=void 0,s=void 0;function n(e){if(!(e instanceof Object))throw new Error('Target "'+e+'" is not an object');s=e}function i(e){Object.keys(e).forEach((function(t){var r=e[t];if("function"!==typeof r)throw new Error('Trap "'+t+": "+r+'" is not a function');if(!Reflect[t])throw new Error('Trap "'+t+": "+r+'" is not a valid trap')})),r=e}n((function(){})),e&&n(e),i(Reflect);var o=new Proxy({},{get:function(e,n){return function(){for(var e=arguments.length,i=Array(e),o=0;o<e;o++)i[o]=arguments[o];return r[n].apply(null,[s].concat(t(i.slice(1))))}}});return{setTarget:n,setHandler:i,getTarget:function(){return s},getHandler:function(){return r},proxy:new Proxy(s,o)}}},86971:function(e,t,r){var s=r(3832);r(83453),e.exports=s.mgf=s.mgf||{},s.mgf.mgf1=s.mgf1},83453:function(e,t,r){var s=r(3832);r(97116),s.mgf=s.mgf||{};var n=e.exports=s.mgf.mgf1=s.mgf1=s.mgf1||{};n.create=function(e){var t={generate:function(t,r){for(var n=new s.util.ByteBuffer,i=Math.ceil(r/e.digestLength),o=0;o<i;o++){var a=new s.util.ByteBuffer;a.putInt32(o),e.start(),e.update(t+a.getBytes()),n.putBuffer(e.digest())}return n.truncate(n.length()-r),n.getBytes()}};return t}},79437:function(e,t,r){var s=r(3832);r(8925),r(3068),r(33480),r(66270),r(26953),r(95496),r(49563),r(97116),r(25414);var n=s.asn1,i=e.exports=s.pkcs7=s.pkcs7||{};function o(e){var t={},r=[];if(!n.validate(e,i.asn1.recipientInfoValidator,t,r)){var o=new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");throw o.errors=r,o}return{version:t.version.charCodeAt(0),issuer:s.pki.RDNAttributesAsArray(t.issuer),serialNumber:s.util.createBuffer(t.serial).toHex(),encryptedContent:{algorithm:n.derToOid(t.encAlgorithm),parameter:t.encParameter?t.encParameter.value:void 0,content:t.encKey}}}function a(e){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(e.version).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[s.pki.distinguishedNameToAsn1({attributes:e.issuer}),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,s.util.hexToBytes(e.serialNumber))]),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.encryptedContent.algorithm).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]),n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,e.encryptedContent.content)])}function c(e){for(var t=[],r=0;r<e.length;++r)t.push(o(e[r]));return t}function l(e){for(var t=[],r=0;r<e.length;++r)t.push(a(e[r]));return t}function u(e){var t=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(e.version).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[s.pki.distinguishedNameToAsn1({attributes:e.issuer}),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,s.util.hexToBytes(e.serialNumber))]),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.digestAlgorithm).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")])]);if(e.authenticatedAttributesAsn1&&t.value.push(e.authenticatedAttributesAsn1),t.value.push(n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.signatureAlgorithm).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")])),t.value.push(n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,e.signature)),e.unauthenticatedAttributes.length>0){for(var r=n.create(n.Class.CONTEXT_SPECIFIC,1,!0,[]),i=0;i<e.unauthenticatedAttributes.length;++i){var o=e.unauthenticatedAttributes[i];r.values.push(d(o))}t.value.push(r)}return t}function h(e){for(var t=[],r=0;r<e.length;++r)t.push(u(e[r]));return t}function d(e){var t;if(e.type===s.pki.oids.contentType)t=n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.value).getBytes());else if(e.type===s.pki.oids.messageDigest)t=n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,e.value.bytes());else if(e.type===s.pki.oids.signingTime){var r=new Date("1950-01-01T00:00:00Z"),i=new Date("2050-01-01T00:00:00Z"),o=e.value;if("string"===typeof o){var a=Date.parse(o);o=isNaN(a)?13===o.length?n.utcTimeToDate(o):n.generalizedTimeToDate(o):new Date(a)}t=o>=r&&o<i?n.create(n.Class.UNIVERSAL,n.Type.UTCTIME,!1,n.dateToUtcTime(o)):n.create(n.Class.UNIVERSAL,n.Type.GENERALIZEDTIME,!1,n.dateToGeneralizedTime(o))}return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.type).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SET,!0,[t])])}function p(e){return[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(s.pki.oids.data).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.algorithm).getBytes()),e.parameter?n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,e.parameter.getBytes()):void 0]),n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,e.content.getBytes())])]}function f(e,t,r){var i={},o=[];if(!n.validate(t,r,i,o)){var a=new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");throw a.errors=a,a}var c=n.derToOid(i.contentType);if(c!==s.pki.oids.data)throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");if(i.encryptedContent){var l="";if(s.util.isArray(i.encryptedContent))for(var u=0;u<i.encryptedContent.length;++u){if(i.encryptedContent[u].type!==n.Type.OCTETSTRING)throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");l+=i.encryptedContent[u].value}else l=i.encryptedContent;e.encryptedContent={algorithm:n.derToOid(i.encAlgorithm),parameter:s.util.createBuffer(i.encParameter.value),content:s.util.createBuffer(l)}}if(i.content){l="";if(s.util.isArray(i.content))for(u=0;u<i.content.length;++u){if(i.content[u].type!==n.Type.OCTETSTRING)throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");l+=i.content[u].value}else l=i.content;e.content=s.util.createBuffer(l)}return e.version=i.version.charCodeAt(0),e.rawCapture=i,i}function y(e){if(void 0===e.encryptedContent.key)throw new Error("Symmetric key not available.");if(void 0===e.content){var t;switch(e.encryptedContent.algorithm){case s.pki.oids["aes128-CBC"]:case s.pki.oids["aes192-CBC"]:case s.pki.oids["aes256-CBC"]:t=s.aes.createDecryptionCipher(e.encryptedContent.key);break;case s.pki.oids["desCBC"]:case s.pki.oids["des-EDE3-CBC"]:t=s.des.createDecryptionCipher(e.encryptedContent.key);break;default:throw new Error("Unsupported symmetric cipher, OID "+e.encryptedContent.algorithm)}if(t.start(e.encryptedContent.parameter),t.update(e.encryptedContent.content),!t.finish())throw new Error("Symmetric decryption failed.");e.content=t.output}}i.messageFromPem=function(e){var t=s.pem.decode(e)[0];if("PKCS7"!==t.type){var r=new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');throw r.headerType=t.type,r}if(t.procType&&"ENCRYPTED"===t.procType.type)throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");var o=n.fromDer(t.body);return i.messageFromAsn1(o)},i.messageToPem=function(e,t){var r={type:"PKCS7",body:n.toDer(e.toAsn1()).getBytes()};return s.pem.encode(r,{maxline:t})},i.messageFromAsn1=function(e){var t={},r=[];if(!n.validate(e,i.asn1.contentInfoValidator,t,r)){var o=new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");throw o.errors=r,o}var a,c=n.derToOid(t.contentType);switch(c){case s.pki.oids.envelopedData:a=i.createEnvelopedData();break;case s.pki.oids.encryptedData:a=i.createEncryptedData();break;case s.pki.oids.signedData:a=i.createSignedData();break;default:throw new Error("Cannot read PKCS#7 message. ContentType with OID "+c+" is not (yet) supported.")}return a.fromAsn1(t.content.value[0]),a},i.createSignedData=function(){var e=null;return e={type:s.pki.oids.signedData,version:1,certificates:[],crls:[],signers:[],digestAlgorithmIdentifiers:[],contentInfo:null,signerInfos:[],fromAsn1:function(t){if(f(e,t,i.asn1.signedDataValidator),e.certificates=[],e.crls=[],e.digestAlgorithmIdentifiers=[],e.contentInfo=null,e.signerInfos=[],e.rawCapture.certificates)for(var r=e.rawCapture.certificates.value,n=0;n<r.length;++n)e.certificates.push(s.pki.certificateFromAsn1(r[n]))},toAsn1:function(){e.contentInfo||e.sign();for(var t=[],r=0;r<e.certificates.length;++r)t.push(s.pki.certificateToAsn1(e.certificates[r]));var i=[],o=n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(e.version).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SET,!0,e.digestAlgorithmIdentifiers),e.contentInfo])]);return t.length>0&&o.value[0].value.push(n.create(n.Class.CONTEXT_SPECIFIC,0,!0,t)),i.length>0&&o.value[0].value.push(n.create(n.Class.CONTEXT_SPECIFIC,1,!0,i)),o.value[0].value.push(n.create(n.Class.UNIVERSAL,n.Type.SET,!0,e.signerInfos)),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.type).getBytes()),o])},addSigner:function(t){var r=t.issuer,n=t.serialNumber;if(t.certificate){var i=t.certificate;"string"===typeof i&&(i=s.pki.certificateFromPem(i)),r=i.issuer.attributes,n=i.serialNumber}var o=t.key;if(!o)throw new Error("Could not add PKCS#7 signer; no private key specified.");"string"===typeof o&&(o=s.pki.privateKeyFromPem(o));var a=t.digestAlgorithm||s.pki.oids.sha1;switch(a){case s.pki.oids.sha1:case s.pki.oids.sha256:case s.pki.oids.sha384:case s.pki.oids.sha512:case s.pki.oids.md5:break;default:throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: "+a)}var c=t.authenticatedAttributes||[];if(c.length>0){for(var l=!1,u=!1,h=0;h<c.length;++h){var d=c[h];if(l||d.type!==s.pki.oids.contentType){if(u||d.type!==s.pki.oids.messageDigest);else if(u=!0,l)break}else if(l=!0,u)break}if(!l||!u)throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.")}e.signers.push({key:o,version:1,issuer:r,serialNumber:n,digestAlgorithm:a,signatureAlgorithm:s.pki.oids.rsaEncryption,signature:null,authenticatedAttributes:c,unauthenticatedAttributes:[]})},sign:function(i){var o;(i=i||{},"object"!==typeof e.content||null===e.contentInfo)&&(e.contentInfo=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(s.pki.oids.data).getBytes())]),"content"in e&&(e.content instanceof s.util.ByteBuffer?o=e.content.bytes():"string"===typeof e.content&&(o=s.util.encodeUtf8(e.content)),i.detached?e.detachedContent=n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,o):e.contentInfo.value.push(n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,o)]))));if(0!==e.signers.length){var a=t();r(a)}},verify:function(){throw new Error("PKCS#7 signature verification not yet implemented.")},addCertificate:function(t){"string"===typeof t&&(t=s.pki.certificateFromPem(t)),e.certificates.push(t)},addCertificateRevokationList:function(e){throw new Error("PKCS#7 CRL support not yet implemented.")}},e;function t(){for(var t={},r=0;r<e.signers.length;++r){var i=e.signers[r],o=i.digestAlgorithm;o in t||(t[o]=s.md[s.pki.oids[o]].create()),0===i.authenticatedAttributes.length?i.md=t[o]:i.md=s.md[s.pki.oids[o]].create()}for(var o in e.digestAlgorithmIdentifiers=[],t)e.digestAlgorithmIdentifiers.push(n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(o).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")]));return t}function r(t){var r;if(e.detachedContent?r=e.detachedContent:(r=e.contentInfo.value[1],r=r.value[0]),!r)throw new Error("Could not sign PKCS#7 message; there is no content to sign.");var i=n.derToOid(e.contentInfo.value[0].value),o=n.toDer(r);for(var a in o.getByte(),n.getBerValueLength(o),o=o.getBytes(),t)t[a].start().update(o);for(var c=new Date,l=0;l<e.signers.length;++l){var u=e.signers[l];if(0===u.authenticatedAttributes.length){if(i!==s.pki.oids.data)throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.")}else{u.authenticatedAttributesAsn1=n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[]);for(var p=n.create(n.Class.UNIVERSAL,n.Type.SET,!0,[]),f=0;f<u.authenticatedAttributes.length;++f){var y=u.authenticatedAttributes[f];y.type===s.pki.oids.messageDigest?y.value=t[u.digestAlgorithm].digest():y.type===s.pki.oids.signingTime&&(y.value||(y.value=c)),p.value.push(d(y)),u.authenticatedAttributesAsn1.value.push(d(y))}o=n.toDer(p).getBytes(),u.md.start().update(o)}u.signature=u.key.sign(u.md,"RSASSA-PKCS1-V1_5")}e.signerInfos=h(e.signers)}},i.createEncryptedData=function(){var e=null;return e={type:s.pki.oids.encryptedData,version:0,encryptedContent:{algorithm:s.pki.oids["aes256-CBC"]},fromAsn1:function(t){f(e,t,i.asn1.encryptedDataValidator)},decrypt:function(t){void 0!==t&&(e.encryptedContent.key=t),y(e)}},e},i.createEnvelopedData=function(){var e=null;return e={type:s.pki.oids.envelopedData,version:0,recipients:[],encryptedContent:{algorithm:s.pki.oids["aes256-CBC"]},fromAsn1:function(t){var r=f(e,t,i.asn1.envelopedDataValidator);e.recipients=c(r.recipientInfos.value)},toAsn1:function(){return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.type).getBytes()),n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(e.version).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SET,!0,l(e.recipients)),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,p(e.encryptedContent))])])])},findRecipient:function(t){for(var r=t.issuer.attributes,s=0;s<e.recipients.length;++s){var n=e.recipients[s],i=n.issuer;if(n.serialNumber===t.serialNumber&&i.length===r.length){for(var o=!0,a=0;a<r.length;++a)if(i[a].type!==r[a].type||i[a].value!==r[a].value){o=!1;break}if(o)return n}}return null},decrypt:function(t,r){if(void 0===e.encryptedContent.key&&void 0!==t&&void 0!==r)switch(t.encryptedContent.algorithm){case s.pki.oids.rsaEncryption:case s.pki.oids.desCBC:var n=r.decrypt(t.encryptedContent.content);e.encryptedContent.key=s.util.createBuffer(n);break;default:throw new Error("Unsupported asymmetric cipher, OID "+t.encryptedContent.algorithm)}y(e)},addRecipient:function(t){e.recipients.push({version:0,issuer:t.issuer.attributes,serialNumber:t.serialNumber,encryptedContent:{algorithm:s.pki.oids.rsaEncryption,key:t.publicKey}})},encrypt:function(t,r){if(void 0===e.encryptedContent.content){var n,i,o;switch(r=r||e.encryptedContent.algorithm,t=t||e.encryptedContent.key,r){case s.pki.oids["aes128-CBC"]:n=16,i=16,o=s.aes.createEncryptionCipher;break;case s.pki.oids["aes192-CBC"]:n=24,i=16,o=s.aes.createEncryptionCipher;break;case s.pki.oids["aes256-CBC"]:n=32,i=16,o=s.aes.createEncryptionCipher;break;case s.pki.oids["des-EDE3-CBC"]:n=24,i=8,o=s.des.createEncryptionCipher;break;default:throw new Error("Unsupported symmetric cipher, OID "+r)}if(void 0===t)t=s.util.createBuffer(s.random.getBytes(n));else if(t.length()!=n)throw new Error("Symmetric key has wrong length; got "+t.length()+" bytes, expected "+n+".");e.encryptedContent.algorithm=r,e.encryptedContent.key=t,e.encryptedContent.parameter=s.util.createBuffer(s.random.getBytes(i));var a=o(t);if(a.start(e.encryptedContent.parameter.copy()),a.update(e.content),!a.finish())throw new Error("Symmetric encryption failed.");e.encryptedContent.content=a.output}for(var c=0;c<e.recipients.length;++c){var l=e.recipients[c];if(void 0===l.encryptedContent.content)switch(l.encryptedContent.algorithm){case s.pki.oids.rsaEncryption:l.encryptedContent.content=l.encryptedContent.key.encrypt(e.encryptedContent.key.data);break;default:throw new Error("Unsupported asymmetric cipher, OID "+l.encryptedContent.algorithm)}}}},e}},95496:function(e,t,r){var s=r(3832);r(3068),r(97116);var n=s.asn1,i=e.exports=s.pkcs7asn1=s.pkcs7asn1||{};s.pkcs7=s.pkcs7||{},s.pkcs7.asn1=i;var o={name:"ContentInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.ContentType",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:n.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,captureAsn1:"content"}]};i.contentInfoValidator=o;var a={name:"EncryptedContentInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentType",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"contentType"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm.parameter",tagClass:n.Class.UNIVERSAL,captureAsn1:"encParameter"}]},{name:"EncryptedContentInfo.encryptedContent",tagClass:n.Class.CONTEXT_SPECIFIC,type:0,capture:"encryptedContent",captureAsn1:"encryptedContentAsn1"}]};i.envelopedDataValidator={name:"EnvelopedData",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"EnvelopedData.Version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"version"},{name:"EnvelopedData.RecipientInfos",tagClass:n.Class.UNIVERSAL,type:n.Type.SET,constructed:!0,captureAsn1:"recipientInfos"}].concat(a)},i.encryptedDataValidator={name:"EncryptedData",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedData.Version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"version"}].concat(a)};var c={name:"SignerInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1},{name:"SignerInfo.issuerAndSerialNumber",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.issuerAndSerialNumber.issuer",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"issuer"},{name:"SignerInfo.issuerAndSerialNumber.serialNumber",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"serial"}]},{name:"SignerInfo.digestAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.digestAlgorithm.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"digestAlgorithm"},{name:"SignerInfo.digestAlgorithm.parameter",tagClass:n.Class.UNIVERSAL,constructed:!1,captureAsn1:"digestParameter",optional:!0}]},{name:"SignerInfo.authenticatedAttributes",tagClass:n.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"authenticatedAttributes"},{name:"SignerInfo.digestEncryptionAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,capture:"signatureAlgorithm"},{name:"SignerInfo.encryptedDigest",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"signature"},{name:"SignerInfo.unauthenticatedAttributes",tagClass:n.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0,capture:"unauthenticatedAttributes"}]};i.signedDataValidator={name:"SignedData",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"SignedData.Version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"version"},{name:"SignedData.DigestAlgorithms",tagClass:n.Class.UNIVERSAL,type:n.Type.SET,constructed:!0,captureAsn1:"digestAlgorithms"},o,{name:"SignedData.Certificates",tagClass:n.Class.CONTEXT_SPECIFIC,type:0,optional:!0,captureAsn1:"certificates"},{name:"SignedData.CertificateRevocationLists",tagClass:n.Class.CONTEXT_SPECIFIC,type:1,optional:!0,captureAsn1:"crls"},{name:"SignedData.SignerInfos",tagClass:n.Class.UNIVERSAL,type:n.Type.SET,capture:"signerInfos",optional:!0,value:[c]}]},i.recipientInfoValidator={name:"RecipientInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.version",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"version"},{name:"RecipientInfo.issuerAndSerial",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.issuerAndSerial.issuer",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"issuer"},{name:"RecipientInfo.issuerAndSerial.serialNumber",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"serial"}]},{name:"RecipientInfo.keyEncryptionAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.keyEncryptionAlgorithm.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"RecipientInfo.keyEncryptionAlgorithm.parameter",tagClass:n.Class.UNIVERSAL,constructed:!1,captureAsn1:"encParameter",optional:!0}]},{name:"RecipientInfo.encryptedKey",tagClass:n.Class.UNIVERSAL,type:n.Type.OCTETSTRING,constructed:!1,capture:"encKey"}]}},96007:function(e,t,r){var s=r(3832);r(49563),r(97116);var n=e.exports=s.pss=s.pss||{};n.create=function(e){3===arguments.length&&(e={md:arguments[0],mgf:arguments[1],saltLength:arguments[2]});var t,r=e.md,n=e.mgf,i=r.digestLength,o=e.salt||null;if("string"===typeof o&&(o=s.util.createBuffer(o)),"saltLength"in e)t=e.saltLength;else{if(null===o)throw new Error("Salt length not specified or specific salt not given.");t=o.length()}if(null!==o&&o.length()!==t)throw new Error("Given salt length does not match length of given salt.");var a=e.prng||s.random,c={encode:function(e,c){var l,u,h=c-1,d=Math.ceil(h/8),p=e.digest().getBytes();if(d<i+t+2)throw new Error("Message is too long to encrypt.");u=null===o?a.getBytesSync(t):o.bytes();var f=new s.util.ByteBuffer;f.fillWithByte(0,8),f.putBytes(p),f.putBytes(u),r.start(),r.update(f.getBytes());var y=r.digest().getBytes(),g=new s.util.ByteBuffer;g.fillWithByte(0,d-t-i-2),g.putByte(1),g.putBytes(u);var m=g.getBytes(),w=d-i-1,b=n.generate(y,w),_="";for(l=0;l<w;l++)_+=String.fromCharCode(m.charCodeAt(l)^b.charCodeAt(l));var E=65280>>8*d-h&255;return _=String.fromCharCode(_.charCodeAt(0)&~E)+_.substr(1),_+y+String.fromCharCode(188)},verify:function(e,o,a){var c,l=a-1,u=Math.ceil(l/8);if(o=o.substr(-u),u<i+t+2)throw new Error("Inconsistent parameters to PSS signature verification.");if(188!==o.charCodeAt(u-1))throw new Error("Encoded message does not end in 0xBC.");var h=u-i-1,d=o.substr(0,h),p=o.substr(h,i),f=65280>>8*u-l&255;if(0!==(d.charCodeAt(0)&f))throw new Error("Bits beyond keysize not zero as expected.");var y=n.generate(p,h),g="";for(c=0;c<h;c++)g+=String.fromCharCode(d.charCodeAt(c)^y.charCodeAt(c));g=String.fromCharCode(g.charCodeAt(0)&~f)+g.substr(1);var m=u-i-t-2;for(c=0;c<m;c++)if(0!==g.charCodeAt(c))throw new Error("Leftmost octets not zero as expected");if(1!==g.charCodeAt(m))throw new Error("Inconsistent PSS signature, 0x01 marker not found");var w=g.substr(-t),b=new s.util.ByteBuffer;b.fillWithByte(0,8),b.putBytes(e),b.putBytes(w),r.start(),r.update(b.getBytes());var _=r.digest().getBytes();return p===_}};return c}},25414:function(e,t,r){var s=r(3832);r(8925),r(3068),r(33480),r(28991),r(86971),r(66270),r(26953),r(96007),r(28095),r(97116);var n=s.asn1,i=e.exports=s.pki=s.pki||{},o=i.oids,a={};a["CN"]=o["commonName"],a["commonName"]="CN",a["C"]=o["countryName"],a["countryName"]="C",a["L"]=o["localityName"],a["localityName"]="L",a["ST"]=o["stateOrProvinceName"],a["stateOrProvinceName"]="ST",a["O"]=o["organizationName"],a["organizationName"]="O",a["OU"]=o["organizationalUnitName"],a["organizationalUnitName"]="OU",a["E"]=o["emailAddress"],a["emailAddress"]="E";var c=s.pki.rsa.publicKeyValidator,l={name:"Certificate",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"tbsCertificate",value:[{name:"Certificate.TBSCertificate.version",tagClass:n.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.version.integer",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"certVersion"}]},{name:"Certificate.TBSCertificate.serialNumber",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"certSerialNumber"},{name:"Certificate.TBSCertificate.signature",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.signature.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"certinfoSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:n.Class.UNIVERSAL,optional:!0,captureAsn1:"certinfoSignatureParams"}]},{name:"Certificate.TBSCertificate.issuer",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"certIssuer"},{name:"Certificate.TBSCertificate.validity",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.validity.notBefore (utc)",tagClass:n.Class.UNIVERSAL,type:n.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity1UTCTime"},{name:"Certificate.TBSCertificate.validity.notBefore (generalized)",tagClass:n.Class.UNIVERSAL,type:n.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity2GeneralizedTime"},{name:"Certificate.TBSCertificate.validity.notAfter (utc)",tagClass:n.Class.UNIVERSAL,type:n.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity3UTCTime"},{name:"Certificate.TBSCertificate.validity.notAfter (generalized)",tagClass:n.Class.UNIVERSAL,type:n.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity4GeneralizedTime"}]},{name:"Certificate.TBSCertificate.subject",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"certSubject"},c,{name:"Certificate.TBSCertificate.issuerUniqueID",tagClass:n.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.issuerUniqueID.id",tagClass:n.Class.UNIVERSAL,type:n.Type.BITSTRING,constructed:!1,captureBitStringValue:"certIssuerUniqueId"}]},{name:"Certificate.TBSCertificate.subjectUniqueID",tagClass:n.Class.CONTEXT_SPECIFIC,type:2,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.subjectUniqueID.id",tagClass:n.Class.UNIVERSAL,type:n.Type.BITSTRING,constructed:!1,captureBitStringValue:"certSubjectUniqueId"}]},{name:"Certificate.TBSCertificate.extensions",tagClass:n.Class.CONTEXT_SPECIFIC,type:3,constructed:!0,captureAsn1:"certExtensions",optional:!0}]},{name:"Certificate.signatureAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.signatureAlgorithm.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"certSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:n.Class.UNIVERSAL,optional:!0,captureAsn1:"certSignatureParams"}]},{name:"Certificate.signatureValue",tagClass:n.Class.UNIVERSAL,type:n.Type.BITSTRING,constructed:!1,captureBitStringValue:"certSignature"}]},u={name:"rsapss",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.hashAlgorithm",tagClass:n.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier",tagClass:n.Class.UNIVERSAL,type:n.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"hashOid"}]}]},{name:"rsapss.maskGenAlgorithm",tagClass:n.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier",tagClass:n.Class.UNIVERSAL,type:n.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"maskGenOid"},{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"maskGenHashOid"}]}]}]},{name:"rsapss.saltLength",tagClass:n.Class.CONTEXT_SPECIFIC,type:2,optional:!0,value:[{name:"rsapss.saltLength.saltLength",tagClass:n.Class.UNIVERSAL,type:n.Class.INTEGER,constructed:!1,capture:"saltLength"}]},{name:"rsapss.trailerField",tagClass:n.Class.CONTEXT_SPECIFIC,type:3,optional:!0,value:[{name:"rsapss.trailer.trailer",tagClass:n.Class.UNIVERSAL,type:n.Class.INTEGER,constructed:!1,capture:"trailer"}]}]},h={name:"CertificationRequestInfo",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfo",value:[{name:"CertificationRequestInfo.integer",tagClass:n.Class.UNIVERSAL,type:n.Type.INTEGER,constructed:!1,capture:"certificationRequestInfoVersion"},{name:"CertificationRequestInfo.subject",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfoSubject"},c,{name:"CertificationRequestInfo.attributes",tagClass:n.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"certificationRequestInfoAttributes",value:[{name:"CertificationRequestInfo.attributes",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequestInfo.attributes.type",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1},{name:"CertificationRequestInfo.attributes.value",tagClass:n.Class.UNIVERSAL,type:n.Type.SET,constructed:!0}]}]}]},d={name:"CertificationRequest",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,captureAsn1:"csr",value:[h,{name:"CertificationRequest.signatureAlgorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequest.signatureAlgorithm.algorithm",tagClass:n.Class.UNIVERSAL,type:n.Type.OID,constructed:!1,capture:"csrSignatureOid"},{name:"CertificationRequest.signatureAlgorithm.parameters",tagClass:n.Class.UNIVERSAL,optional:!0,captureAsn1:"csrSignatureParams"}]},{name:"CertificationRequest.signature",tagClass:n.Class.UNIVERSAL,type:n.Type.BITSTRING,constructed:!1,captureBitStringValue:"csrSignature"}]};function p(e,t){"string"===typeof t&&(t={shortName:t});for(var r,s=null,n=0;null===s&&n<e.attributes.length;++n)r=e.attributes[n],(t.type&&t.type===r.type||t.name&&t.name===r.name||t.shortName&&t.shortName===r.shortName)&&(s=r);return s}i.RDNAttributesAsArray=function(e,t){for(var r,s,i,c=[],l=0;l<e.value.length;++l){r=e.value[l];for(var u=0;u<r.value.length;++u)i={},s=r.value[u],i.type=n.derToOid(s.value[0].value),i.value=s.value[1].value,i.valueTagClass=s.value[1].type,i.type in o&&(i.name=o[i.type],i.name in a&&(i.shortName=a[i.name])),t&&(t.update(i.type),t.update(i.value)),c.push(i)}return c},i.CRIAttributesAsArray=function(e){for(var t=[],r=0;r<e.length;++r)for(var s=e[r],c=n.derToOid(s.value[0].value),l=s.value[1].value,u=0;u<l.length;++u){var h={};if(h.type=c,h.value=l[u].value,h.valueTagClass=l[u].type,h.type in o&&(h.name=o[h.type],h.name in a&&(h.shortName=a[h.name])),h.type===o.extensionRequest){h.extensions=[];for(var d=0;d<h.value.length;++d)h.extensions.push(i.certificateExtensionFromAsn1(h.value[d]))}t.push(h)}return t};var f=function(e,t,r){var s={};if(e!==o["RSASSA-PSS"])return s;r&&(s={hash:{algorithmOid:o["sha1"]},mgf:{algorithmOid:o["mgf1"],hash:{algorithmOid:o["sha1"]}},saltLength:20});var i={},a=[];if(!n.validate(t,u,i,a)){var c=new Error("Cannot read RSASSA-PSS parameter block.");throw c.errors=a,c}return void 0!==i.hashOid&&(s.hash=s.hash||{},s.hash.algorithmOid=n.derToOid(i.hashOid)),void 0!==i.maskGenOid&&(s.mgf=s.mgf||{},s.mgf.algorithmOid=n.derToOid(i.maskGenOid),s.mgf.hash=s.mgf.hash||{},s.mgf.hash.algorithmOid=n.derToOid(i.maskGenHashOid)),void 0!==i.saltLength&&(s.saltLength=i.saltLength.charCodeAt(0)),s},y=function(e){switch(o[e.signatureOid]){case"sha1WithRSAEncryption":case"sha1WithRSASignature":return s.md.sha1.create();case"md5WithRSAEncryption":return s.md.md5.create();case"sha256WithRSAEncryption":return s.md.sha256.create();case"sha384WithRSAEncryption":return s.md.sha384.create();case"sha512WithRSAEncryption":return s.md.sha512.create();case"RSASSA-PSS":return s.md.sha256.create();default:var t=new Error("Could not compute "+e.type+" digest. Unknown signature OID.");throw t.signatureOid=e.signatureOid,t}},g=function(e){var t,r=e.certificate;switch(r.signatureOid){case o.sha1WithRSAEncryption:case o.sha1WithRSASignature:break;case o["RSASSA-PSS"]:var n,i;if(n=o[r.signatureParameters.mgf.hash.algorithmOid],void 0===n||void 0===s.md[n]){var a=new Error("Unsupported MGF hash function.");throw a.oid=r.signatureParameters.mgf.hash.algorithmOid,a.name=n,a}if(i=o[r.signatureParameters.mgf.algorithmOid],void 0===i||void 0===s.mgf[i]){a=new Error("Unsupported MGF function.");throw a.oid=r.signatureParameters.mgf.algorithmOid,a.name=i,a}if(i=s.mgf[i].create(s.md[n].create()),n=o[r.signatureParameters.hash.algorithmOid],void 0===n||void 0===s.md[n]){a=new Error("Unsupported RSASSA-PSS hash function.");throw a.oid=r.signatureParameters.hash.algorithmOid,a.name=n,a}t=s.pss.create(s.md[n].create(),i,r.signatureParameters.saltLength);break}return r.publicKey.verify(e.md.digest().getBytes(),e.signature,t)};function m(e){for(var t,r,i=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]),o=e.attributes,a=0;a<o.length;++a){t=o[a];var c=t.value,l=n.Type.PRINTABLESTRING;"valueTagClass"in t&&(l=t.valueTagClass,l===n.Type.UTF8&&(c=s.util.encodeUtf8(c))),r=n.create(n.Class.UNIVERSAL,n.Type.SET,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(t.type).getBytes()),n.create(n.Class.UNIVERSAL,l,!1,c)])]),i.value.push(r)}return i}function w(e){for(var t,r=0;r<e.length;++r){if(t=e[r],"undefined"===typeof t.name&&(t.type&&t.type in i.oids?t.name=i.oids[t.type]:t.shortName&&t.shortName in a&&(t.name=i.oids[a[t.shortName]])),"undefined"===typeof t.type){if(!t.name||!(t.name in i.oids)){var s=new Error("Attribute type not specified.");throw s.attribute=t,s}t.type=i.oids[t.name]}if("undefined"===typeof t.shortName&&t.name&&t.name in a&&(t.shortName=a[t.name]),t.type===o.extensionRequest&&(t.valueConstructed=!0,t.valueTagClass=n.Type.SEQUENCE,!t.value&&t.extensions)){t.value=[];for(var c=0;c<t.extensions.length;++c)t.value.push(i.certificateExtensionToAsn1(b(t.extensions[c])))}if("undefined"===typeof t.value){s=new Error("Attribute value not specified.");throw s.attribute=t,s}}}function b(e,t){if(t=t||{},"undefined"===typeof e.name&&e.id&&e.id in i.oids&&(e.name=i.oids[e.id]),"undefined"===typeof e.id){if(!e.name||!(e.name in i.oids)){var r=new Error("Extension ID not specified.");throw r.extension=e,r}e.id=i.oids[e.name]}if("undefined"!==typeof e.value)return e;if("keyUsage"===e.name){var a=0,c=0,l=0;e.digitalSignature&&(c|=128,a=7),e.nonRepudiation&&(c|=64,a=6),e.keyEncipherment&&(c|=32,a=5),e.dataEncipherment&&(c|=16,a=4),e.keyAgreement&&(c|=8,a=3),e.keyCertSign&&(c|=4,a=2),e.cRLSign&&(c|=2,a=1),e.encipherOnly&&(c|=1,a=0),e.decipherOnly&&(l|=128,a=7);var u=String.fromCharCode(a);0!==l?u+=String.fromCharCode(c)+String.fromCharCode(l):0!==c&&(u+=String.fromCharCode(c)),e.value=n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,u)}else if("basicConstraints"===e.name)e.value=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]),e.cA&&e.value.value.push(n.create(n.Class.UNIVERSAL,n.Type.BOOLEAN,!1,String.fromCharCode(255))),"pathLenConstraint"in e&&e.value.value.push(n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(e.pathLenConstraint).getBytes()));else if("extKeyUsage"===e.name){e.value=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);var h=e.value.value;for(var d in e)!0===e[d]&&(d in o?h.push(n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(o[d]).getBytes())):-1!==d.indexOf(".")&&h.push(n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(d).getBytes())))}else if("nsCertType"===e.name){a=0,c=0;e.client&&(c|=128,a=7),e.server&&(c|=64,a=6),e.email&&(c|=32,a=5),e.objsign&&(c|=16,a=4),e.reserved&&(c|=8,a=3),e.sslCA&&(c|=4,a=2),e.emailCA&&(c|=2,a=1),e.objCA&&(c|=1,a=0);u=String.fromCharCode(a);0!==c&&(u+=String.fromCharCode(c)),e.value=n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,u)}else if("subjectAltName"===e.name||"issuerAltName"===e.name){e.value=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);for(var p=0;p<e.altNames.length;++p){b=e.altNames[p];u=b.value;if(7===b.type&&b.ip){if(u=s.util.bytesFromIP(b.ip),null===u){r=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');throw r.extension=e,r}}else 8===b.type&&(u=b.oid?n.oidToDer(n.oidToDer(b.oid)):n.oidToDer(u));e.value.value.push(n.create(n.Class.CONTEXT_SPECIFIC,b.type,!1,u))}}else if("nsComment"===e.name&&t.cert){if(!/^[\x00-\x7F]*$/.test(e.comment)||e.comment.length<1||e.comment.length>128)throw new Error('Invalid "nsComment" content.');e.value=n.create(n.Class.UNIVERSAL,n.Type.IA5STRING,!1,e.comment)}else if("subjectKeyIdentifier"===e.name&&t.cert){var f=t.cert.generateSubjectKeyIdentifier();e.subjectKeyIdentifier=f.toHex(),e.value=n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,f.getBytes())}else if("authorityKeyIdentifier"===e.name&&t.cert){e.value=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);h=e.value.value;if(e.keyIdentifier){var y=!0===e.keyIdentifier?t.cert.generateSubjectKeyIdentifier().getBytes():e.keyIdentifier;h.push(n.create(n.Class.CONTEXT_SPECIFIC,0,!1,y))}if(e.authorityCertIssuer){var g=[n.create(n.Class.CONTEXT_SPECIFIC,4,!0,[m(!0===e.authorityCertIssuer?t.cert.issuer:e.authorityCertIssuer)])];h.push(n.create(n.Class.CONTEXT_SPECIFIC,1,!0,g))}if(e.serialNumber){var w=s.util.hexToBytes(!0===e.serialNumber?t.cert.serialNumber:e.serialNumber);h.push(n.create(n.Class.CONTEXT_SPECIFIC,2,!1,w))}}else if("cRLDistributionPoints"===e.name){e.value=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);h=e.value.value;var b,_=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]),E=n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[]);for(p=0;p<e.altNames.length;++p){b=e.altNames[p];u=b.value;if(7===b.type&&b.ip){if(u=s.util.bytesFromIP(b.ip),null===u){r=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');throw r.extension=e,r}}else 8===b.type&&(u=b.oid?n.oidToDer(n.oidToDer(b.oid)):n.oidToDer(u));E.value.push(n.create(n.Class.CONTEXT_SPECIFIC,b.type,!1,u))}_.value.push(n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[E])),h.push(_)}if("undefined"===typeof e.value){r=new Error("Extension value not specified.");throw r.extension=e,r}return e}function _(e,t){switch(e){case o["RSASSA-PSS"]:var r=[];return void 0!==t.hash.algorithmOid&&r.push(n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(t.hash.algorithmOid).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")])])),void 0!==t.mgf.algorithmOid&&r.push(n.create(n.Class.CONTEXT_SPECIFIC,1,!0,[n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(t.mgf.algorithmOid).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(t.mgf.hash.algorithmOid).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")])])])),void 0!==t.saltLength&&r.push(n.create(n.Class.CONTEXT_SPECIFIC,2,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(t.saltLength).getBytes())])),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,r);default:return n.create(n.Class.UNIVERSAL,n.Type.NULL,!1,"")}}function E(e){var t=n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[]);if(0===e.attributes.length)return t;for(var r=e.attributes,i=0;i<r.length;++i){var o=r[i],a=o.value,c=n.Type.UTF8;"valueTagClass"in o&&(c=o.valueTagClass),c===n.Type.UTF8&&(a=s.util.encodeUtf8(a));var l=!1;"valueConstructed"in o&&(l=o.valueConstructed);var u=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(o.type).getBytes()),n.create(n.Class.UNIVERSAL,n.Type.SET,!0,[n.create(n.Class.UNIVERSAL,c,l,a)])]);t.value.push(u)}return t}i.certificateFromPem=function(e,t,r){var o=s.pem.decode(e)[0];if("CERTIFICATE"!==o.type&&"X509 CERTIFICATE"!==o.type&&"TRUSTED CERTIFICATE"!==o.type){var a=new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');throw a.headerType=o.type,a}if(o.procType&&"ENCRYPTED"===o.procType.type)throw new Error("Could not convert certificate from PEM; PEM is encrypted.");var c=n.fromDer(o.body,r);return i.certificateFromAsn1(c,t)},i.certificateToPem=function(e,t){var r={type:"CERTIFICATE",body:n.toDer(i.certificateToAsn1(e)).getBytes()};return s.pem.encode(r,{maxline:t})},i.publicKeyFromPem=function(e){var t=s.pem.decode(e)[0];if("PUBLIC KEY"!==t.type&&"RSA PUBLIC KEY"!==t.type){var r=new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');throw r.headerType=t.type,r}if(t.procType&&"ENCRYPTED"===t.procType.type)throw new Error("Could not convert public key from PEM; PEM is encrypted.");var o=n.fromDer(t.body);return i.publicKeyFromAsn1(o)},i.publicKeyToPem=function(e,t){var r={type:"PUBLIC KEY",body:n.toDer(i.publicKeyToAsn1(e)).getBytes()};return s.pem.encode(r,{maxline:t})},i.publicKeyToRSAPublicKeyPem=function(e,t){var r={type:"RSA PUBLIC KEY",body:n.toDer(i.publicKeyToRSAPublicKey(e)).getBytes()};return s.pem.encode(r,{maxline:t})},i.getPublicKeyFingerprint=function(e,t){t=t||{};var r,o=t.md||s.md.sha1.create(),a=t.type||"RSAPublicKey";switch(a){case"RSAPublicKey":r=n.toDer(i.publicKeyToRSAPublicKey(e)).getBytes();break;case"SubjectPublicKeyInfo":r=n.toDer(i.publicKeyToAsn1(e)).getBytes();break;default:throw new Error('Unknown fingerprint type "'+t.type+'".')}o.start(),o.update(r);var c=o.digest();if("hex"===t.encoding){var l=c.toHex();return t.delimiter?l.match(/.{2}/g).join(t.delimiter):l}if("binary"===t.encoding)return c.getBytes();if(t.encoding)throw new Error('Unknown encoding "'+t.encoding+'".');return c},i.certificationRequestFromPem=function(e,t,r){var o=s.pem.decode(e)[0];if("CERTIFICATE REQUEST"!==o.type){var a=new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');throw a.headerType=o.type,a}if(o.procType&&"ENCRYPTED"===o.procType.type)throw new Error("Could not convert certification request from PEM; PEM is encrypted.");var c=n.fromDer(o.body,r);return i.certificationRequestFromAsn1(c,t)},i.certificationRequestToPem=function(e,t){var r={type:"CERTIFICATE REQUEST",body:n.toDer(i.certificationRequestToAsn1(e)).getBytes()};return s.pem.encode(r,{maxline:t})},i.createCertificate=function(){var e={version:2,serialNumber:"00",signatureOid:null,signature:null,siginfo:{}};return e.siginfo.algorithmOid=null,e.validity={},e.validity.notBefore=new Date,e.validity.notAfter=new Date,e.issuer={},e.issuer.getField=function(t){return p(e.issuer,t)},e.issuer.addField=function(t){w([t]),e.issuer.attributes.push(t)},e.issuer.attributes=[],e.issuer.hash=null,e.subject={},e.subject.getField=function(t){return p(e.subject,t)},e.subject.addField=function(t){w([t]),e.subject.attributes.push(t)},e.subject.attributes=[],e.subject.hash=null,e.extensions=[],e.publicKey=null,e.md=null,e.setSubject=function(t,r){w(t),e.subject.attributes=t,delete e.subject.uniqueId,r&&(e.subject.uniqueId=r),e.subject.hash=null},e.setIssuer=function(t,r){w(t),e.issuer.attributes=t,delete e.issuer.uniqueId,r&&(e.issuer.uniqueId=r),e.issuer.hash=null},e.setExtensions=function(t){for(var r=0;r<t.length;++r)b(t[r],{cert:e});e.extensions=t},e.getExtension=function(t){"string"===typeof t&&(t={name:t});for(var r,s=null,n=0;null===s&&n<e.extensions.length;++n)r=e.extensions[n],(t.id&&r.id===t.id||t.name&&r.name===t.name)&&(s=r);return s},e.sign=function(t,r){e.md=r||s.md.sha1.create();var a=o[e.md.algorithm+"WithRSAEncryption"];if(!a){var c=new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");throw c.algorithm=e.md.algorithm,c}e.signatureOid=e.siginfo.algorithmOid=a,e.tbsCertificate=i.getTBSCertificate(e);var l=n.toDer(e.tbsCertificate);e.md.update(l.getBytes()),e.signature=t.sign(e.md)},e.verify=function(t){var r=!1;if(!e.issued(t)){var s=t.issuer,o=e.subject,a=new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");throw a.expectedIssuer=o.attributes,a.actualIssuer=s.attributes,a}var c=t.md;if(null===c){c=y({signatureOid:t.signatureOid,type:"certificate"});var l=t.tbsCertificate||i.getTBSCertificate(t),u=n.toDer(l);c.update(u.getBytes())}return null!==c&&(r=g({certificate:e,md:c,signature:t.signature})),r},e.isIssuer=function(t){var r=!1,s=e.issuer,n=t.subject;if(s.hash&&n.hash)r=s.hash===n.hash;else if(s.attributes.length===n.attributes.length){var i,o;r=!0;for(var a=0;r&&a<s.attributes.length;++a)i=s.attributes[a],o=n.attributes[a],i.type===o.type&&i.value===o.value||(r=!1)}return r},e.issued=function(t){return t.isIssuer(e)},e.generateSubjectKeyIdentifier=function(){return i.getPublicKeyFingerprint(e.publicKey,{type:"RSAPublicKey"})},e.verifySubjectKeyIdentifier=function(){for(var t=o["subjectKeyIdentifier"],r=0;r<e.extensions.length;++r){var n=e.extensions[r];if(n.id===t){var i=e.generateSubjectKeyIdentifier().getBytes();return s.util.hexToBytes(n.subjectKeyIdentifier)===i}}return!1},e},i.certificateFromAsn1=function(e,t){var r={},o=[];if(!n.validate(e,l,r,o)){var a=new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");throw a.errors=o,a}var c=n.derToOid(r.publicKeyOid);if(c!==i.oids.rsaEncryption)throw new Error("Cannot read public key. OID is not RSA.");var u=i.createCertificate();u.version=r.certVersion?r.certVersion.charCodeAt(0):0;var h=s.util.createBuffer(r.certSerialNumber);u.serialNumber=h.toHex(),u.signatureOid=s.asn1.derToOid(r.certSignatureOid),u.signatureParameters=f(u.signatureOid,r.certSignatureParams,!0),u.siginfo.algorithmOid=s.asn1.derToOid(r.certinfoSignatureOid),u.siginfo.parameters=f(u.siginfo.algorithmOid,r.certinfoSignatureParams,!1),u.signature=r.certSignature;var d=[];if(void 0!==r.certValidity1UTCTime&&d.push(n.utcTimeToDate(r.certValidity1UTCTime)),void 0!==r.certValidity2GeneralizedTime&&d.push(n.generalizedTimeToDate(r.certValidity2GeneralizedTime)),void 0!==r.certValidity3UTCTime&&d.push(n.utcTimeToDate(r.certValidity3UTCTime)),void 0!==r.certValidity4GeneralizedTime&&d.push(n.generalizedTimeToDate(r.certValidity4GeneralizedTime)),d.length>2)throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");if(d.length<2)throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");if(u.validity.notBefore=d[0],u.validity.notAfter=d[1],u.tbsCertificate=r.tbsCertificate,t){u.md=y({signatureOid:u.signatureOid,type:"certificate"});var g=n.toDer(u.tbsCertificate);u.md.update(g.getBytes())}var m=s.md.sha1.create(),b=n.toDer(r.certIssuer);m.update(b.getBytes()),u.issuer.getField=function(e){return p(u.issuer,e)},u.issuer.addField=function(e){w([e]),u.issuer.attributes.push(e)},u.issuer.attributes=i.RDNAttributesAsArray(r.certIssuer),r.certIssuerUniqueId&&(u.issuer.uniqueId=r.certIssuerUniqueId),u.issuer.hash=m.digest().toHex();var _=s.md.sha1.create(),E=n.toDer(r.certSubject);return _.update(E.getBytes()),u.subject.getField=function(e){return p(u.subject,e)},u.subject.addField=function(e){w([e]),u.subject.attributes.push(e)},u.subject.attributes=i.RDNAttributesAsArray(r.certSubject),r.certSubjectUniqueId&&(u.subject.uniqueId=r.certSubjectUniqueId),u.subject.hash=_.digest().toHex(),r.certExtensions?u.extensions=i.certificateExtensionsFromAsn1(r.certExtensions):u.extensions=[],u.publicKey=i.publicKeyFromAsn1(r.subjectPublicKeyInfo),u},i.certificateExtensionsFromAsn1=function(e){for(var t=[],r=0;r<e.value.length;++r)for(var s=e.value[r],n=0;n<s.value.length;++n)t.push(i.certificateExtensionFromAsn1(s.value[n]));return t},i.certificateExtensionFromAsn1=function(e){var t={};if(t.id=n.derToOid(e.value[0].value),t.critical=!1,e.value[1].type===n.Type.BOOLEAN?(t.critical=0!==e.value[1].value.charCodeAt(0),t.value=e.value[2].value):t.value=e.value[1].value,t.id in o)if(t.name=o[t.id],"keyUsage"===t.name){var r=n.fromDer(t.value),i=0,a=0;r.value.length>1&&(i=r.value.charCodeAt(1),a=r.value.length>2?r.value.charCodeAt(2):0),t.digitalSignature=128===(128&i),t.nonRepudiation=64===(64&i),t.keyEncipherment=32===(32&i),t.dataEncipherment=16===(16&i),t.keyAgreement=8===(8&i),t.keyCertSign=4===(4&i),t.cRLSign=2===(2&i),t.encipherOnly=1===(1&i),t.decipherOnly=128===(128&a)}else if("basicConstraints"===t.name){r=n.fromDer(t.value);r.value.length>0&&r.value[0].type===n.Type.BOOLEAN?t.cA=0!==r.value[0].value.charCodeAt(0):t.cA=!1;var c=null;r.value.length>0&&r.value[0].type===n.Type.INTEGER?c=r.value[0].value:r.value.length>1&&(c=r.value[1].value),null!==c&&(t.pathLenConstraint=n.derToInteger(c))}else if("extKeyUsage"===t.name){r=n.fromDer(t.value);for(var l=0;l<r.value.length;++l){var u=n.derToOid(r.value[l].value);u in o?t[o[u]]=!0:t[u]=!0}}else if("nsCertType"===t.name){r=n.fromDer(t.value),i=0;r.value.length>1&&(i=r.value.charCodeAt(1)),t.client=128===(128&i),t.server=64===(64&i),t.email=32===(32&i),t.objsign=16===(16&i),t.reserved=8===(8&i),t.sslCA=4===(4&i),t.emailCA=2===(2&i),t.objCA=1===(1&i)}else if("subjectAltName"===t.name||"issuerAltName"===t.name){var h;t.altNames=[];r=n.fromDer(t.value);for(var d=0;d<r.value.length;++d){h=r.value[d];var p={type:h.type,value:h.value};switch(t.altNames.push(p),h.type){case 1:case 2:case 6:break;case 7:p.ip=s.util.bytesToIP(h.value);break;case 8:p.oid=n.derToOid(h.value);break;default:}}}else if("subjectKeyIdentifier"===t.name){r=n.fromDer(t.value);t.subjectKeyIdentifier=s.util.bytesToHex(r.value)}return t},i.certificationRequestFromAsn1=function(e,t){var r={},o=[];if(!n.validate(e,d,r,o)){var a=new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");throw a.errors=o,a}var c=n.derToOid(r.publicKeyOid);if(c!==i.oids.rsaEncryption)throw new Error("Cannot read public key. OID is not RSA.");var l=i.createCertificationRequest();if(l.version=r.csrVersion?r.csrVersion.charCodeAt(0):0,l.signatureOid=s.asn1.derToOid(r.csrSignatureOid),l.signatureParameters=f(l.signatureOid,r.csrSignatureParams,!0),l.siginfo.algorithmOid=s.asn1.derToOid(r.csrSignatureOid),l.siginfo.parameters=f(l.siginfo.algorithmOid,r.csrSignatureParams,!1),l.signature=r.csrSignature,l.certificationRequestInfo=r.certificationRequestInfo,t){l.md=y({signatureOid:l.signatureOid,type:"certification request"});var u=n.toDer(l.certificationRequestInfo);l.md.update(u.getBytes())}var h=s.md.sha1.create();return l.subject.getField=function(e){return p(l.subject,e)},l.subject.addField=function(e){w([e]),l.subject.attributes.push(e)},l.subject.attributes=i.RDNAttributesAsArray(r.certificationRequestInfoSubject,h),l.subject.hash=h.digest().toHex(),l.publicKey=i.publicKeyFromAsn1(r.subjectPublicKeyInfo),l.getAttribute=function(e){return p(l,e)},l.addAttribute=function(e){w([e]),l.attributes.push(e)},l.attributes=i.CRIAttributesAsArray(r.certificationRequestInfoAttributes||[]),l},i.createCertificationRequest=function(){var e={version:0,signatureOid:null,signature:null,siginfo:{}};return e.siginfo.algorithmOid=null,e.subject={},e.subject.getField=function(t){return p(e.subject,t)},e.subject.addField=function(t){w([t]),e.subject.attributes.push(t)},e.subject.attributes=[],e.subject.hash=null,e.publicKey=null,e.attributes=[],e.getAttribute=function(t){return p(e,t)},e.addAttribute=function(t){w([t]),e.attributes.push(t)},e.md=null,e.setSubject=function(t){w(t),e.subject.attributes=t,e.subject.hash=null},e.setAttributes=function(t){w(t),e.attributes=t},e.sign=function(t,r){e.md=r||s.md.sha1.create();var a=o[e.md.algorithm+"WithRSAEncryption"];if(!a){var c=new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");throw c.algorithm=e.md.algorithm,c}e.signatureOid=e.siginfo.algorithmOid=a,e.certificationRequestInfo=i.getCertificationRequestInfo(e);var l=n.toDer(e.certificationRequestInfo);e.md.update(l.getBytes()),e.signature=t.sign(e.md)},e.verify=function(){var t=!1,r=e.md;if(null===r){r=y({signatureOid:e.signatureOid,type:"certification request"});var s=e.certificationRequestInfo||i.getCertificationRequestInfo(e),o=n.toDer(s);r.update(o.getBytes())}return null!==r&&(t=g({certificate:e,md:r,signature:e.signature})),t},e};var v=new Date("1950-01-01T00:00:00Z"),S=new Date("2050-01-01T00:00:00Z");function I(e){return e>=v&&e<S?n.create(n.Class.UNIVERSAL,n.Type.UTCTIME,!1,n.dateToUtcTime(e)):n.create(n.Class.UNIVERSAL,n.Type.GENERALIZEDTIME,!1,n.dateToGeneralizedTime(e))}i.getTBSCertificate=function(e){var t=I(e.validity.notBefore),r=I(e.validity.notAfter),o=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.CONTEXT_SPECIFIC,0,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(e.version).getBytes())]),n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,s.util.hexToBytes(e.serialNumber)),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.siginfo.algorithmOid).getBytes()),_(e.siginfo.algorithmOid,e.siginfo.parameters)]),m(e.issuer),n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[t,r]),m(e.subject),i.publicKeyToAsn1(e.publicKey)]);return e.issuer.uniqueId&&o.value.push(n.create(n.Class.CONTEXT_SPECIFIC,1,!0,[n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,String.fromCharCode(0)+e.issuer.uniqueId)])),e.subject.uniqueId&&o.value.push(n.create(n.Class.CONTEXT_SPECIFIC,2,!0,[n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,String.fromCharCode(0)+e.subject.uniqueId)])),e.extensions.length>0&&o.value.push(i.certificateExtensionsToAsn1(e.extensions)),o},i.getCertificationRequestInfo=function(e){var t=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.INTEGER,!1,n.integerToDer(e.version).getBytes()),m(e.subject),i.publicKeyToAsn1(e.publicKey),E(e)]);return t},i.distinguishedNameToAsn1=function(e){return m(e)},i.certificateToAsn1=function(e){var t=e.tbsCertificate||i.getTBSCertificate(e);return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[t,n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.signatureOid).getBytes()),_(e.signatureOid,e.signatureParameters)]),n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},i.certificateExtensionsToAsn1=function(e){var t=n.create(n.Class.CONTEXT_SPECIFIC,3,!0,[]),r=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);t.value.push(r);for(var s=0;s<e.length;++s)r.value.push(i.certificateExtensionToAsn1(e[s]));return t},i.certificateExtensionToAsn1=function(e){var t=n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[]);t.value.push(n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.id).getBytes())),e.critical&&t.value.push(n.create(n.Class.UNIVERSAL,n.Type.BOOLEAN,!1,String.fromCharCode(255)));var r=e.value;return"string"!==typeof e.value&&(r=n.toDer(r).getBytes()),t.value.push(n.create(n.Class.UNIVERSAL,n.Type.OCTETSTRING,!1,r)),t},i.certificationRequestToAsn1=function(e){var t=e.certificationRequestInfo||i.getCertificationRequestInfo(e);return n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[t,n.create(n.Class.UNIVERSAL,n.Type.SEQUENCE,!0,[n.create(n.Class.UNIVERSAL,n.Type.OID,!1,n.oidToDer(e.signatureOid).getBytes()),_(e.signatureOid,e.signatureParameters)]),n.create(n.Class.UNIVERSAL,n.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},i.createCaStore=function(e){var t={certs:{}};function r(e){return o(e),t.certs[e.hash]||null}function o(e){if(!e.hash){var t=s.md.sha1.create();e.attributes=i.RDNAttributesAsArray(m(e),t),e.hash=t.digest().toHex()}}if(t.getIssuer=function(e){var t=r(e.issuer);return t},t.addCertificate=function(e){if("string"===typeof e&&(e=s.pki.certificateFromPem(e)),o(e.subject),!t.hasCertificate(e))if(e.subject.hash in t.certs){var r=t.certs[e.subject.hash];s.util.isArray(r)||(r=[r]),r.push(e),t.certs[e.subject.hash]=r}else t.certs[e.subject.hash]=e},t.hasCertificate=function(e){"string"===typeof e&&(e=s.pki.certificateFromPem(e));var t=r(e.subject);if(!t)return!1;s.util.isArray(t)||(t=[t]);for(var o=n.toDer(i.certificateToAsn1(e)).getBytes(),a=0;a<t.length;++a){var c=n.toDer(i.certificateToAsn1(t[a])).getBytes();if(o===c)return!0}return!1},t.listAllCertificates=function(){var e=[];for(var r in t.certs)if(t.certs.hasOwnProperty(r)){var n=t.certs[r];if(s.util.isArray(n))for(var i=0;i<n.length;++i)e.push(n[i]);else e.push(n)}return e},t.removeCertificate=function(e){var a;if("string"===typeof e&&(e=s.pki.certificateFromPem(e)),o(e.subject),!t.hasCertificate(e))return null;var c=r(e.subject);if(!s.util.isArray(c))return a=t.certs[e.subject.hash],delete t.certs[e.subject.hash],a;for(var l=n.toDer(i.certificateToAsn1(e)).getBytes(),u=0;u<c.length;++u){var h=n.toDer(i.certificateToAsn1(c[u])).getBytes();l===h&&(a=c[u],c.splice(u,1))}return 0===c.length&&delete t.certs[e.subject.hash],a},e)for(var a=0;a<e.length;++a){var c=e[a];t.addCertificate(c)}return t},i.certificateError={bad_certificate:"forge.pki.BadCertificate",unsupported_certificate:"forge.pki.UnsupportedCertificate",certificate_revoked:"forge.pki.CertificateRevoked",certificate_expired:"forge.pki.CertificateExpired",certificate_unknown:"forge.pki.CertificateUnknown",unknown_ca:"forge.pki.UnknownCertificateAuthority"},i.verifyCertificateChain=function(e,t,r){"function"===typeof r&&(r={verify:r}),r=r||{},t=t.slice(0);var n=t.slice(0),o=r.validityCheckDate;"undefined"===typeof o&&(o=new Date);var a=!0,c=null,l=0;do{var u=t.shift(),h=null,d=!1;if(o&&(o<u.validity.notBefore||o>u.validity.notAfter)&&(c={message:"Certificate is not valid yet or has expired.",error:i.certificateError.certificate_expired,notBefore:u.validity.notBefore,notAfter:u.validity.notAfter,now:o}),null===c){if(h=t[0]||e.getIssuer(u),null===h&&u.isIssuer(u)&&(d=!0,h=u),h){var p=h;s.util.isArray(p)||(p=[p]);var f=!1;while(!f&&p.length>0){h=p.shift();try{f=h.verify(u)}catch(S){}}f||(c={message:"Certificate signature is invalid.",error:i.certificateError.bad_certificate})}null!==c||h&&!d||e.hasCertificate(u)||(c={message:"Certificate is not trusted.",error:i.certificateError.unknown_ca})}if(null===c&&h&&!u.isIssuer(h)&&(c={message:"Certificate issuer is invalid.",error:i.certificateError.bad_certificate}),null===c)for(var y={keyUsage:!0,basicConstraints:!0},g=0;null===c&&g<u.extensions.length;++g){var m=u.extensions[g];m.critical&&!(m.name in y)&&(c={message:"Certificate has an unsupported critical extension.",error:i.certificateError.unsupported_certificate})}if(null===c&&(!a||0===t.length&&(!h||d))){var w=u.getExtension("basicConstraints"),b=u.getExtension("keyUsage");if(null!==b&&(b.keyCertSign&&null!==w||(c={message:"Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",error:i.certificateError.bad_certificate})),null!==c||null===w||w.cA||(c={message:"Certificate basicConstraints indicates the certificate is not a CA.",error:i.certificateError.bad_certificate}),null===c&&null!==b&&"pathLenConstraint"in w){var _=l-1;_>w.pathLenConstraint&&(c={message:"Certificate basicConstraints pathLenConstraint violated.",error:i.certificateError.bad_certificate})}}var E=null===c||c.error,v=r.verify?r.verify(E,l,n):E;if(!0!==v)throw!0===E&&(c={message:"The application rejected the certificate.",error:i.certificateError.bad_certificate}),(v||0===v)&&("object"!==typeof v||s.util.isArray(v)?"string"===typeof v&&(c.error=v):(v.message&&(c.message=v.message),v.error&&(c.error=v.error))),c;c=null,a=!1,++l}while(t.length>0);return!0}},35103:function(e,t,r){const s=r(91607),n=r(50603);e.exports=class{constructor(){this._buffer=new s,this._waitingConsumers=new s}push(e){const{promise:t,resolve:r}=n();return this._buffer.push({chunk:e,resolve:r}),this._consume(),t}_consume(){while(!this._waitingConsumers.isEmpty()&&!this._buffer.isEmpty()){const e=this._waitingConsumers.shift(),t=this._buffer.shift();e.resolve(t.chunk),t.resolve()}}shift(){const{promise:e,resolve:t}=n();return this._waitingConsumers.push({resolve:t}),this._consume(),e}isEmpty(){return this._buffer.isEmpty()}}},50603:function(e){"use strict";const t=()=>{const e={};return e.promise=new Promise(((t,r)=>{e.resolve=t,e.reject=r})),e};e.exports=t},62100:function(e,t,r){"use strict";e.exports=r(89482)},33286:function(e,t,r){const{instantiate:s}=r(19824);function n(e={}){if(!n.supported)return null;var t=new Uint8Array([0,97,115,109,1,0,0,0,1,78,14,96,2,127,126,0,96,1,127,1,126,96,2,127,127,0,96,1,127,1,127,96,1,127,0,96,2,127,127,1,127,96,3,127,127,127,1,127,96,0,0,96,3,127,127,127,0,96,0,1,127,96,4,127,127,127,127,0,96,5,127,127,127,127,127,1,127,96,1,126,1,127,96,2,126,126,1,126,2,13,1,3,101,110,118,5,97,98,111,114,116,0,10,3,54,53,2,2,8,9,3,5,2,8,6,5,3,4,2,6,9,12,13,2,5,11,3,2,3,2,3,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,6,7,7,4,4,5,3,1,0,1,6,47,9,127,1,65,0,11,127,1,65,0,11,127,0,65,3,11,127,0,65,4,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,0,65,240,2,11,127,0,65,6,11,7,240,5,41,6,109,101,109,111,114,121,2,0,7,95,95,97,108,108,111,99,0,10,8,95,95,114,101,116,97,105,110,0,11,9,95,95,114,101,108,101,97,115,101,0,12,9,95,95,99,111,108,108,101,99,116,0,51,11,95,95,114,116,116,105,95,98,97,115,101,3,7,13,73,110,116,51,50,65,114,114,97,121,95,73,68,3,2,13,85,105,110,116,56,65,114,114,97,121,95,73,68,3,3,6,100,101,103,114,101,101,0,16,3,109,111,100,0,17,5,82,97,98,105,110,3,8,16,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,0,21,16,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,0,22,21,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,23,21,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,24,14,82,97,98,105,110,35,103,101,116,58,119,112,111,115,0,25,14,82,97,98,105,110,35,115,101,116,58,119,112,111,115,0,26,15,82,97,98,105,110,35,103,101,116,58,99,111,117,110,116,0,27,15,82,97,98,105,110,35,115,101,116,58,99,111,117,110,116,0,28,13,82,97,98,105,110,35,103,101,116,58,112,111,115,0,29,13,82,97,98,105,110,35,115,101,116,58,112,111,115,0,30,15,82,97,98,105,110,35,103,101,116,58,115,116,97,114,116,0,31,15,82,97,98,105,110,35,115,101,116,58,115,116,97,114,116,0,32,16,82,97,98,105,110,35,103,101,116,58,100,105,103,101,115,116,0,33,16,82,97,98,105,110,35,115,101,116,58,100,105,103,101,115,116,0,34,21,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,35,21,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,36,22,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,37,22,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,38,31,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,39,31,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,40,20,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,0,41,20,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,0,42,17,82,97,98,105,110,35,103,101,116,58,109,105,110,115,105,122,101,0,43,17,82,97,98,105,110,35,115,101,116,58,109,105,110,115,105,122,101,0,44,17,82,97,98,105,110,35,103,101,116,58,109,97,120,115,105,122,101,0,45,17,82,97,98,105,110,35,115,101,116,58,109,97,120,115,105,122,101,0,46,14,82,97,98,105,110,35,103,101,116,58,109,97,115,107,0,47,14,82,97,98,105,110,35,115,101,116,58,109,97,115,107,0,48,17,82,97,98,105,110,35,99,111,110,115,116,114,117,99,116,111,114,0,20,17,82,97,98,105,110,35,102,105,110,103,101,114,112,114,105,110,116,0,49,8,1,50,10,165,31,53,199,1,1,4,127,32,1,40,2,0,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,3,65,4,107,118,65,16,115,33,4,32,3,65,7,107,11,33,3,32,1,40,2,20,33,2,32,1,40,2,16,34,5,4,64,32,5,32,2,54,2,20,11,32,2,4,64,32,2,32,5,54,2,16,11,32,1,32,0,32,4,32,3,65,4,116,106,65,2,116,106,40,2,96,70,4,64,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,2,54,2,96,32,2,69,4,64,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,65,127,115,113,34,1,54,2,4,32,1,69,4,64,32,0,32,0,40,2,0,65,1,32,3,116,65,127,115,113,54,2,0,11,11,11,11,226,2,1,6,127,32,1,40,2,0,33,3,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,34,5,65,1,113,4,64,32,3,65,124,113,65,16,106,32,5,65,124,113,106,34,2,65,240,255,255,255,3,73,4,64,32,0,32,4,16,1,32,1,32,2,32,3,65,3,113,114,34,3,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,33,5,11,11,32,3,65,2,113,4,64,32,1,65,4,107,40,2,0,34,2,40,2,0,34,6,65,124,113,65,16,106,32,3,65,124,113,106,34,7,65,240,255,255,255,3,73,4,64,32,0,32,2,16,1,32,2,32,7,32,6,65,3,113,114,34,3,54,2,0,32,2,33,1,11,11,32,4,32,5,65,2,114,54,2,0,32,4,65,4,107,32,1,54,2,0,32,0,32,3,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,2,65,4,107,118,65,16,115,33,4,32,2,65,7,107,11,34,3,65,4,116,32,4,106,65,2,116,106,40,2,96,33,2,32,1,65,0,54,2,16,32,1,32,2,54,2,20,32,2,4,64,32,2,32,1,54,2,16,11,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,1,54,2,96,32,0,32,0,40,2,0,65,1,32,3,116,114,54,2,0,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,114,54,2,4,11,119,1,1,127,32,2,2,127,32,0,40,2,160,12,34,2,4,64,32,2,32,1,65,16,107,70,4,64,32,2,40,2,0,33,3,32,1,65,16,107,33,1,11,11,32,1,11,107,34,2,65,48,73,4,64,15,11,32,1,32,3,65,2,113,32,2,65,32,107,65,1,114,114,54,2,0,32,1,65,0,54,2,16,32,1,65,0,54,2,20,32,1,32,2,106,65,16,107,34,2,65,2,54,2,0,32,0,32,2,54,2,160,12,32,0,32,1,16,2,11,155,1,1,3,127,35,0,34,0,69,4,64,65,1,63,0,34,0,74,4,127,65,1,32,0,107,64,0,65,0,72,5,65,0,11,4,64,0,11,65,176,3,34,0,65,0,54,2,0,65,208,15,65,0,54,2,0,3,64,32,1,65,23,73,4,64,32,1,65,2,116,65,176,3,106,65,0,54,2,4,65,0,33,2,3,64,32,2,65,16,73,4,64,32,1,65,4,116,32,2,106,65,2,116,65,176,3,106,65,0,54,2,96,32,2,65,1,106,33,2,12,1,11,11,32,1,65,1,106,33,1,12,1,11,11,65,176,3,65,224,15,63,0,65,16,116,16,3,65,176,3,36,0,11,32,0,11,45,0,32,0,65,240,255,255,255,3,79,4,64,65,32,65,224,0,65,201,3,65,29,16,0,0,11,32,0,65,15,106,65,112,113,34,0,65,16,32,0,65,16,75,27,11,169,1,1,1,127,32,0,32,1,65,128,2,73,4,127,32,1,65,4,118,33,1,65,0,5,32,1,65,248,255,255,255,1,73,4,64,32,1,65,1,65,27,32,1,103,107,116,106,65,1,107,33,1,11,32,1,65,31,32,1,103,107,34,2,65,4,107,118,65,16,115,33,1,32,2,65,7,107,11,34,2,65,2,116,106,40,2,4,65,127,32,1,116,113,34,1,4,127,32,0,32,1,104,32,2,65,4,116,106,65,2,116,106,40,2,96,5,32,0,40,2,0,65,127,32,2,65,1,106,116,113,34,1,4,127,32,0,32,0,32,1,104,34,0,65,2,116,106,40,2,4,104,32,0,65,4,116,106,65,2,116,106,40,2,96,5,65,0,11,11,11,111,1,1,127,63,0,34,2,32,1,65,248,255,255,255,1,73,4,127,32,1,65,1,65,27,32,1,103,107,116,65,1,107,106,5,32,1,11,65,16,32,0,40,2,160,12,32,2,65,16,116,65,16,107,71,116,106,65,255,255,3,106,65,128,128,124,113,65,16,118,34,1,32,2,32,1,74,27,64,0,65,0,72,4,64,32,1,64,0,65,0,72,4,64,0,11,11,32,0,32,2,65,16,116,63,0,65,16,116,16,3,11,113,1,2,127,32,1,40,2,0,34,3,65,124,113,32,2,107,34,4,65,32,79,4,64,32,1,32,2,32,3,65,2,113,114,54,2,0,32,2,32,1,65,16,106,106,34,1,32,4,65,16,107,65,1,114,54,2,0,32,0,32,1,16,2,5,32,1,32,3,65,126,113,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,32,1,65,16,106,32,1,40,2,0,65,124,113,106,40,2,0,65,125,113,54,2,0,11,11,91,1,2,127,32,0,32,1,16,5,34,4,16,6,34,3,69,4,64,65,1,36,1,65,0,36,1,32,0,32,4,16,6,34,3,69,4,64,32,0,32,4,16,7,32,0,32,4,16,6,33,3,11,11,32,3,65,0,54,2,4,32,3,32,2,54,2,8,32,3,32,1,54,2,12,32,0,32,3,16,1,32,0,32,3,32,4,16,8,32,3,11,13,0,16,4,32,0,32,1,16,9,65,16,106,11,33,1,1,127,32,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,18,0,32,0,65,172,3,75,4,64,32,0,65,16,107,16,52,11,11,140,3,1,1,127,2,64,32,1,69,13,0,32,0,65,0,58,0,0,32,0,32,1,106,65,1,107,65,0,58,0,0,32,1,65,2,77,13,0,32,0,65,1,106,65,0,58,0,0,32,0,65,2,106,65,0,58,0,0,32,0,32,1,106,34,2,65,2,107,65,0,58,0,0,32,2,65,3,107,65,0,58,0,0,32,1,65,6,77,13,0,32,0,65,3,106,65,0,58,0,0,32,0,32,1,106,65,4,107,65,0,58,0,0,32,1,65,8,77,13,0,32,1,65,0,32,0,107,65,3,113,34,1,107,33,2,32,0,32,1,106,34,0,65,0,54,2,0,32,0,32,2,65,124,113,34,1,106,65,4,107,65,0,54,2,0,32,1,65,8,77,13,0,32,0,65,4,106,65,0,54,2,0,32,0,65,8,106,65,0,54,2,0,32,0,32,1,106,34,2,65,12,107,65,0,54,2,0,32,2,65,8,107,65,0,54,2,0,32,1,65,24,77,13,0,32,0,65,12,106,65,0,54,2,0,32,0,65,16,106,65,0,54,2,0,32,0,65,20,106,65,0,54,2,0,32,0,65,24,106,65,0,54,2,0,32,0,32,1,106,34,2,65,28,107,65,0,54,2,0,32,2,65,24,107,65,0,54,2,0,32,2,65,20,107,65,0,54,2,0,32,2,65,16,107,65,0,54,2,0,32,0,32,0,65,4,113,65,24,106,34,2,106,33,0,32,1,32,2,107,33,1,3,64,32,1,65,32,79,4,64,32,0,66,0,55,3,0,32,0,65,8,106,66,0,55,3,0,32,0,65,16,106,66,0,55,3,0,32,0,65,24,106,66,0,55,3,0,32,1,65,32,107,33,1,32,0,65,32,106,33,0,12,1,11,11,11,11,178,1,1,3,127,32,1,65,240,255,255,255,3,32,2,118,75,4,64,65,144,1,65,192,1,65,23,65,56,16,0,0,11,32,1,32,2,116,34,3,65,0,16,10,34,2,32,3,16,13,32,0,69,4,64,65,12,65,2,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,2,34,1,32,0,40,2,0,34,4,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,32,4,16,12,11,32,0,32,1,54,2,0,32,0,32,2,54,2,4,32,0,32,3,54,2,8,32,0,11,46,1,2,127,65,12,65,5,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,65,128,2,65,3,16,14,11,9,0,65,63,32,0,121,167,107,11,49,1,2,127,65,63,32,1,121,167,107,33,2,3,64,65,63,32,0,121,167,107,32,2,107,34,3,65,0,78,4,64,32,0,32,1,32,3,172,134,133,33,0,12,1,11,11,32,0,11,40,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,163,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,65,0,58,0,0,11,38,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,152,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,45,0,0,11,254,5,2,1,127,4,126,32,0,69,4,64,65,232,0,65,6,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,24,32,0,66,0,55,3,32,32,0,66,0,55,3,40,32,0,66,0,55,3,48,32,0,66,0,55,3,56,32,0,66,0,55,3,64,32,0,66,0,55,3,72,32,0,66,0,55,3,80,32,0,66,0,55,3,88,32,0,66,0,55,3,96,32,0,32,2,173,55,3,80,32,0,32,3,173,55,3,88,65,12,65,4,16,10,34,2,65,172,3,75,4,64,32,2,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,32,4,65,0,16,14,33,2,32,0,40,2,0,16,12,32,0,32,2,54,2,0,32,0,32,4,54,2,4,32,0,66,1,32,1,173,134,66,1,125,55,3,96,32,0,66,243,130,183,218,216,230,232,30,55,3,72,35,4,69,4,64,65,0,33,2,3,64,32,2,65,128,2,72,4,64,32,2,65,255,1,113,173,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,65,0,33,4,3,64,32,4,32,0,40,2,4,65,1,107,72,4,64,32,6,66,8,134,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,32,4,65,1,106,33,4,12,1,11,11,35,6,40,2,4,32,2,65,3,116,106,32,6,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,63,32,0,41,3,72,121,167,107,172,33,7,65,0,33,2,3,64,32,2,65,128,2,72,4,64,35,5,33,1,32,2,172,32,7,134,34,8,33,6,65,63,32,0,41,3,72,34,9,121,167,107,33,3,3,64,65,63,32,6,121,167,107,32,3,107,34,4,65,0,78,4,64,32,6,32,9,32,4,172,134,133,33,6,12,1,11,11,32,1,40,2,4,32,2,65,3,116,106,32,6,32,8,132,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,1,36,4,11,32,0,66,0,55,3,24,32,0,66,0,55,3,32,65,0,33,2,3,64,32,2,32,0,40,2,4,72,4,64,32,0,40,2,0,32,2,16,18,32,2,65,1,106,33,2,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,6,66,45,136,167,65,3,116,106,41,3,0,32,6,66,8,134,66,1,132,133,55,3,40,32,0,11,38,1,1,127,32,0,40,2,0,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,55,1,2,127,32,1,32,0,40,2,0,34,2,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,16,12,11,32,0,32,1,54,2,0,11,7,0,32,0,40,2,4,11,9,0,32,0,32,1,54,2,4,11,7,0,32,0,40,2,8,11,9,0,32,0,32,1,54,2,8,11,7,0,32,0,41,3,16,11,9,0,32,0,32,1,55,3,16,11,7,0,32,0,41,3,24,11,9,0,32,0,32,1,55,3,24,11,7,0,32,0,41,3,32,11,9,0,32,0,32,1,55,3,32,11,7,0,32,0,41,3,40,11,9,0,32,0,32,1,55,3,40,11,7,0,32,0,41,3,48,11,9,0,32,0,32,1,55,3,48,11,7,0,32,0,41,3,56,11,9,0,32,0,32,1,55,3,56,11,7,0,32,0,41,3,64,11,9,0,32,0,32,1,55,3,64,11,7,0,32,0,41,3,72,11,9,0,32,0,32,1,55,3,72,11,7,0,32,0,41,3,80,11,9,0,32,0,32,1,55,3,80,11,7,0,32,0,41,3,88,11,9,0,32,0,32,1,55,3,88,11,7,0,32,0,41,3,96,11,9,0,32,0,32,1,55,3,96,11,172,4,2,5,127,1,126,32,2,65,172,3,75,4,64,32,2,65,16,107,34,4,32,4,40,2,4,65,1,106,54,2,4,11,32,2,33,4,65,0,33,2,32,1,40,2,8,33,5,32,1,40,2,4,33,6,3,64,2,127,65,0,33,3,3,64,32,3,32,5,72,4,64,32,3,32,6,106,45,0,0,33,1,32,0,40,2,0,32,0,40,2,8,16,19,33,7,32,0,40,2,8,32,0,40,2,0,40,2,4,106,32,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,7,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,1,173,32,8,66,8,134,132,133,55,3,40,32,0,32,0,41,3,16,66,1,124,55,3,16,32,0,32,0,41,3,24,66,1,124,55,3,24,32,0,41,3,16,32,0,41,3,80,90,4,127,32,0,41,3,40,32,0,41,3,96,131,80,5,65,0,11,4,127,65,1,5,32,0,41,3,16,32,0,41,3,88,90,11,4,64,32,0,32,0,41,3,32,55,3,48,32,0,32,0,41,3,16,55,3,56,32,0,32,0,41,3,40,55,3,64,65,0,33,1,3,64,32,1,32,0,40,2,4,72,4,64,32,0,40,2,0,32,1,16,18,32,1,65,1,106,33,1,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,8,66,8,134,66,1,132,133,55,3,40,32,3,65,1,106,12,3,11,32,3,65,1,106,33,3,12,1,11,11,65,127,11,34,1,65,0,78,4,64,32,5,32,1,107,33,5,32,1,32,6,106,33,6,32,2,34,1,65,1,106,33,2,32,4,40,2,4,32,1,65,2,116,106,32,0,41,3,56,62,2,0,12,1,11,11,32,4,11,10,0,16,15,36,5,16,15,36,6,11,3,0,1,11,73,1,2,127,32,0,40,2,4,34,1,65,255,255,255,255,0,113,34,2,65,1,70,4,64,32,0,65,16,106,16,53,32,0,32,0,40,2,0,65,1,114,54,2,0,35,0,32,0,16,2,5,32,0,32,2,65,1,107,32,1,65,128,128,128,128,127,113,114,54,2,4,11,11,58,0,2,64,2,64,2,64,32,0,65,8,107,40,2,0,14,7,0,0,1,1,1,1,1,2,11,15,11,32,0,40,2,0,34,0,4,64,32,0,65,172,3,79,4,64,32,0,65,16,107,16,52,11,11,15,11,0,11,11,137,3,7,0,65,16,11,55,40,0,0,0,1,0,0,0,1,0,0,0,40,0,0,0,97,0,108,0,108,0,111,0,99,0,97,0,116,0,105,0,111,0,110,0,32,0,116,0,111,0,111,0,32,0,108,0,97,0,114,0,103,0,101,0,65,208,0,11,45,30,0,0,0,1,0,0,0,1,0,0,0,30,0,0,0,126,0,108,0,105,0,98,0,47,0,114,0,116,0,47,0,116,0,108,0,115,0,102,0,46,0,116,0,115,0,65,128,1,11,43,28,0,0,0,1,0,0,0,1,0,0,0,28,0,0,0,73,0,110,0,118,0,97,0,108,0,105,0,100,0,32,0,108,0,101,0,110,0,103,0,116,0,104,0,65,176,1,11,53,38,0,0,0,1,0,0,0,1,0,0,0,38,0,0,0,126,0,108,0,105,0,98,0,47,0,97,0,114,0,114,0,97,0,121,0,98,0,117,0,102,0,102,0,101,0,114,0,46,0,116,0,115,0,65,240,1,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,73,0,110,0,100,0,101,0,120,0,32,0,111,0,117,0,116,0,32,0,111,0,102,0,32,0,114,0,97,0,110,0,103,0,101,0,65,176,2,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,126,0,108,0,105,0,98,0,47,0,116,0,121,0,112,0,101,0,100,0,97,0,114,0,114,0,97,0,121,0,46,0,116,0,115,0,65,240,2,11,53,7,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,145,4,0,0,2,0,0,0,49,0,0,0,2,0,0,0,17,1,0,0,2,0,0,0,16,0,34,16,115,111,117,114,99,101,77,97,112,112,105,110,103,85,82,76,16,46,47,114,97,98,105,110,46,119,97,115,109,46,109,97,112]);return s(new Response(new Blob([t],{type:"application/wasm"})),e)}n.supported="undefined"!==typeof WebAssembly,e.exports=n},63060:function(e,t,r){const s=r(57118),n=r(33286),i=async(e,t,r,i,o)=>{const a=await n();return new s(a,e,t,r,i,o)};e.exports={Rabin:s,create:i}},57118:function(e){class t{constructor(e,t=12,r=8192,s=32768,n=64,i){this.bits=t,this.min=r,this.max=s,this.asModule=e,this.rabin=new e.Rabin(t,r,s,n,i),this.polynomial=i}fingerprint(e){const{__retain:t,__release:r,__allocArray:s,__getInt32Array:n,Int32Array_ID:i,Uint8Array_ID:o}=this.asModule,a=new Int32Array(Math.ceil(e.length/this.min)),c=t(s(i,a)),l=t(s(o,e)),u=this.rabin.fingerprint(l,c),h=n(u);r(l),r(c);const d=h.indexOf(0);return d>=0?h.subarray(0,d):h}}e.exports=t},8558:function(e,t,r){const s=r(14636),n=r(81391),i=r(54156),o=r(4832),{RateLimiterClusterMaster:a,RateLimiterClusterMasterPM2:c,RateLimiterCluster:l}=r(91713),u=r(22288),h=r(45105),d=r(60911),p=r(33766),f=r(78686),y=r(73328),g=r(15155);e.exports={RateLimiterRedis:s,RateLimiterMongo:n,RateLimiterMySQL:i,RateLimiterPostgres:o,RateLimiterMemory:u,RateLimiterMemcache:h,RateLimiterClusterMaster:a,RateLimiterClusterMasterPM2:c,RateLimiterCluster:l,RLWrapperBlackAndWhite:d,RateLimiterUnion:p,RateLimiterQueue:f,BurstyRateLimiter:y,RateLimiterRes:g}},73328:function(e,t,r){const s=r(15155);e.exports=class{constructor(e,t){this._rateLimiter=e,this._burstLimiter=t}_combineRes(e,t){return new s(e.remainingPoints,Math.min(e.msBeforeNext,t.msBeforeNext),e.consumedPoints,e.isFirstInDuration)}consume(e,t=1,r={}){return this._rateLimiter.consume(e,t,r).catch((n=>n instanceof s?this._burstLimiter.consume(e,t,r).then((e=>Promise.resolve(this._combineRes(n,e)))).catch((e=>e instanceof s?Promise.reject(this._combineRes(n,e)):Promise.reject(e))):Promise.reject(n)))}get(e){return Promise.all([this._rateLimiter.get(e),this._burstLimiter.get(e)]).then((([e,t])=>this._combineRes(e,t)))}get points(){return this._rateLimiter.points}}},60911:function(e,t,r){const s=r(15155);e.exports=class{constructor(e={}){this.limiter=e.limiter,this.blackList=e.blackList,this.whiteList=e.whiteList,this.isBlackListed=e.isBlackListed,this.isWhiteListed=e.isWhiteListed,this.runActionAnyway=e.runActionAnyway}get limiter(){return this._limiter}set limiter(e){if("undefined"===typeof e)throw new Error("limiter is not set");this._limiter=e}get runActionAnyway(){return this._runActionAnyway}set runActionAnyway(e){this._runActionAnyway="undefined"!==typeof e&&e}get blackList(){return this._blackList}set blackList(e){this._blackList=Array.isArray(e)?e:[]}get isBlackListed(){return this._isBlackListed}set isBlackListed(e){if("undefined"===typeof e&&(e=()=>!1),"function"!==typeof e)throw new Error("isBlackListed must be function");this._isBlackListed=e}get whiteList(){return this._whiteList}set whiteList(e){this._whiteList=Array.isArray(e)?e:[]}get isWhiteListed(){return this._isWhiteListed}set isWhiteListed(e){if("undefined"===typeof e&&(e=()=>!1),"function"!==typeof e)throw new Error("isWhiteListed must be function");this._isWhiteListed=e}isBlackListedSomewhere(e){return this.blackList.indexOf(e)>=0||this.isBlackListed(e)}isWhiteListedSomewhere(e){return this.whiteList.indexOf(e)>=0||this.isWhiteListed(e)}getBlackRes(){return new s(0,Number.MAX_SAFE_INTEGER,0,!1)}getWhiteRes(){return new s(Number.MAX_SAFE_INTEGER,0,0,!1)}rejectBlack(){return Promise.reject(this.getBlackRes())}resolveBlack(){return Promise.resolve(this.getBlackRes())}resolveWhite(){return Promise.resolve(this.getWhiteRes())}consume(e,t=1){let r;return this.isWhiteListedSomewhere(e)?r=this.resolveWhite():this.isBlackListedSomewhere(e)&&(r=this.rejectBlack()),"undefined"===typeof r?this.limiter.consume(e,t):(this.runActionAnyway&&this.limiter.consume(e,t).catch((()=>{})),r)}block(e,t){let r;return this.isWhiteListedSomewhere(e)?r=this.resolveWhite():this.isBlackListedSomewhere(e)&&(r=this.resolveBlack()),"undefined"===typeof r?this.limiter.block(e,t):(this.runActionAnyway&&this.limiter.block(e,t).catch((()=>{})),r)}penalty(e,t){let r;return this.isWhiteListedSomewhere(e)?r=this.resolveWhite():this.isBlackListedSomewhere(e)&&(r=this.resolveBlack()),"undefined"===typeof r?this.limiter.penalty(e,t):(this.runActionAnyway&&this.limiter.penalty(e,t).catch((()=>{})),r)}reward(e,t){let r;return this.isWhiteListedSomewhere(e)?r=this.resolveWhite():this.isBlackListedSomewhere(e)&&(r=this.resolveBlack()),"undefined"===typeof r?this.limiter.reward(e,t):(this.runActionAnyway&&this.limiter.reward(e,t).catch((()=>{})),r)}get(e){let t;return this.isWhiteListedSomewhere(e)?t=this.resolveWhite():this.isBlackListedSomewhere(e)&&(t=this.resolveBlack()),"undefined"===typeof t||this.runActionAnyway?this.limiter.get(e):t}delete(e){return this.limiter.delete(e)}}},81352:function(e){e.exports=class{constructor(e={}){this.points=e.points,this.duration=e.duration,this.blockDuration=e.blockDuration,this.execEvenly=e.execEvenly,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs,this.keyPrefix=e.keyPrefix}get points(){return this._points}set points(e){this._points=e>=0?e:4}get duration(){return this._duration}set duration(e){this._duration="undefined"===typeof e?1:e}get msDuration(){return 1e3*this.duration}get blockDuration(){return this._blockDuration}set blockDuration(e){this._blockDuration="undefined"===typeof e?0:e}get msBlockDuration(){return 1e3*this.blockDuration}get execEvenly(){return this._execEvenly}set execEvenly(e){this._execEvenly="undefined"!==typeof e&&Boolean(e)}get execEvenlyMinDelayMs(){return this._execEvenlyMinDelayMs}set execEvenlyMinDelayMs(e){this._execEvenlyMinDelayMs="undefined"===typeof e?Math.ceil(this.msDuration/this.points):e}get keyPrefix(){return this._keyPrefix}set keyPrefix(e){if("undefined"===typeof e&&(e="rlflx"),"string"!==typeof e)throw new Error("keyPrefix must be string");this._keyPrefix=e}_getKeySecDuration(e={}){return e&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}consume(){throw new Error("You have to implement the method 'consume'!")}penalty(){throw new Error("You have to implement the method 'penalty'!")}reward(){throw new Error("You have to implement the method 'reward'!")}get(){throw new Error("You have to implement the method 'get'!")}set(){throw new Error("You have to implement the method 'set'!")}block(){throw new Error("You have to implement the method 'block'!")}delete(){throw new Error("You have to implement the method 'delete'!")}}},91713:function(e,t,r){var s=r(34155),n=r(25108);const i=r(81265),o=r(35539),a=r(81352),c=r(22288),l=r(15155),u="rate_limiter_flexible";let h=null;const d=function(e,t,r,s){let n;n=null===s||!0===s||!1===s?s:{remainingPoints:s.remainingPoints,msBeforeNext:s.msBeforeNext,consumedPoints:s.consumedPoints,isFirstInDuration:s.isFirstInDuration},e.send({channel:u,keyPrefix:t.keyPrefix,promiseId:t.promiseId,type:r,data:n})},p=function(e){setTimeout((()=>{this._initiated?s.send(e):"undefined"!==typeof this._promises[e.promiseId]&&p.call(this,e)}),30)},f=function(e,t,r,n,i){const o={channel:u,keyPrefix:this.keyPrefix,func:e,promiseId:t,data:{key:r,arg:n,opts:i}};this._initiated?s.send(o):p.call(this,o)},y=function(e,t){if(!t||t.channel!==u||"undefined"===typeof this._rateLimiters[t.keyPrefix])return!1;let r;switch(t.func){case"consume":r=this._rateLimiters[t.keyPrefix].consume(t.data.key,t.data.arg,t.data.opts);break;case"penalty":r=this._rateLimiters[t.keyPrefix].penalty(t.data.key,t.data.arg,t.data.opts);break;case"reward":r=this._rateLimiters[t.keyPrefix].reward(t.data.key,t.data.arg,t.data.opts);break;case"block":r=this._rateLimiters[t.keyPrefix].block(t.data.key,t.data.arg,t.data.opts);break;case"get":r=this._rateLimiters[t.keyPrefix].get(t.data.key,t.data.opts);break;case"delete":r=this._rateLimiters[t.keyPrefix].delete(t.data.key,t.data.opts);break;default:return!1}r&&r.then((r=>{d(e,t,"resolve",r)})).catch((r=>{d(e,t,"reject",r)}))},g=function(e){if(!e||e.channel!==u||e.keyPrefix!==this.keyPrefix)return!1;if(this._promises[e.promiseId]){let t;switch(clearTimeout(this._promises[e.promiseId].timeoutId),t=null===e.data||!0===e.data||!1===e.data?e.data:new l(e.data.remainingPoints,e.data.msBeforeNext,e.data.consumedPoints,e.data.isFirstInDuration),e.type){case"resolve":this._promises[e.promiseId].resolve(t);break;case"reject":this._promises[e.promiseId].reject(t);break;default:throw new Error(`RateLimiterCluster: no such message type '${e.type}'`)}delete this._promises[e.promiseId]}},m=function(){return{points:this.points,duration:this.duration,blockDuration:this.blockDuration,execEvenly:this.execEvenly,execEvenlyMinDelayMs:this.execEvenlyMinDelayMs,keyPrefix:this.keyPrefix}},w=function(e,t){const r=s.hrtime();let n=r[0].toString()+r[1].toString();return"undefined"!==typeof this._promises[n]&&(n+=o.randomBytes(12).toString("base64")),this._promises[n]={resolve:e,reject:t,timeoutId:setTimeout((()=>{delete this._promises[n],t(new Error("RateLimiterCluster timeout: no answer from master in time"))}),this.timeoutMs)},n};class b{constructor(){if(h)return h;this._rateLimiters={},i.setMaxListeners(0),i.on("message",((e,t)=>{t&&t.channel===u&&"init"===t.type?("undefined"===typeof this._rateLimiters[t.opts.keyPrefix]&&(this._rateLimiters[t.opts.keyPrefix]=new c(t.opts)),e.send({channel:u,type:"init",keyPrefix:t.opts.keyPrefix})):y.call(this,e,t)})),h=this}}class _{constructor(e){if(h)return h;this._rateLimiters={},e.launchBus(((t,r)=>{r.on("process:msg",(t=>{const r=t.raw;if(r&&r.channel===u&&"init"===r.type)"undefined"===typeof this._rateLimiters[r.opts.keyPrefix]&&(this._rateLimiters[r.opts.keyPrefix]=new c(r.opts)),e.sendDataToProcessId(t.process.pm_id,{data:{},topic:u,channel:u,type:"init",keyPrefix:r.opts.keyPrefix},((e,t)=>{e&&n.log(e,t)}));else{const s={send:r=>{const s=r;s.topic=u,"undefined"===typeof s.data&&(s.data={}),e.sendDataToProcessId(t.process.pm_id,s,((e,t)=>{e&&n.log(e,t)}))}};y.call(this,s,r)}}))})),h=this}}class E extends a{get timeoutMs(){return this._timeoutMs}set timeoutMs(e){this._timeoutMs="undefined"===typeof e?5e3:Math.abs(parseInt(e))}constructor(e={}){super(e),s.setMaxListeners(0),this.timeoutMs=e.timeoutMs,this._initiated=!1,s.on("message",(e=>{e&&e.channel===u&&"init"===e.type&&e.keyPrefix===this.keyPrefix?this._initiated=!0:g.call(this,e)})),s.send({channel:u,type:"init",opts:m.call(this)}),this._promises={}}consume(e,t=1,r={}){return new Promise(((s,n)=>{const i=w.call(this,s,n);f.call(this,"consume",i,e,t,r)}))}penalty(e,t=1,r={}){return new Promise(((s,n)=>{const i=w.call(this,s,n);f.call(this,"penalty",i,e,t,r)}))}reward(e,t=1,r={}){return new Promise(((s,n)=>{const i=w.call(this,s,n);f.call(this,"reward",i,e,t,r)}))}block(e,t,r={}){return new Promise(((s,n)=>{const i=w.call(this,s,n);f.call(this,"block",i,e,t,r)}))}get(e,t={}){return new Promise(((r,s)=>{const n=w.call(this,r,s);f.call(this,"get",n,e,t)}))}delete(e,t={}){return new Promise(((r,s)=>{const n=w.call(this,r,s);f.call(this,"delete",n,e,t)}))}}e.exports={RateLimiterClusterMaster:b,RateLimiterClusterMasterPM2:_,RateLimiterCluster:E}},45105:function(e,t,r){const s=r(91090),n=r(15155);class i extends s{constructor(e){super(e),this.client=e.storeClient}_getRateLimiterRes(e,t,r){const s=new n;return s.consumedPoints=parseInt(r.consumedPoints),s.isFirstInDuration=r.consumedPoints===t,s.remainingPoints=Math.max(this.points-s.consumedPoints,0),s.msBeforeNext=r.msBeforeNext,s}_upsert(e,t,r,s=!1,n={}){return new Promise(((i,o)=>{const a=Date.now(),c=Math.floor(r/1e3);s?this.client.set(e,t,c,(r=>{r?o(r):this.client.set(`${e}_expire`,c>0?a+1e3*c:-1,c,(()=>{const e={consumedPoints:t,msBeforeNext:c>0?1e3*c:-1};i(e)}))})):this.client.incr(e,t,((l,u)=>{l||!1===u?this.client.add(e,t,c,((l,u)=>{if(l||!u)if("undefined"===typeof n.attemptNumber||n.attemptNumber<3){const a=Object.assign({},n);a.attemptNumber=a.attemptNumber?a.attemptNumber+1:1,this._upsert(e,t,r,s,a).then((e=>i(e))).catch((e=>o(e)))}else o(new Error("Can not add key"));else this.client.add(`${e}_expire`,c>0?a+1e3*c:-1,c,(()=>{const e={consumedPoints:t,msBeforeNext:c>0?1e3*c:-1};i(e)}))})):this.client.get(`${e}_expire`,((e,t)=>{if(e)o(e);else{const e=!1===t?0:t,r={consumedPoints:u,msBeforeNext:e>=0?Math.max(e-a,0):-1};i(r)}}))}))}))}_get(e){return new Promise(((t,r)=>{const s=Date.now();this.client.get(e,((n,i)=>{i?this.client.get(`${e}_expire`,((e,n)=>{if(e)r(e);else{const e=!1===n?0:n,r={consumedPoints:i,msBeforeNext:e>=0?Math.max(e-s,0):-1};t(r)}})):t(null)}))}))}_delete(e){return new Promise(((t,r)=>{this.client.del(e,((s,n)=>{s?r(s):!1===n?t(n):this.client.del(`${e}_expire`,(e=>{e?r(e):t(n)}))}))}))}}e.exports=i},22288:function(e,t,r){const s=r(81352),n=r(58425),i=r(15155);class o extends s{constructor(e={}){super(e),this._memoryStorage=new n}consume(e,t=1,r={}){return new Promise(((s,n)=>{const i=this.getKey(e),o=this._getKeySecDuration(r);let a=this._memoryStorage.incrby(i,t,o);if(a.remainingPoints=Math.max(this.points-a.consumedPoints,0),a.consumedPoints>this.points)this.blockDuration>0&&a.consumedPoints<=this.points+t&&(a=this._memoryStorage.set(i,a.consumedPoints,this.blockDuration)),n(a);else if(this.execEvenly&&a.msBeforeNext>0&&!a.isFirstInDuration){let e=Math.ceil(a.msBeforeNext/(a.remainingPoints+2));e<this.execEvenlyMinDelayMs&&(e=a.consumedPoints*this.execEvenlyMinDelayMs),setTimeout(s,e,a)}else s(a)}))}penalty(e,t=1,r={}){const s=this.getKey(e);return new Promise((e=>{const n=this._getKeySecDuration(r),i=this._memoryStorage.incrby(s,t,n);i.remainingPoints=Math.max(this.points-i.consumedPoints,0),e(i)}))}reward(e,t=1,r={}){const s=this.getKey(e);return new Promise((e=>{const n=this._getKeySecDuration(r),i=this._memoryStorage.incrby(s,-t,n);i.remainingPoints=Math.max(this.points-i.consumedPoints,0),e(i)}))}block(e,t){const r=1e3*t,s=this.points+1;return this._memoryStorage.set(this.getKey(e),s,t),Promise.resolve(new i(0,0===r?-1:r,s))}set(e,t,r){const s=1e3*(r>=0?r:this.duration);return this._memoryStorage.set(this.getKey(e),t,r),Promise.resolve(new i(0,0===s?-1:s,t))}get(e){const t=this._memoryStorage.get(this.getKey(e));return null!==t&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),Promise.resolve(t)}delete(e){return Promise.resolve(this._memoryStorage.delete(this.getKey(e)))}}e.exports=o},81391:function(e,t,r){const s=r(91090),n=r(15155);function i(e){try{const t=e.client?e.client:e,{version:r}=t.topology.s.options.metadata.driver,s=r.split(".").map((e=>parseInt(e)));return{major:s[0],feature:s[1],patch:s[2]}}catch(t){return{major:0,feature:0,patch:0}}}class o extends s{constructor(e){super(e),this.dbName=e.dbName,this.tableName=e.tableName,this.indexKeyPrefix=e.indexKeyPrefix,e.mongo?this.client=e.mongo:this.client=e.storeClient,"function"===typeof this.client.then?this.client.then((e=>{this.client=e,this._initCollection(),this._driverVersion=i(this.client)})):(this._initCollection(),this._driverVersion=i(this.client))}get dbName(){return this._dbName}set dbName(e){this._dbName="undefined"===typeof e?o.getDbName():e}static getDbName(){return"node-rate-limiter-flexible"}get tableName(){return this._tableName}set tableName(e){this._tableName="undefined"===typeof e?this.keyPrefix:e}get client(){return this._client}set client(e){if("undefined"===typeof e)throw new Error("mongo is not set");this._client=e}get indexKeyPrefix(){return this._indexKeyPrefix}set indexKeyPrefix(e){this._indexKeyPrefix=e||{}}_initCollection(){const e="function"===typeof this.client.db?this.client.db(this.dbName):this.client,t=e.collection(this.tableName);t.createIndex({expire:-1},{expireAfterSeconds:0}),t.createIndex(Object.assign({},this.indexKeyPrefix,{key:1}),{unique:!0}),this._collection=t}_getRateLimiterRes(e,t,r){const s=new n;let i;return i="undefined"===typeof r.value?r:r.value,s.isFirstInDuration=i.points===t,s.consumedPoints=i.points,s.remainingPoints=Math.max(this.points-s.consumedPoints,0),s.msBeforeNext=null!==i.expire?Math.max(new Date(i.expire).getTime()-Date.now(),0):-1,s}_upsert(e,t,r,s=!1,n={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const i=n.attrs||{};let o,a;s?(o={key:e},o=Object.assign(o,i),a={$set:{key:e,points:t,expire:r>0?new Date(Date.now()+r):null}},a.$set=Object.assign(a.$set,i)):(o={$or:[{expire:{$gt:new Date}},{expire:{$eq:null}}],key:e},o=Object.assign(o,i),a={$setOnInsert:{key:e,expire:r>0?new Date(Date.now()+r):null},$inc:{points:t}},a.$setOnInsert=Object.assign(a.$setOnInsert,i));const c={upsert:!0};return this._driverVersion.major>=4||3===this._driverVersion.major&&this._driverVersion.feature>=7||this._driverVersion.feature>=6&&this._driverVersion.patch>=7?c.returnDocument="after":c.returnOriginal=!1,new Promise(((n,l)=>{this._collection.findOneAndUpdate(o,a,c).then((e=>{n(e)})).catch((o=>{if(o&&11e3===o.code){const o=Object.assign({$or:[{expire:{$lte:new Date}},{expire:{$eq:null}}],key:e},i),a={$set:Object.assign({key:e,points:t,expire:r>0?new Date(Date.now()+r):null},i)};this._collection.findOneAndUpdate(o,a,c).then((e=>{n(e)})).catch((i=>{i&&11e3===i.code?this._upsert(e,t,r,s).then((e=>n(e))).catch((e=>l(e))):l(i)}))}else l(o)}))}))}_get(e,t={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const r=t.attrs||{},s=Object.assign({key:e,$or:[{expire:{$gt:new Date}},{expire:{$eq:null}}]},r);return this._collection.findOne(s)}_delete(e,t={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const r=t.attrs||{},s=Object.assign({key:e},r);return this._collection.deleteOne(s).then((e=>e.deletedCount>0))}}e.exports=o},54156:function(e,t,r){const s=r(91090),n=r(15155);class i extends s{constructor(e,t=null){super(e),this.client=e.storeClient,this.clientType=e.storeType,this.dbName=e.dbName,this.tableName=e.tableName,this.clearExpiredByTimeout=e.clearExpiredByTimeout,this.tableCreated=e.tableCreated,this.tableCreated?(this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),"function"===typeof t&&t()):this._createDbAndTable().then((()=>{this.tableCreated=!0,this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),"function"===typeof t&&t()})).catch((e=>{if("function"!==typeof t)throw e;t(e)}))}clearExpired(e){return new Promise((t=>{this._getConnection().then((r=>{r.query("DELETE FROM ??.?? WHERE expire < ?",[this.dbName,this.tableName,e],(()=>{this._releaseConnection(r),t()}))})).catch((()=>{t()}))}))}_clearExpiredHourAgo(){this._clearExpiredTimeoutId&&clearTimeout(this._clearExpiredTimeoutId),this._clearExpiredTimeoutId=setTimeout((()=>{this.clearExpired(Date.now()-36e5).then((()=>{this._clearExpiredHourAgo()}))}),3e5),this._clearExpiredTimeoutId.unref()}_getConnection(){switch(this.clientType){case"pool":return new Promise(((e,t)=>{this.client.getConnection(((r,s)=>{if(r)return t(r);e(s)}))}));case"sequelize":return this.client.connectionManager.getConnection();case"knex":return this.client.client.acquireConnection();default:return Promise.resolve(this.client)}}_releaseConnection(e){switch(this.clientType){case"pool":return e.release();case"sequelize":return this.client.connectionManager.releaseConnection(e);case"knex":return this.client.client.releaseConnection(e);default:return!0}}_createDbAndTable(){return new Promise(((e,t)=>{this._getConnection().then((r=>{r.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`,(s=>{if(s)return this._releaseConnection(r),t(s);r.query(this._getCreateTableStmt(),(s=>{if(s)return this._releaseConnection(r),t(s);this._releaseConnection(r),e()}))}))})).catch((e=>{t(e)}))}))}_getCreateTableStmt(){return`CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`}get clientType(){return this._clientType}set clientType(e){if("undefined"===typeof e)if("Connection"===this.client.constructor.name)e="connection";else if("Pool"===this.client.constructor.name)e="pool";else{if("Sequelize"!==this.client.constructor.name)throw new Error("storeType is not defined");e="sequelize"}this._clientType=e.toLowerCase()}get dbName(){return this._dbName}set dbName(e){this._dbName="undefined"===typeof e?"rtlmtrflx":e}get tableName(){return this._tableName}set tableName(e){this._tableName="undefined"===typeof e?this.keyPrefix:e}get tableCreated(){return this._tableCreated}set tableCreated(e){this._tableCreated="undefined"!==typeof e&&!!e}get clearExpiredByTimeout(){return this._clearExpiredByTimeout}set clearExpiredByTimeout(e){this._clearExpiredByTimeout="undefined"===typeof e||Boolean(e)}_getRateLimiterRes(e,t,r){const s=new n,[i]=r;return s.isFirstInDuration=t===i.points,s.consumedPoints=s.isFirstInDuration?t:i.points,s.remainingPoints=Math.max(this.points-s.consumedPoints,0),s.msBeforeNext=i.expire?Math.max(i.expire-Date.now(),0):-1,s}_upsertTransaction(e,t,r,s,n){return new Promise(((i,o)=>{e.query("BEGIN",(a=>{if(a)return e.rollback(),o(a);const c=Date.now(),l=s>0?c+s:null;let u,h;n?(u="INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = ?, \n            expire = ?;",h=[this.dbName,this.tableName,t,r,l,r,l]):(u="INSERT INTO ??.?? VALUES (?, ?, ?)\n          ON DUPLICATE KEY UPDATE \n            points = IF(expire <= ?, ?, points + (?)), \n            expire = IF(expire <= ?, ?, expire);",h=[this.dbName,this.tableName,t,r,l,c,r,r,c,l]),e.query(u,h,(r=>{if(r)return e.rollback(),o(r);e.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;",[this.dbName,this.tableName,t],((t,r)=>{if(t)return e.rollback(),o(t);e.query("COMMIT",(t=>{if(t)return e.rollback(),o(t);i(r)}))}))}))}))}))}_upsert(e,t,r,s=!1){return this.tableCreated?new Promise(((n,i)=>{this._getConnection().then((o=>{this._upsertTransaction(o,e,t,r,s).then((e=>{n(e),this._releaseConnection(o)})).catch((e=>{i(e),this._releaseConnection(o)}))})).catch((e=>{i(e)}))})):Promise.reject(Error("Table is not created yet"))}_get(e){return this.tableCreated?new Promise(((t,r)=>{this._getConnection().then((s=>{s.query("SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",[this.dbName,this.tableName,e,Date.now()],((e,n)=>{e?r(e):0===n.length?t(null):t(n),this._releaseConnection(s)}))})).catch((e=>{r(e)}))})):Promise.reject(Error("Table is not created yet"))}_delete(e){return this.tableCreated?new Promise(((t,r)=>{this._getConnection().then((s=>{s.query("DELETE FROM ??.?? WHERE `key` = ?",[this.dbName,this.tableName,e],((e,n)=>{e?r(e):t(n.affectedRows>0),this._releaseConnection(s)}))})).catch((e=>{r(e)}))})):Promise.reject(Error("Table is not created yet"))}}e.exports=i},4832:function(e,t,r){const s=r(91090),n=r(15155);class i extends s{constructor(e,t=null){super(e),this.client=e.storeClient,this.clientType=e.storeType,this.tableName=e.tableName,this.clearExpiredByTimeout=e.clearExpiredByTimeout,this.tableCreated=e.tableCreated,this.tableCreated?"function"===typeof t&&t():this._createTable().then((()=>{this.tableCreated=!0,this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),"function"===typeof t&&t()})).catch((e=>{if("function"!==typeof t)throw e;t(e)}))}clearExpired(e){return new Promise((t=>{const r={name:"rlflx-clear-expired",text:`DELETE FROM ${this.tableName} WHERE expire < $1`,values:[e]};this._query(r).then((()=>{t()})).catch((()=>{t()}))}))}_clearExpiredHourAgo(){this._clearExpiredTimeoutId&&clearTimeout(this._clearExpiredTimeoutId),this._clearExpiredTimeoutId=setTimeout((()=>{this.clearExpired(Date.now()-36e5).then((()=>{this._clearExpiredHourAgo()}))}),3e5),this._clearExpiredTimeoutId.unref()}_getConnection(){switch(this.clientType){case"pool":return Promise.resolve(this.client);case"sequelize":return this.client.connectionManager.getConnection();case"knex":return this.client.client.acquireConnection();case"typeorm":return Promise.resolve(this.client.driver.master);default:return Promise.resolve(this.client)}}_releaseConnection(e){switch(this.clientType){case"pool":return!0;case"sequelize":return this.client.connectionManager.releaseConnection(e);case"knex":return this.client.client.releaseConnection(e);case"typeorm":return!0;default:return!0}}_createTable(){return new Promise(((e,t)=>{this._query({text:this._getCreateTableStmt()}).then((()=>{e()})).catch((r=>{"23505"===r.code?e():t(r)}))}))}_getCreateTableStmt(){return`CREATE TABLE IF NOT EXISTS ${this.tableName} ( \n      key varchar(255) PRIMARY KEY,\n      points integer NOT NULL DEFAULT 0,\n      expire bigint\n    );`}get clientType(){return this._clientType}set clientType(e){const t=this.client.constructor.name;if("undefined"===typeof e)if("Client"===t)e="client";else if("Pool"===t||"BoundPool"===t)e="pool";else{if("Sequelize"!==t)throw new Error("storeType is not defined");e="sequelize"}this._clientType=e.toLowerCase()}get tableName(){return this._tableName}set tableName(e){this._tableName="undefined"===typeof e?this.keyPrefix:e}get tableCreated(){return this._tableCreated}set tableCreated(e){this._tableCreated="undefined"!==typeof e&&!!e}get clearExpiredByTimeout(){return this._clearExpiredByTimeout}set clearExpiredByTimeout(e){this._clearExpiredByTimeout="undefined"===typeof e||Boolean(e)}_getRateLimiterRes(e,t,r){const s=new n,i=r.rows[0];return s.isFirstInDuration=t===i.points,s.consumedPoints=s.isFirstInDuration?t:i.points,s.remainingPoints=Math.max(this.points-s.consumedPoints,0),s.msBeforeNext=i.expire?Math.max(i.expire-Date.now(),0):-1,s}_query(e){const t=this.tableName.toLowerCase(),r={name:`${t}:${e.name}`,text:e.text,values:e.values};return new Promise(((e,t)=>{this._getConnection().then((s=>{s.query(r).then((t=>{e(t),this._releaseConnection(s)})).catch((e=>{t(e),this._releaseConnection(s)}))})).catch((e=>{t(e)}))}))}_upsert(e,t,r,s=!1){if(!this.tableCreated)return Promise.reject(Error("Table is not created yet"));const n=r>0?Date.now()+r:null,i=s?" $3 ":` CASE\n             WHEN ${this.tableName}.expire <= $4 THEN $3\n             ELSE ${this.tableName}.expire\n            END `;return this._query({name:s?"rlflx-upsert-force":"rlflx-upsert",text:`\n            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)\n              ON CONFLICT(key) DO UPDATE SET\n                points = CASE\n                          WHEN (${this.tableName}.expire <= $4 OR 1=${s?1:0}) THEN $2\n                          ELSE ${this.tableName}.points + ($2)\n                         END,\n                expire = ${i}\n            RETURNING points, expire;`,values:[e,t,n,Date.now()]})}_get(e){return this.tableCreated?new Promise(((t,r)=>{this._query({name:"rlflx-get",text:`\n            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,values:[e,Date.now()]}).then((e=>{0===e.rowCount&&(e=null),t(e)})).catch((e=>{r(e)}))})):Promise.reject(Error("Table is not created yet"))}_delete(e){return this.tableCreated?this._query({name:"rlflx-delete",text:`DELETE FROM ${this.tableName} WHERE key = $1`,values:[e]}).then((e=>e.rowCount>0)):Promise.reject(Error("Table is not created yet"))}}e.exports=i},78686:function(e,t,r){const s=r(45255),n=4294967295,i="limiter";e.exports=class{constructor(e,t={maxQueueSize:n}){this._queueLimiters={KEY_DEFAULT:new o(e,t)},this._limiterFlexible=e,this._maxQueueSize=t.maxQueueSize}getTokensRemaining(e=i){return this._queueLimiters[e]?this._queueLimiters[e].getTokensRemaining():Promise.resolve(this._limiterFlexible.points)}removeTokens(e,t=i){return this._queueLimiters[t]||(this._queueLimiters[t]=new o(this._limiterFlexible,{key:t,maxQueueSize:this._maxQueueSize})),this._queueLimiters[t].removeTokens(e)}};class o{constructor(e,t={maxQueueSize:n,key:i}){this._key=t.key,this._waitTimeout=null,this._queue=[],this._limiterFlexible=e,this._maxQueueSize=t.maxQueueSize}getTokensRemaining(){return this._limiterFlexible.get(this._key).then((e=>null!==e?e.remainingPoints:this._limiterFlexible.points))}removeTokens(e){const t=this;return new Promise(((r,n)=>{e>t._limiterFlexible.points?n(new s(`Requested tokens ${e} exceeds maximum ${t._limiterFlexible.points} tokens per interval`)):t._queue.length>0?t._queueRequest.call(t,r,n,e):t._limiterFlexible.consume(t._key,e).then((e=>{r(e.remainingPoints)})).catch((s=>{s instanceof Error?n(s):(t._queueRequest.call(t,r,n,e),null===t._waitTimeout&&(t._waitTimeout=setTimeout(t._processFIFO.bind(t),s.msBeforeNext)))}))}))}_queueRequest(e,t,r){const n=this;n._queue.length<n._maxQueueSize?n._queue.push({resolve:e,reject:t,tokens:r}):t(new s(`Number of requests reached it's maximum ${n._maxQueueSize}`))}_processFIFO(){const e=this;if(null!==e._waitTimeout&&(clearTimeout(e._waitTimeout),e._waitTimeout=null),0===e._queue.length)return;const t=e._queue.shift();e._limiterFlexible.consume(e._key,t.tokens).then((r=>{t.resolve(r.remainingPoints),e._processFIFO.call(e)})).catch((r=>{r instanceof Error?(t.reject(r),e._processFIFO.call(e)):(e._queue.unshift(t),null===e._waitTimeout&&(e._waitTimeout=setTimeout(e._processFIFO.bind(e),r.msBeforeNext)))}))}}},14636:function(e,t,r){const s=r(91090),n=r(15155),i="redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} ";class o extends s{constructor(e){super(e),e.redis?this.client=e.redis:this.client=e.storeClient,"function"===typeof this.client.defineCommand&&this.client.defineCommand("rlflxIncr",{numberOfKeys:1,lua:i})}_getRateLimiterRes(e,t,r){let[s,i]=r;Array.isArray(s)&&([,s]=s,[,i]=i);const o=new n;return o.consumedPoints=parseInt(s),o.isFirstInDuration=o.consumedPoints===t,o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.msBeforeNext=i,o}_upsert(e,t,r,s=!1){return new Promise(((n,o)=>{const a=Math.floor(r/1e3),c=this.client.multi();if(s)a>0?c.set(e,t,"EX",a):c.set(e,t),c.pttl(e).exec(((e,t)=>e?o(e):n(t)));else if(a>0){const r=function(e,t){return e?o(e):n(t)};"function"===typeof this.client.rlflxIncr?this.client.rlflxIncr(e,t,a,r):this.client.eval(i,1,e,t,a,r)}else c.incrby(e,t).pttl(e).exec(((e,t)=>e?o(e):n(t)))}))}_get(e){return new Promise(((t,r)=>{this.client.multi().get(e).pttl(e).exec(((e,s)=>{if(e)r(e);else{const[e]=s;if(null===e)return t(null);t(s)}}))}))}_delete(e){return new Promise(((t,r)=>{this.client.del(e,((e,s)=>{e?r(e):t(s>0)}))}))}}e.exports=o},15155:function(e){e.exports=class{constructor(e,t,r,s){this.remainingPoints="undefined"===typeof e?0:e,this.msBeforeNext="undefined"===typeof t?0:t,this.consumedPoints="undefined"===typeof r?0:r,this.isFirstInDuration="undefined"!==typeof s&&s}get msBeforeNext(){return this._msBeforeNext}set msBeforeNext(e){return this._msBeforeNext=e,this}get remainingPoints(){return this._remainingPoints}set remainingPoints(e){return this._remainingPoints=e,this}get consumedPoints(){return this._consumedPoints}set consumedPoints(e){return this._consumedPoints=e,this}get isFirstInDuration(){return this._isFirstInDuration}set isFirstInDuration(e){this._isFirstInDuration=Boolean(e)}_getDecoratedProperties(){return{remainingPoints:this.remainingPoints,msBeforeNext:this.msBeforeNext,consumedPoints:this.consumedPoints,isFirstInDuration:this.isFirstInDuration}}[Symbol.for("nodejs.util.inspect.custom")](){return this._getDecoratedProperties()}toString(){return JSON.stringify(this._getDecoratedProperties())}toJSON(){return this._getDecoratedProperties()}}},91090:function(e,t,r){const s=r(81352),n=r(52423),i=r(15155);e.exports=class extends s{constructor(e={}){super(e),this.inMemoryBlockOnConsumed=e.inMemoryBlockOnConsumed||e.inmemoryBlockOnConsumed,this.inMemoryBlockDuration=e.inMemoryBlockDuration||e.inmemoryBlockDuration,this.insuranceLimiter=e.insuranceLimiter,this._inMemoryBlockedKeys=new n}get client(){return this._client}set client(e){if("undefined"===typeof e)throw new Error("storeClient is not set");this._client=e}_afterConsume(e,t,r,s,n,i={}){const o=this._getRateLimiterRes(r,s,n);if(this.inMemoryBlockOnConsumed>0&&!(this.inMemoryBlockDuration>0)&&o.consumedPoints>=this.inMemoryBlockOnConsumed)return this._inMemoryBlockedKeys.addMs(r,o.msBeforeNext),o.consumedPoints>this.points?t(o):e(o);if(o.consumedPoints>this.points){let e=Promise.resolve();this.blockDuration>0&&o.consumedPoints<=this.points+s&&(o.msBeforeNext=this.msBlockDuration,e=this._block(r,o.consumedPoints,this.msBlockDuration,i)),this.inMemoryBlockOnConsumed>0&&o.consumedPoints>=this.inMemoryBlockOnConsumed&&(this._inMemoryBlockedKeys.add(r,this.inMemoryBlockDuration),o.msBeforeNext=this.msInMemoryBlockDuration),e.then((()=>{t(o)})).catch((e=>{t(e)}))}else if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let t=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));t<this.execEvenlyMinDelayMs&&(t=o.consumedPoints*this.execEvenlyMinDelayMs),setTimeout(e,t,o)}else e(o)}_handleError(e,t,r,n,i,o=!1,a={}){this.insuranceLimiter instanceof s?this.insuranceLimiter[t](i,o,a).then((e=>{r(e)})).catch((e=>{n(e)})):n(e)}get _inmemoryBlockedKeys(){return this._inMemoryBlockedKeys}getInmemoryBlockMsBeforeExpire(e){return this.getInMemoryBlockMsBeforeExpire(e)}get inmemoryBlockOnConsumed(){return this.inMemoryBlockOnConsumed}set inmemoryBlockOnConsumed(e){this.inMemoryBlockOnConsumed=e}get inmemoryBlockDuration(){return this.inMemoryBlockDuration}set inmemoryBlockDuration(e){this.inMemoryBlockDuration=e}get msInmemoryBlockDuration(){return 1e3*this.inMemoryBlockDuration}getInMemoryBlockMsBeforeExpire(e){return this.inMemoryBlockOnConsumed>0?this._inMemoryBlockedKeys.msBeforeExpire(e):0}get inMemoryBlockOnConsumed(){return this._inMemoryBlockOnConsumed}set inMemoryBlockOnConsumed(e){if(this._inMemoryBlockOnConsumed=e?parseInt(e):0,this.inMemoryBlockOnConsumed>0&&this.points>this.inMemoryBlockOnConsumed)throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option')}get inMemoryBlockDuration(){return this._inMemoryBlockDuration}set inMemoryBlockDuration(e){if(this._inMemoryBlockDuration=e?parseInt(e):0,this.inMemoryBlockDuration>0&&0===this.inMemoryBlockOnConsumed)throw new Error("inMemoryBlockOnConsumed option must be set up")}get msInMemoryBlockDuration(){return 1e3*this._inMemoryBlockDuration}get insuranceLimiter(){return this._insuranceLimiter}set insuranceLimiter(e){if("undefined"!==typeof e&&!(e instanceof s))throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");this._insuranceLimiter=e,this._insuranceLimiter&&(this._insuranceLimiter.blockDuration=this.blockDuration,this._insuranceLimiter.execEvenly=this.execEvenly)}block(e,t,r={}){const s=1e3*t;return this._block(this.getKey(e),this.points+1,s,r)}set(e,t,r,s={}){const n=1e3*(r>=0?r:this.duration);return this._block(this.getKey(e),t,n,s)}consume(e,t=1,r={}){return new Promise(((s,n)=>{const o=this.getKey(e),a=this.getInMemoryBlockMsBeforeExpire(o);if(a>0)return n(new i(0,a));this._upsert(o,t,1e3*this._getKeySecDuration(r),!1,r).then((e=>{this._afterConsume(s,n,o,t,e)})).catch((i=>{this._handleError(i,"consume",s,n,e,t,r)}))}))}penalty(e,t=1,r={}){const s=this.getKey(e);return new Promise(((n,i)=>{this._upsert(s,t,1e3*this._getKeySecDuration(r),!1,r).then((e=>{n(this._getRateLimiterRes(s,t,e))})).catch((s=>{this._handleError(s,"penalty",n,i,e,t,r)}))}))}reward(e,t=1,r={}){const s=this.getKey(e);return new Promise(((n,i)=>{this._upsert(s,-t,1e3*this._getKeySecDuration(r),!1,r).then((e=>{n(this._getRateLimiterRes(s,-t,e))})).catch((s=>{this._handleError(s,"reward",n,i,e,t,r)}))}))}get(e,t={}){const r=this.getKey(e);return new Promise(((s,n)=>{this._get(r,t).then((e=>{s(null===e||"undefined"===typeof e?null:this._getRateLimiterRes(r,0,e))})).catch((r=>{this._handleError(r,"get",s,n,e,t)}))}))}delete(e,t={}){const r=this.getKey(e);return new Promise(((s,n)=>{this._delete(r,t).then((e=>{this._inMemoryBlockedKeys.delete(r),s(e)})).catch((r=>{this._handleError(r,"delete",s,n,e,t)}))}))}deleteInMemoryBlockedAll(){this._inMemoryBlockedKeys.delete()}_getRateLimiterRes(e,t,r){throw new Error("You have to implement the method '_getRateLimiterRes'!")}_block(e,t,r,s={}){return new Promise(((n,o)=>{this._upsert(e,t,r,!0,s).then((()=>{n(new i(0,r>0?r:-1,t))})).catch((t=>{this._handleError(t,"block",n,o,this.parseKey(e),r/1e3,s)}))}))}_get(e,t={}){throw new Error("You have to implement the method '_get'!")}_delete(e,t={}){throw new Error("You have to implement the method '_delete'!")}_upsert(e,t,r,s=!1,n={}){throw new Error("You have to implement the method '_upsert'!")}}},33766:function(e,t,r){const s=r(81352);e.exports=class{constructor(...e){if(e.length<2)throw new Error("RateLimiterUnion: at least two limiters have to be set");e.forEach((e=>{if(!(e instanceof s))throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract")})),this._limiters=e}consume(e,t=1){return new Promise(((r,s)=>{const n=[];this._limiters.forEach((r=>{n.push(r.consume(e,t).catch((e=>({rejected:!0,rej:e}))))})),Promise.all(n).then((e=>{const t={};let n=!1;e.forEach((e=>{!0===e.rejected&&(n=!0)}));for(let r=0;r<e.length;r++)n&&!0===e[r].rejected?t[this._limiters[r].keyPrefix]=e[r].rej:n||(t[this._limiters[r].keyPrefix]=e[r]);n?s(t):r(t)}))}))}}},78894:function(e){e.exports=class{constructor(){this._keys={},this._addedKeysAmount=0}collectExpired(){const e=Date.now();Object.keys(this._keys).forEach((t=>{this._keys[t]<=e&&delete this._keys[t]})),this._addedKeysAmount=Object.keys(this._keys).length}add(e,t){this.addMs(e,1e3*t)}addMs(e,t){this._keys[e]=Date.now()+t,this._addedKeysAmount++,this._addedKeysAmount>999&&this.collectExpired()}msBeforeExpire(e){const t=this._keys[e];if(t&&t>=Date.now()){this.collectExpired();const e=Date.now();return t>=e?t-e:0}return 0}delete(e){e?delete this._keys[e]:Object.keys(this._keys).forEach((e=>{delete this._keys[e]}))}}},52423:function(e,t,r){const s=r(78894);e.exports=s},58425:function(e,t,r){const s=r(9250),n=r(15155);e.exports=class{constructor(){this._storage={}}incrby(e,t,r){if(this._storage[e]){const s=this._storage[e].expiresAt?this._storage[e].expiresAt.getTime()-(new Date).getTime():-1;return 0!==s?(this._storage[e].value=this._storage[e].value+t,new n(0,s,this._storage[e].value,!1)):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const i=1e3*r;return this._storage[e]&&this._storage[e].timeoutId&&clearTimeout(this._storage[e].timeoutId),this._storage[e]=new s(t,i>0?new Date(Date.now()+i):null),i>0&&(this._storage[e].timeoutId=setTimeout((()=>{delete this._storage[e]}),i),this._storage[e].timeoutId.unref&&this._storage[e].timeoutId.unref()),new n(0,0===i?-1:i,this._storage[e].value,!0)}get(e){if(this._storage[e]){const t=this._storage[e].expiresAt?this._storage[e].expiresAt.getTime()-(new Date).getTime():-1;return new n(0,t,this._storage[e].value,!1)}return null}delete(e){return!!this._storage[e]&&(this._storage[e].timeoutId&&clearTimeout(this._storage[e].timeoutId),delete this._storage[e],!0)}}},9250:function(e){e.exports=class{constructor(e,t,r=null){this.value=e,this.expiresAt=t,this.timeoutId=r}get value(){return this._value}set value(e){this._value=parseInt(e)}get expiresAt(){return this._expiresAt}set expiresAt(e){e instanceof Date||!Number.isInteger(e)||(e=new Date(e)),this._expiresAt=e}get timeoutId(){return this._timeoutId}set timeoutId(e){this._timeoutId=e}}},45255:function(e){e.exports=class extends Error{constructor(e,t){super(),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="CustomError",this.message=e,t&&(this.extra=t)}}},73692:function(e,t,r){"use strict";e.exports=a;var s=r(57824),n=a.prototype,i=new Date%1e9;function o(){return(1e9*Math.random()>>>0)+i++}function a(e){e=e||{},this.id=e.id||o(),this.max=e.max||1/0,this.items=e.items||[],this._lookup={},this.size=this.items.length,this.lastModified=new Date(e.lastModified||new Date);for(var t,r,s=this.items.length;s--;)t=this.items[s],r=new Date(t.expires)-new Date,this._lookup[t.key]=t,r>0?this.expire(t.key,r):r<=0&&this.delete(t.key)}n.has=function(e){return e in this._lookup},n.get=function(e){if(!this.has(e))return null;var t=this._lookup[e];return t.refresh&&this.expire(e,t.refresh),this.items.splice(this.items.indexOf(t),1),this.items.push(t),t.value},n.meta=function(e){if(!this.has(e))return null;var t=this._lookup[e];return"meta"in t?t.meta:null},n.set=function(e,t,r){var s=this._lookup[e],n=this._lookup[e]={key:e,value:t};return this.lastModified=new Date,s?(clearTimeout(s.timeout),this.items.splice(this.items.indexOf(s),1,n)):(this.size>=this.max&&this.delete(this.items[0].key),this.items.push(n),this.size++),r&&("ttl"in r&&this.expire(e,r.ttl),"meta"in r&&(n.meta=r.meta),r.refresh&&(n.refresh=r.ttl)),this},n.delete=function(e){var t=this._lookup[e];return!!t&&(this.lastModified=new Date,this.items.splice(this.items.indexOf(t),1),clearTimeout(t.timeout),delete this._lookup[e],this.size--,this)},n.expire=function(e,t){var r=t||0,n=this._lookup[e];if(!n)return this;if("string"===typeof r&&(r=s(t)),"number"!==typeof r)throw new TypeError("Expiration time must be a string or number.");return clearTimeout(n.timeout),n.timeout=setTimeout(this.delete.bind(this,n.key),r),n.expires=Number(new Date)+r,this},n.clear=function(){for(var e=this.items.length;e--;)this.delete(this.items[e].key);return this},n.toJSON=function(){for(var e,t=new Array(this.items.length),r=t.length;r--;)e=this.items[r],t[r]={key:e.key,meta:e.meta,value:e.value,expires:e.expires,refresh:e.refresh};return{id:this.id,max:isFinite(this.max)?this.max:void 0,lastModified:this.lastModified,items:t}}},29967:function(e,t,r){
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
e.exports=n;const s=r(54375);function n(e,t,r){if("number"!==typeof t)throw new Error("second argument must be a Number");let n,i,o,a,c,l,u=!0;function h(e){function t(){r&&r(e,n),r=null}u?s(t):t()}function d(t,r,s){if(n[t]=s,r&&(c=!0),0===--o||r)h(r);else if(!c&&l<i){let t;a?(t=a[l],l+=1,e[t]((function(e,r){d(t,e,r)}))):(t=l,l+=1,e[t]((function(e,r){d(t,e,r)})))}}Array.isArray(e)?(n=[],o=i=e.length):(a=Object.keys(e),n={},o=i=a.length),l=t,o?a?a.some((function(r,s){return e[r]((function(e,t){d(r,e,t)})),s===t-1})):e.some((function(e,r){return e((function(e,t){d(r,e,t)})),r===t-1})):h(null),u=!1}},50202:function(e,t,r){"use strict";var s=r(63700),n=/[\/\?<>\\:\*\|"]/g,i=/[\x00-\x1f\x80-\x9f]/g,o=/^\.+$/,a=/^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,c=/[\. ]+$/;function l(e,t){if("string"!==typeof e)throw new Error("Input must be string");var r=e.replace(n,t).replace(i,t).replace(o,t).replace(a,t).replace(c,t);return s(r,255)}e.exports=function(e,t){var r=t&&t.replacement||"",s=l(e,r);return""===r?s:l(s,"")}},27695:function(e){"use strict";const t=new Map,r=()=>`${Date.now()}:${Math.floor(1e6*Math.random())}`;async function s(e,r,s){while(t.get(s)){try{await e()}catch(n){setTimeout((()=>{throw n}),1);break}if(!t.get(s))break;await new Promise((e=>{const n=setTimeout(e,r);t.set(s,n)}))}}function n(e,n,i){i=i||n;const o=r(),a=setTimeout((()=>{s(e,n,o)}),i);return t.set(o,a),o}function i(e){const r=t.get(e);r&&(clearTimeout(r),t.delete(e))}e.exports={setDelayedInterval:n,clearDelayedInterval:i}},20544:function(e){"use strict";const t=7;function r(e,t){return e+s(t)}function s(e){let t=e;return t-=t>>1&1431655765,t=(858993459&t)+(t>>2&858993459),16843009*(t+(t>>4)&252645135)>>24}function n(e,t){return e[0]-t[0]}function i(e){return e[1]}e.exports=class{constructor(){this._bitArrays=[],this._data=[],this._length=0,this._changedLength=!1,this._changedData=!1}set(e,t){let r=this._internalPositionFor(e,!1);if(void 0===t)-1!==r&&(this._unsetInternalPos(r),this._unsetBit(e),this._changedLength=!0,this._changedData=!0);else{let s=!1;-1===r?(r=this._data.length,this._setBit(e),this._changedData=!0):s=!0,this._setInternalPos(r,e,t,s),this._changedLength=!0}}unset(e){this.set(e,void 0)}get(e){this._sortData();const t=this._internalPositionFor(e,!0);if(-1!==t)return this._data[t][1]}push(e){return this.set(this.length,e),this.length}get length(){if(this._sortData(),this._changedLength){const e=this._data[this._data.length-1];this._length=e?e[0]+1:0,this._changedLength=!1}return this._length}forEach(e){let t=0;while(t<this.length)e(this.get(t),t,this),t++}map(e){let t=0,r=new Array(this.length);while(t<this.length)r[t]=e(this.get(t),t,this),t++;return r}reduce(e,t){let r=0,s=t;while(r<this.length){const t=this.get(r);s=e(s,t,r),r++}return s}find(e){let t,r,s=0;while(s<this.length&&!t)r=this.get(s),t=e(r),s++;return t?r:void 0}_internalPositionFor(e,n){const i=this._bytePosFor(e,n);if(i>=this._bitArrays.length)return-1;const o=this._bitArrays[i],a=e-i*t,c=(o&1<<a)>0;if(!c)return-1;const l=this._bitArrays.slice(0,i).reduce(r,0),u=~(4294967295<<a+1),h=s(o&u),d=l+h-1;return d}_bytePosFor(e,r){const s=Math.floor(e/t),n=s+1;while(!r&&this._bitArrays.length<n)this._bitArrays.push(0);return s}_setBit(e){const r=this._bytePosFor(e,!1);this._bitArrays[r]|=1<<e-r*t}_unsetBit(e){const r=this._bytePosFor(e,!1);this._bitArrays[r]&=~(1<<e-r*t)}_setInternalPos(e,t,r,s){const n=this._data,i=[t,r];if(s)this._sortData(),n[e]=i;else{if(n.length)if(n[n.length-1][0]>=t)n.push(i);else if(n[0][0]<=t)n.unshift(i);else{const e=Math.round(n.length/2);this._data=n.slice(0,e).concat(i).concat(n.slice(e))}else this._data.push(i);this._changedData=!0,this._changedLength=!0}}_unsetInternalPos(e){this._data.splice(e,1)}_sortData(){this._changedData&&this._data.sort(n),this._changedData=!1}bitField(){const e=[];let t,r=8,s=0,n=0;const i=this._bitArrays.slice();while(i.length||s){0===s&&(t=i.shift(),s=7);const o=Math.min(s,r),a=~(255<<o),c=t&a;n|=c<<8-r,t>>>=o,s-=o,r-=o,r&&(s||i.length)||(e.push(n),n=0,r=8)}for(var o=e.length-1;o>0;o--){const t=e[o];if(0!==t)break;e.pop()}return e}compactArray(){return this._sortData(),this._data.map(i)}}},84957:function(e){
/**
 * Timestamp for 64-bit time_t, nanosecond precision and strftime
 *
 * @author Yusuke Kawasaki
 * @license MIT
 * @see https://github.com/kawanet/timestamp-nano
 */
(function(){e.exports=w;var t=86400,r=3200,s=146097*r/400,n=t*s,i=1e3*n,o=1e11*t,a=16777216,c=4294967296,l=1e6,u=1e9,h="000000000",d=Math.trunc||x,p=w.prototype;w.fromDate=R,w.fromInt64BE=O(0,1,2,3,0,4),w.fromInt64LE=O(3,2,1,0,4,0),w.fromString=k,w.fromTimeT=T,p.year=0,p.time=0,p.nano=0,p.addNano=S,p.getNano=I,p.getTimeT=C,p.getYear=b,p.toDate=E,p.toJSON=P,p.toString=D,p.writeInt64BE=N(0,1,2,3,0,4),p.writeInt64LE=N(3,2,1,0,4,0);var f="%Y-%m-%dT%H:%M:%S.%NZ",y=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],g=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],m={"%":"%",F:"%Y-%m-%d",n:"\n",R:"%H:%M",T:"%H:%M:%S",t:"\t",X:"%T",Z:"GMT",z:"+0000"};return w;function w(e,t,r){var s=this;if(!(s instanceof w))return new w(e,t,r);s.time=+e||0,s.nano=+t||0,s.year=+r||0,_(s)}function b(){var e=this.toDate().getUTCFullYear();return e+this.year}function _(e){var t,s,n=e.year,a=e.time,c=e.nano;if(c<0||l<=c){var u=Math.floor(c/l);c-=u*l,a+=u,t=1}var h=n%r;if(a<-o||o<a||h){s=d(a/i),s&&(n+=s*r,a-=s*i);var p=v(a);p.setUTCFullYear(h+p.getUTCFullYear()),n-=h,a=+p,s=d(n/r);var f=a+s*i;s&&-o<=f&&f<=o&&(n-=s*r,a=f),t=1}return t&&(e.year=n,e.time=a,e.nano=c),e}function E(){var e=_(this);return v(e.time)}function v(e){var t=new Date(0);return t.setTime(e),t}function S(e){return this.nano+=+e||0,this}function I(){var e=_(this);return(e.time%1e3*l+ +e.nano+u)%u}function k(e){var t,r=new w;e+="";var s=e.replace(/^\s*[+\-]?\d+/,(function(e){var t=+e,s=1970+(t-1970)%400;return r.year=t-s,s})).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/,(function(e,r,s){return r<0&&(s*=-1),t=6e4*(60*+r+ +s),""})).replace(/\.\d+$/,(function(e){return r.nano=+(e+h).substr(1,9),""})).split(/\D+/);if(s.length>1?s[1]--:s[1]=0,r.time=t=Date.UTC.apply(Date,s)-(t||0),isNaN(t))throw new TypeError("Invalid Date");return _(r)}function R(e){return new w(+e)}function T(e){return A(e,0)}function A(e,t){t|=0,t*=c,e=+e||0;var s=d(t/n)+d(e/n),i=t%n+e%n,o=d(i/n);return o&&(s+=o,i-=o*n),new w(1e3*i,0,s*r)}function C(){var e=_(this),n=Math.floor(e.time/1e3),i=e.year;return i&&(n+=i*s*t/r),n}function P(){return this.toString().replace(/0{1,6}Z$/,"Z")}function D(e){var t=this,r=t.toDate(),s={H:l,L:d,M:u,N:p,S:h,Y:i,a:w,b:b,d:a,e:c,m:o};return n(e||f);function n(e){return e.replace(/%./g,(function(e){var t=e[1],r=m[t],i=s[t];return r?n(r):i?i():e}))}function i(){var e=t.getYear();return e>999999?"+"+e:e>9999?"+"+U(e,6):e>=0?U(e,4):e>=-999999?"-"+U(-e,6):e}function o(){return B(r.getUTCMonth()+1)}function a(){return B(r.getUTCDate())}function c(){return M(r.getUTCDate())}function l(){return B(r.getUTCHours())}function u(){return B(r.getUTCMinutes())}function h(){return B(r.getUTCSeconds())}function d(){return U(r.getUTCMilliseconds(),3)}function p(){return U(t.getNano(),9)}function w(){return g[r.getUTCDay()]}function b(){return y[r.getUTCMonth()]}}function N(e,n,i,o,a,l){return u;function u(e,n){var i=_(this);e||(e=new Array(8)),L(e,n|=0);var o=Math.floor(i.time/1e3),u=i.year*(s*t/r),p=d(u/c)+d(o/c),f=u%c+o%c,y=Math.floor(f/c);return y&&(p+=y,f-=y*c),h(e,n+a,p),h(e,n+l,f),e}function h(t,r,s){t[r+e]=s>>24&255,t[r+n]=s>>16&255,t[r+i]=s>>8&255,t[r+o]=255&s}}function O(e,t,r,s,n,i){return o;function o(e,t){L(e,t|=0);var r=c(e,t+n),s=c(e,t+i);return A(s,r)}function c(n,i){return n[i+e]*a+(n[i+t]<<16|n[i+r]<<8|n[i+s])}}function L(e,t){var r=e&&e.length;if(null==r)throw new TypeError("Invalid Buffer");if(r<t+8)throw new RangeError("Out of range")}function x(e){var t=e-e%1;return 0===t&&(e<0||0===e&&1/e!==1/0)?-0:t}function M(e){return(e>9?"":" ")+(0|e)}function B(e){return(e>9?"":"0")+(0|e)}function U(e,t){return(h+(0|e)).substr(-t)}})()},63700:function(e,t,r){"use strict";var s=r(71156),n=r(90793);e.exports=s.bind(null,n)},71156:function(e){"use strict";function t(e){return e>=55296&&e<=56319}function r(e){return e>=56320&&e<=57343}e.exports=function(e,s,n){if("string"!==typeof s)throw new Error("Input must be string");for(var i,o,a=s.length,c=0,l=0;l<a;l+=1){if(i=s.charCodeAt(l),o=s[l],t(i)&&r(s.charCodeAt(l+1))&&(l+=1,o+=s[l]),c+=e(o),c===n)return s.slice(0,l+1);if(c>n)return s.slice(0,l-o.length+1)}return s}},90793:function(e){"use strict";function t(e){return e>=55296&&e<=56319}function r(e){return e>=56320&&e<=57343}e.exports=function(e){if("string"!==typeof e)throw new Error("Input must be string");for(var s=e.length,n=0,i=null,o=null,a=0;a<s;a++)i=e.charCodeAt(a),r(i)?null!=o&&t(o)?n+=1:n+=3:i<=127?n+=1:i>=128&&i<=2047?n+=2:i>=2048&&i<=65535&&(n+=3),o=i;return n}},23209:function(e){e.exports=s;var t=128,r=127;function s(e,n){var i,o=0,a=(n=n||0,0),c=n,l=e.length;do{if(c>=l)throw s.bytes=0,new RangeError("Could not decode varint");i=e[c++],o+=a<28?(i&r)<<a:(i&r)*Math.pow(2,a),a+=7}while(i>=t);return s.bytes=c-n,o}},7089:function(e){e.exports=i;var t=128,r=127,s=~r,n=Math.pow(2,31);function i(e,r,o){r=r||[],o=o||0;var a=o;while(e>=n)r[o++]=255&e|t,e/=128;while(e&s)r[o++]=255&e|t,e>>>=7;return r[o]=0|e,i.bytes=o-a+1,r}},13924:function(e,t,r){e.exports={encode:r(7089),decode:r(23209),encodingLength:r(64146)}},64146:function(e){var t=Math.pow(2,7),r=Math.pow(2,14),s=Math.pow(2,21),n=Math.pow(2,28),i=Math.pow(2,35),o=Math.pow(2,42),a=Math.pow(2,49),c=Math.pow(2,56),l=Math.pow(2,63);e.exports=function(e){return e<t?1:e<r?2:e<s?3:e<n?4:e<i?5:e<o?6:e<a?7:e<c?8:e<l?9:10}},82838:function(e,t,r){"use strict";const s=r(13924);e.exports=e=>{if(!(e instanceof Uint8Array))throw new Error("arg needs to be a Uint8Array");const t=[];while(e.length>0){const r=s.decode(e);t.push(r),e=e.slice(s.decode.bytes)}return t}},52596:function(){},63897:function(){},81265:function(){},35539:function(){},64482:function(e,t,r){"use strict";var s,n,i;(function(o,a){n=[r(42450)],s=a,i="function"===typeof s?s.apply(t,n):s,void 0===i||(e.exports=i)})(0,(function(e){var t=e.Reader,r=e.Writer,s=e.util,n=e.roots["default"]||(e.roots["default"]={});return n.RPC=function(){function i(e){if(this.subscriptions=[],this.messages=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var o;return i.prototype.subscriptions=s.emptyArray,i.prototype.messages=s.emptyArray,i.prototype.control=null,Object.defineProperty(i.prototype,"_control",{get:s.oneOfGetter(o=["control"]),set:s.oneOfSetter(o)}),i.encode=function(e,t){if(t||(t=r.create()),null!=e.subscriptions&&e.subscriptions.length)for(var s=0;s<e.subscriptions.length;++s)n.RPC.SubOpts.encode(e.subscriptions[s],t.uint32(10).fork()).ldelim();if(null!=e.messages&&e.messages.length)for(s=0;s<e.messages.length;++s)n.RPC.Message.encode(e.messages[s],t.uint32(18).fork()).ldelim();return null!=e.control&&Object.hasOwnProperty.call(e,"control")&&n.RPC.ControlMessage.encode(e.control,t.uint32(26).fork()).ldelim(),t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var s=void 0===r?e.len:e.pos+r,i=new n.RPC;while(e.pos<s){var o=e.uint32();switch(o>>>3){case 1:i.subscriptions&&i.subscriptions.length||(i.subscriptions=[]),i.subscriptions.push(n.RPC.SubOpts.decode(e,e.uint32()));break;case 2:i.messages&&i.messages.length||(i.messages=[]),i.messages.push(n.RPC.Message.decode(e,e.uint32()));break;case 3:i.control=n.RPC.ControlMessage.decode(e,e.uint32());break;default:e.skipType(7&o);break}}return i},i.fromObject=function(e){if(e instanceof n.RPC)return e;var t=new n.RPC;if(e.subscriptions){if(!Array.isArray(e.subscriptions))throw TypeError(".RPC.subscriptions: array expected");t.subscriptions=[];for(var r=0;r<e.subscriptions.length;++r){if("object"!==typeof e.subscriptions[r])throw TypeError(".RPC.subscriptions: object expected");t.subscriptions[r]=n.RPC.SubOpts.fromObject(e.subscriptions[r])}}if(e.messages){if(!Array.isArray(e.messages))throw TypeError(".RPC.messages: array expected");t.messages=[];for(r=0;r<e.messages.length;++r){if("object"!==typeof e.messages[r])throw TypeError(".RPC.messages: object expected");t.messages[r]=n.RPC.Message.fromObject(e.messages[r])}}if(null!=e.control){if("object"!==typeof e.control)throw TypeError(".RPC.control: object expected");t.control=n.RPC.ControlMessage.fromObject(e.control)}return t},i.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.subscriptions=[],r.messages=[]),e.subscriptions&&e.subscriptions.length){r.subscriptions=[];for(var s=0;s<e.subscriptions.length;++s)r.subscriptions[s]=n.RPC.SubOpts.toObject(e.subscriptions[s],t)}if(e.messages&&e.messages.length){r.messages=[];for(s=0;s<e.messages.length;++s)r.messages[s]=n.RPC.Message.toObject(e.messages[s],t)}return null!=e.control&&e.hasOwnProperty("control")&&(r.control=n.RPC.ControlMessage.toObject(e.control,t),t.oneofs&&(r._control="control")),r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i.SubOpts=function(){function i(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var o;return i.prototype.subscribe=null,i.prototype.topic=null,Object.defineProperty(i.prototype,"_subscribe",{get:s.oneOfGetter(o=["subscribe"]),set:s.oneOfSetter(o)}),Object.defineProperty(i.prototype,"_topic",{get:s.oneOfGetter(o=["topic"]),set:s.oneOfSetter(o)}),i.encode=function(e,t){return t||(t=r.create()),null!=e.subscribe&&Object.hasOwnProperty.call(e,"subscribe")&&t.uint32(8).bool(e.subscribe),null!=e.topic&&Object.hasOwnProperty.call(e,"topic")&&t.uint32(18).string(e.topic),t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var s=void 0===r?e.len:e.pos+r,i=new n.RPC.SubOpts;while(e.pos<s){var o=e.uint32();switch(o>>>3){case 1:i.subscribe=e.bool();break;case 2:i.topic=e.string();break;default:e.skipType(7&o);break}}return i},i.fromObject=function(e){if(e instanceof n.RPC.SubOpts)return e;var t=new n.RPC.SubOpts;return null!=e.subscribe&&(t.subscribe=Boolean(e.subscribe)),null!=e.topic&&(t.topic=String(e.topic)),t},i.toObject=function(e,t){t||(t={});var r={};return null!=e.subscribe&&e.hasOwnProperty("subscribe")&&(r.subscribe=e.subscribe,t.oneofs&&(r._subscribe="subscribe")),null!=e.topic&&e.hasOwnProperty("topic")&&(r.topic=e.topic,t.oneofs&&(r._topic="topic")),r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i}(),i.Message=function(){function i(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var o;return i.prototype.from=null,i.prototype.data=null,i.prototype.seqno=null,i.prototype.topic="",i.prototype.signature=null,i.prototype.key=null,Object.defineProperty(i.prototype,"_from",{get:s.oneOfGetter(o=["from"]),set:s.oneOfSetter(o)}),Object.defineProperty(i.prototype,"_data",{get:s.oneOfGetter(o=["data"]),set:s.oneOfSetter(o)}),Object.defineProperty(i.prototype,"_seqno",{get:s.oneOfGetter(o=["seqno"]),set:s.oneOfSetter(o)}),Object.defineProperty(i.prototype,"_signature",{get:s.oneOfGetter(o=["signature"]),set:s.oneOfSetter(o)}),Object.defineProperty(i.prototype,"_key",{get:s.oneOfGetter(o=["key"]),set:s.oneOfSetter(o)}),i.encode=function(e,t){return t||(t=r.create()),null!=e.from&&Object.hasOwnProperty.call(e,"from")&&t.uint32(10).bytes(e.from),null!=e.data&&Object.hasOwnProperty.call(e,"data")&&t.uint32(18).bytes(e.data),null!=e.seqno&&Object.hasOwnProperty.call(e,"seqno")&&t.uint32(26).bytes(e.seqno),t.uint32(34).string(e.topic),null!=e.signature&&Object.hasOwnProperty.call(e,"signature")&&t.uint32(42).bytes(e.signature),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&t.uint32(50).bytes(e.key),t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var i=void 0===r?e.len:e.pos+r,o=new n.RPC.Message;while(e.pos<i){var a=e.uint32();switch(a>>>3){case 1:o.from=e.bytes();break;case 2:o.data=e.bytes();break;case 3:o.seqno=e.bytes();break;case 4:o.topic=e.string();break;case 5:o.signature=e.bytes();break;case 6:o.key=e.bytes();break;default:e.skipType(7&a);break}}if(!o.hasOwnProperty("topic"))throw s.ProtocolError("missing required 'topic'",{instance:o});return o},i.fromObject=function(e){if(e instanceof n.RPC.Message)return e;var t=new n.RPC.Message;return null!=e.from&&("string"===typeof e.from?s.base64.decode(e.from,t.from=s.newBuffer(s.base64.length(e.from)),0):e.from.length&&(t.from=e.from)),null!=e.data&&("string"===typeof e.data?s.base64.decode(e.data,t.data=s.newBuffer(s.base64.length(e.data)),0):e.data.length&&(t.data=e.data)),null!=e.seqno&&("string"===typeof e.seqno?s.base64.decode(e.seqno,t.seqno=s.newBuffer(s.base64.length(e.seqno)),0):e.seqno.length&&(t.seqno=e.seqno)),null!=e.topic&&(t.topic=String(e.topic)),null!=e.signature&&("string"===typeof e.signature?s.base64.decode(e.signature,t.signature=s.newBuffer(s.base64.length(e.signature)),0):e.signature.length&&(t.signature=e.signature)),null!=e.key&&("string"===typeof e.key?s.base64.decode(e.key,t.key=s.newBuffer(s.base64.length(e.key)),0):e.key.length&&(t.key=e.key)),t},i.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.topic=""),null!=e.from&&e.hasOwnProperty("from")&&(r.from=t.bytes===String?s.base64.encode(e.from,0,e.from.length):t.bytes===Array?Array.prototype.slice.call(e.from):e.from,t.oneofs&&(r._from="from")),null!=e.data&&e.hasOwnProperty("data")&&(r.data=t.bytes===String?s.base64.encode(e.data,0,e.data.length):t.bytes===Array?Array.prototype.slice.call(e.data):e.data,t.oneofs&&(r._data="data")),null!=e.seqno&&e.hasOwnProperty("seqno")&&(r.seqno=t.bytes===String?s.base64.encode(e.seqno,0,e.seqno.length):t.bytes===Array?Array.prototype.slice.call(e.seqno):e.seqno,t.oneofs&&(r._seqno="seqno")),null!=e.topic&&e.hasOwnProperty("topic")&&(r.topic=e.topic),null!=e.signature&&e.hasOwnProperty("signature")&&(r.signature=t.bytes===String?s.base64.encode(e.signature,0,e.signature.length):t.bytes===Array?Array.prototype.slice.call(e.signature):e.signature,t.oneofs&&(r._signature="signature")),null!=e.key&&e.hasOwnProperty("key")&&(r.key=t.bytes===String?s.base64.encode(e.key,0,e.key.length):t.bytes===Array?Array.prototype.slice.call(e.key):e.key,t.oneofs&&(r._key="key")),r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i}(),i.ControlMessage=function(){function i(e){if(this.ihave=[],this.iwant=[],this.graft=[],this.prune=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return i.prototype.ihave=s.emptyArray,i.prototype.iwant=s.emptyArray,i.prototype.graft=s.emptyArray,i.prototype.prune=s.emptyArray,i.encode=function(e,t){if(t||(t=r.create()),null!=e.ihave&&e.ihave.length)for(var s=0;s<e.ihave.length;++s)n.RPC.ControlIHave.encode(e.ihave[s],t.uint32(10).fork()).ldelim();if(null!=e.iwant&&e.iwant.length)for(s=0;s<e.iwant.length;++s)n.RPC.ControlIWant.encode(e.iwant[s],t.uint32(18).fork()).ldelim();if(null!=e.graft&&e.graft.length)for(s=0;s<e.graft.length;++s)n.RPC.ControlGraft.encode(e.graft[s],t.uint32(26).fork()).ldelim();if(null!=e.prune&&e.prune.length)for(s=0;s<e.prune.length;++s)n.RPC.ControlPrune.encode(e.prune[s],t.uint32(34).fork()).ldelim();return t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var s=void 0===r?e.len:e.pos+r,i=new n.RPC.ControlMessage;while(e.pos<s){var o=e.uint32();switch(o>>>3){case 1:i.ihave&&i.ihave.length||(i.ihave=[]),i.ihave.push(n.RPC.ControlIHave.decode(e,e.uint32()));break;case 2:i.iwant&&i.iwant.length||(i.iwant=[]),i.iwant.push(n.RPC.ControlIWant.decode(e,e.uint32()));break;case 3:i.graft&&i.graft.length||(i.graft=[]),i.graft.push(n.RPC.ControlGraft.decode(e,e.uint32()));break;case 4:i.prune&&i.prune.length||(i.prune=[]),i.prune.push(n.RPC.ControlPrune.decode(e,e.uint32()));break;default:e.skipType(7&o);break}}return i},i.fromObject=function(e){if(e instanceof n.RPC.ControlMessage)return e;var t=new n.RPC.ControlMessage;if(e.ihave){if(!Array.isArray(e.ihave))throw TypeError(".RPC.ControlMessage.ihave: array expected");t.ihave=[];for(var r=0;r<e.ihave.length;++r){if("object"!==typeof e.ihave[r])throw TypeError(".RPC.ControlMessage.ihave: object expected");t.ihave[r]=n.RPC.ControlIHave.fromObject(e.ihave[r])}}if(e.iwant){if(!Array.isArray(e.iwant))throw TypeError(".RPC.ControlMessage.iwant: array expected");t.iwant=[];for(r=0;r<e.iwant.length;++r){if("object"!==typeof e.iwant[r])throw TypeError(".RPC.ControlMessage.iwant: object expected");t.iwant[r]=n.RPC.ControlIWant.fromObject(e.iwant[r])}}if(e.graft){if(!Array.isArray(e.graft))throw TypeError(".RPC.ControlMessage.graft: array expected");t.graft=[];for(r=0;r<e.graft.length;++r){if("object"!==typeof e.graft[r])throw TypeError(".RPC.ControlMessage.graft: object expected");t.graft[r]=n.RPC.ControlGraft.fromObject(e.graft[r])}}if(e.prune){if(!Array.isArray(e.prune))throw TypeError(".RPC.ControlMessage.prune: array expected");t.prune=[];for(r=0;r<e.prune.length;++r){if("object"!==typeof e.prune[r])throw TypeError(".RPC.ControlMessage.prune: object expected");t.prune[r]=n.RPC.ControlPrune.fromObject(e.prune[r])}}return t},i.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.ihave=[],r.iwant=[],r.graft=[],r.prune=[]),e.ihave&&e.ihave.length){r.ihave=[];for(var s=0;s<e.ihave.length;++s)r.ihave[s]=n.RPC.ControlIHave.toObject(e.ihave[s],t)}if(e.iwant&&e.iwant.length){r.iwant=[];for(s=0;s<e.iwant.length;++s)r.iwant[s]=n.RPC.ControlIWant.toObject(e.iwant[s],t)}if(e.graft&&e.graft.length){r.graft=[];for(s=0;s<e.graft.length;++s)r.graft[s]=n.RPC.ControlGraft.toObject(e.graft[s],t)}if(e.prune&&e.prune.length){r.prune=[];for(s=0;s<e.prune.length;++s)r.prune[s]=n.RPC.ControlPrune.toObject(e.prune[s],t)}return r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i}(),i.ControlIHave=function(){function i(e){if(this.messageIDs=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var o;return i.prototype.topicID=null,i.prototype.messageIDs=s.emptyArray,Object.defineProperty(i.prototype,"_topicID",{get:s.oneOfGetter(o=["topicID"]),set:s.oneOfSetter(o)}),i.encode=function(e,t){if(t||(t=r.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&t.uint32(10).string(e.topicID),null!=e.messageIDs&&e.messageIDs.length)for(var s=0;s<e.messageIDs.length;++s)t.uint32(18).bytes(e.messageIDs[s]);return t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var s=void 0===r?e.len:e.pos+r,i=new n.RPC.ControlIHave;while(e.pos<s){var o=e.uint32();switch(o>>>3){case 1:i.topicID=e.string();break;case 2:i.messageIDs&&i.messageIDs.length||(i.messageIDs=[]),i.messageIDs.push(e.bytes());break;default:e.skipType(7&o);break}}return i},i.fromObject=function(e){if(e instanceof n.RPC.ControlIHave)return e;var t=new n.RPC.ControlIHave;if(null!=e.topicID&&(t.topicID=String(e.topicID)),e.messageIDs){if(!Array.isArray(e.messageIDs))throw TypeError(".RPC.ControlIHave.messageIDs: array expected");t.messageIDs=[];for(var r=0;r<e.messageIDs.length;++r)"string"===typeof e.messageIDs[r]?s.base64.decode(e.messageIDs[r],t.messageIDs[r]=s.newBuffer(s.base64.length(e.messageIDs[r])),0):e.messageIDs[r].length&&(t.messageIDs[r]=e.messageIDs[r])}return t},i.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.messageIDs=[]),null!=e.topicID&&e.hasOwnProperty("topicID")&&(r.topicID=e.topicID,t.oneofs&&(r._topicID="topicID")),e.messageIDs&&e.messageIDs.length){r.messageIDs=[];for(var n=0;n<e.messageIDs.length;++n)r.messageIDs[n]=t.bytes===String?s.base64.encode(e.messageIDs[n],0,e.messageIDs[n].length):t.bytes===Array?Array.prototype.slice.call(e.messageIDs[n]):e.messageIDs[n]}return r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i}(),i.ControlIWant=function(){function i(e){if(this.messageIDs=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return i.prototype.messageIDs=s.emptyArray,i.encode=function(e,t){if(t||(t=r.create()),null!=e.messageIDs&&e.messageIDs.length)for(var s=0;s<e.messageIDs.length;++s)t.uint32(10).bytes(e.messageIDs[s]);return t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var s=void 0===r?e.len:e.pos+r,i=new n.RPC.ControlIWant;while(e.pos<s){var o=e.uint32();switch(o>>>3){case 1:i.messageIDs&&i.messageIDs.length||(i.messageIDs=[]),i.messageIDs.push(e.bytes());break;default:e.skipType(7&o);break}}return i},i.fromObject=function(e){if(e instanceof n.RPC.ControlIWant)return e;var t=new n.RPC.ControlIWant;if(e.messageIDs){if(!Array.isArray(e.messageIDs))throw TypeError(".RPC.ControlIWant.messageIDs: array expected");t.messageIDs=[];for(var r=0;r<e.messageIDs.length;++r)"string"===typeof e.messageIDs[r]?s.base64.decode(e.messageIDs[r],t.messageIDs[r]=s.newBuffer(s.base64.length(e.messageIDs[r])),0):e.messageIDs[r].length&&(t.messageIDs[r]=e.messageIDs[r])}return t},i.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.messageIDs=[]),e.messageIDs&&e.messageIDs.length){r.messageIDs=[];for(var n=0;n<e.messageIDs.length;++n)r.messageIDs[n]=t.bytes===String?s.base64.encode(e.messageIDs[n],0,e.messageIDs[n].length):t.bytes===Array?Array.prototype.slice.call(e.messageIDs[n]):e.messageIDs[n]}return r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i}(),i.ControlGraft=function(){function i(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var o;return i.prototype.topicID=null,Object.defineProperty(i.prototype,"_topicID",{get:s.oneOfGetter(o=["topicID"]),set:s.oneOfSetter(o)}),i.encode=function(e,t){return t||(t=r.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&t.uint32(10).string(e.topicID),t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var s=void 0===r?e.len:e.pos+r,i=new n.RPC.ControlGraft;while(e.pos<s){var o=e.uint32();switch(o>>>3){case 1:i.topicID=e.string();break;default:e.skipType(7&o);break}}return i},i.fromObject=function(e){if(e instanceof n.RPC.ControlGraft)return e;var t=new n.RPC.ControlGraft;return null!=e.topicID&&(t.topicID=String(e.topicID)),t},i.toObject=function(e,t){t||(t={});var r={};return null!=e.topicID&&e.hasOwnProperty("topicID")&&(r.topicID=e.topicID,t.oneofs&&(r._topicID="topicID")),r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i}(),i.ControlPrune=function(){function i(e){if(this.peers=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var o;return i.prototype.topicID=null,i.prototype.peers=s.emptyArray,i.prototype.backoff=null,Object.defineProperty(i.prototype,"_topicID",{get:s.oneOfGetter(o=["topicID"]),set:s.oneOfSetter(o)}),Object.defineProperty(i.prototype,"_backoff",{get:s.oneOfGetter(o=["backoff"]),set:s.oneOfSetter(o)}),i.encode=function(e,t){if(t||(t=r.create()),null!=e.topicID&&Object.hasOwnProperty.call(e,"topicID")&&t.uint32(10).string(e.topicID),null!=e.peers&&e.peers.length)for(var s=0;s<e.peers.length;++s)n.RPC.PeerInfo.encode(e.peers[s],t.uint32(18).fork()).ldelim();return null!=e.backoff&&Object.hasOwnProperty.call(e,"backoff")&&t.uint32(24).uint64(e.backoff),t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var s=void 0===r?e.len:e.pos+r,i=new n.RPC.ControlPrune;while(e.pos<s){var o=e.uint32();switch(o>>>3){case 1:i.topicID=e.string();break;case 2:i.peers&&i.peers.length||(i.peers=[]),i.peers.push(n.RPC.PeerInfo.decode(e,e.uint32()));break;case 3:i.backoff=e.uint64();break;default:e.skipType(7&o);break}}return i},i.fromObject=function(e){if(e instanceof n.RPC.ControlPrune)return e;var t=new n.RPC.ControlPrune;if(null!=e.topicID&&(t.topicID=String(e.topicID)),e.peers){if(!Array.isArray(e.peers))throw TypeError(".RPC.ControlPrune.peers: array expected");t.peers=[];for(var r=0;r<e.peers.length;++r){if("object"!==typeof e.peers[r])throw TypeError(".RPC.ControlPrune.peers: object expected");t.peers[r]=n.RPC.PeerInfo.fromObject(e.peers[r])}}return null!=e.backoff&&(s.Long?(t.backoff=s.Long.fromValue(e.backoff)).unsigned=!0:"string"===typeof e.backoff?t.backoff=parseInt(e.backoff,10):"number"===typeof e.backoff?t.backoff=e.backoff:"object"===typeof e.backoff&&(t.backoff=new s.LongBits(e.backoff.low>>>0,e.backoff.high>>>0).toNumber(!0))),t},i.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.peers=[]),null!=e.topicID&&e.hasOwnProperty("topicID")&&(r.topicID=e.topicID,t.oneofs&&(r._topicID="topicID")),e.peers&&e.peers.length){r.peers=[];for(var i=0;i<e.peers.length;++i)r.peers[i]=n.RPC.PeerInfo.toObject(e.peers[i],t)}return null!=e.backoff&&e.hasOwnProperty("backoff")&&("number"===typeof e.backoff?r.backoff=t.longs===String?String(e.backoff):e.backoff:r.backoff=t.longs===String?s.Long.prototype.toString.call(e.backoff):t.longs===Number?new s.LongBits(e.backoff.low>>>0,e.backoff.high>>>0).toNumber(!0):e.backoff,t.oneofs&&(r._backoff="backoff")),r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i}(),i.PeerInfo=function(){function i(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var o;return i.prototype.peerID=null,i.prototype.signedPeerRecord=null,Object.defineProperty(i.prototype,"_peerID",{get:s.oneOfGetter(o=["peerID"]),set:s.oneOfSetter(o)}),Object.defineProperty(i.prototype,"_signedPeerRecord",{get:s.oneOfGetter(o=["signedPeerRecord"]),set:s.oneOfSetter(o)}),i.encode=function(e,t){return t||(t=r.create()),null!=e.peerID&&Object.hasOwnProperty.call(e,"peerID")&&t.uint32(10).bytes(e.peerID),null!=e.signedPeerRecord&&Object.hasOwnProperty.call(e,"signedPeerRecord")&&t.uint32(18).bytes(e.signedPeerRecord),t},i.decode=function(e,r){e instanceof t||(e=t.create(e));var s=void 0===r?e.len:e.pos+r,i=new n.RPC.PeerInfo;while(e.pos<s){var o=e.uint32();switch(o>>>3){case 1:i.peerID=e.bytes();break;case 2:i.signedPeerRecord=e.bytes();break;default:e.skipType(7&o);break}}return i},i.fromObject=function(e){if(e instanceof n.RPC.PeerInfo)return e;var t=new n.RPC.PeerInfo;return null!=e.peerID&&("string"===typeof e.peerID?s.base64.decode(e.peerID,t.peerID=s.newBuffer(s.base64.length(e.peerID)),0):e.peerID.length&&(t.peerID=e.peerID)),null!=e.signedPeerRecord&&("string"===typeof e.signedPeerRecord?s.base64.decode(e.signedPeerRecord,t.signedPeerRecord=s.newBuffer(s.base64.length(e.signedPeerRecord)),0):e.signedPeerRecord.length&&(t.signedPeerRecord=e.signedPeerRecord)),t},i.toObject=function(e,t){t||(t={});var r={};return null!=e.peerID&&e.hasOwnProperty("peerID")&&(r.peerID=t.bytes===String?s.base64.encode(e.peerID,0,e.peerID.length):t.bytes===Array?Array.prototype.slice.call(e.peerID):e.peerID,t.oneofs&&(r._peerID="peerID")),null!=e.signedPeerRecord&&e.hasOwnProperty("signedPeerRecord")&&(r.signedPeerRecord=t.bytes===String?s.base64.encode(e.signedPeerRecord,0,e.signedPeerRecord.length):t.bytes===Array?Array.prototype.slice.call(e.signedPeerRecord):e.signedPeerRecord,t.oneofs&&(r._signedPeerRecord="signedPeerRecord")),r},i.prototype.toJSON=function(){return this.constructor.toObject(this,e.util.toJSONOptions)},i}(),i}(),n}))},51550:function(e,t,r){"use strict";r.r(t),r.d(t,{create:function(){return nx},globSource:function(){return ix},path:function(){return ax},urlSource:function(){return ox}});var s={};r.r(s),r.d(s,{code:function(){return B},decode:function(){return j},encode:function(){return U},name:function(){return M}});var n={};r.r(n),r.d(n,{code:function(){return ae},decode:function(){return le},encode:function(){return ce},name:function(){return oe}});var i={};r.r(i),r.d(i,{code:function(){return Se},decode:function(){return Pe},encode:function(){return Ce},name:function(){return ve},toGeneral:function(){return Ae}});var o={};r.r(o),r.d(o,{InvalidValueError:function(){return i_},MissingRepoOptionsError:function(){return o_},NonReversibleMigrationError:function(){return r_},NotInitializedRepoError:function(){return s_},RequiredParameterError:function(){return n_}});var a={};r.r(a),r.d(a,{abortedError:function(){return RL},notFoundError:function(){return kL}});var c=r(40726),l=r(106),u=r(69860),h=r(32114),d=r(62100);const p=d.Reader,f=d.Writer,y=d.util,g=d.roots["ipfs-unixfs"]||(d.roots["ipfs-unixfs"]={}),m=g.Data=(()=>{function e(e){if(this.blocksizes=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.Type=0,e.prototype.Data=y.newBuffer([]),e.prototype.filesize=y.Long?y.Long.fromBits(0,0,!0):0,e.prototype.blocksizes=y.emptyArray,e.prototype.hashType=y.Long?y.Long.fromBits(0,0,!0):0,e.prototype.fanout=y.Long?y.Long.fromBits(0,0,!0):0,e.prototype.mode=0,e.prototype.mtime=null,e.encode=function(e,t){if(t||(t=f.create()),t.uint32(8).int32(e.Type),null!=e.Data&&Object.hasOwnProperty.call(e,"Data")&&t.uint32(18).bytes(e.Data),null!=e.filesize&&Object.hasOwnProperty.call(e,"filesize")&&t.uint32(24).uint64(e.filesize),null!=e.blocksizes&&e.blocksizes.length)for(var r=0;r<e.blocksizes.length;++r)t.uint32(32).uint64(e.blocksizes[r]);return null!=e.hashType&&Object.hasOwnProperty.call(e,"hashType")&&t.uint32(40).uint64(e.hashType),null!=e.fanout&&Object.hasOwnProperty.call(e,"fanout")&&t.uint32(48).uint64(e.fanout),null!=e.mode&&Object.hasOwnProperty.call(e,"mode")&&t.uint32(56).uint32(e.mode),null!=e.mtime&&Object.hasOwnProperty.call(e,"mtime")&&g.UnixTime.encode(e.mtime,t.uint32(66).fork()).ldelim(),t},e.decode=function(e,t){e instanceof p||(e=p.create(e));var r=void 0===t?e.len:e.pos+t,s=new g.Data;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.Type=e.int32();break;case 2:s.Data=e.bytes();break;case 3:s.filesize=e.uint64();break;case 4:if(s.blocksizes&&s.blocksizes.length||(s.blocksizes=[]),2===(7&n)){var i=e.uint32()+e.pos;while(e.pos<i)s.blocksizes.push(e.uint64())}else s.blocksizes.push(e.uint64());break;case 5:s.hashType=e.uint64();break;case 6:s.fanout=e.uint64();break;case 7:s.mode=e.uint32();break;case 8:s.mtime=g.UnixTime.decode(e,e.uint32());break;default:e.skipType(7&n);break}}if(!s.hasOwnProperty("Type"))throw y.ProtocolError("missing required 'Type'",{instance:s});return s},e.fromObject=function(e){if(e instanceof g.Data)return e;var t=new g.Data;switch(e.Type){case"Raw":case 0:t.Type=0;break;case"Directory":case 1:t.Type=1;break;case"File":case 2:t.Type=2;break;case"Metadata":case 3:t.Type=3;break;case"Symlink":case 4:t.Type=4;break;case"HAMTShard":case 5:t.Type=5;break}if(null!=e.Data&&("string"===typeof e.Data?y.base64.decode(e.Data,t.Data=y.newBuffer(y.base64.length(e.Data)),0):e.Data.length&&(t.Data=e.Data)),null!=e.filesize&&(y.Long?(t.filesize=y.Long.fromValue(e.filesize)).unsigned=!0:"string"===typeof e.filesize?t.filesize=parseInt(e.filesize,10):"number"===typeof e.filesize?t.filesize=e.filesize:"object"===typeof e.filesize&&(t.filesize=new y.LongBits(e.filesize.low>>>0,e.filesize.high>>>0).toNumber(!0))),e.blocksizes){if(!Array.isArray(e.blocksizes))throw TypeError(".Data.blocksizes: array expected");t.blocksizes=[];for(var r=0;r<e.blocksizes.length;++r)y.Long?(t.blocksizes[r]=y.Long.fromValue(e.blocksizes[r])).unsigned=!0:"string"===typeof e.blocksizes[r]?t.blocksizes[r]=parseInt(e.blocksizes[r],10):"number"===typeof e.blocksizes[r]?t.blocksizes[r]=e.blocksizes[r]:"object"===typeof e.blocksizes[r]&&(t.blocksizes[r]=new y.LongBits(e.blocksizes[r].low>>>0,e.blocksizes[r].high>>>0).toNumber(!0))}if(null!=e.hashType&&(y.Long?(t.hashType=y.Long.fromValue(e.hashType)).unsigned=!0:"string"===typeof e.hashType?t.hashType=parseInt(e.hashType,10):"number"===typeof e.hashType?t.hashType=e.hashType:"object"===typeof e.hashType&&(t.hashType=new y.LongBits(e.hashType.low>>>0,e.hashType.high>>>0).toNumber(!0))),null!=e.fanout&&(y.Long?(t.fanout=y.Long.fromValue(e.fanout)).unsigned=!0:"string"===typeof e.fanout?t.fanout=parseInt(e.fanout,10):"number"===typeof e.fanout?t.fanout=e.fanout:"object"===typeof e.fanout&&(t.fanout=new y.LongBits(e.fanout.low>>>0,e.fanout.high>>>0).toNumber(!0))),null!=e.mode&&(t.mode=e.mode>>>0),null!=e.mtime){if("object"!==typeof e.mtime)throw TypeError(".Data.mtime: object expected");t.mtime=g.UnixTime.fromObject(e.mtime)}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.blocksizes=[]),t.defaults){if(r.Type=t.enums===String?"Raw":0,t.bytes===String?r.Data="":(r.Data=[],t.bytes!==Array&&(r.Data=y.newBuffer(r.Data))),y.Long){var s=new y.Long(0,0,!0);r.filesize=t.longs===String?s.toString():t.longs===Number?s.toNumber():s}else r.filesize=t.longs===String?"0":0;if(y.Long){s=new y.Long(0,0,!0);r.hashType=t.longs===String?s.toString():t.longs===Number?s.toNumber():s}else r.hashType=t.longs===String?"0":0;if(y.Long){s=new y.Long(0,0,!0);r.fanout=t.longs===String?s.toString():t.longs===Number?s.toNumber():s}else r.fanout=t.longs===String?"0":0;r.mode=0,r.mtime=null}if(null!=e.Type&&e.hasOwnProperty("Type")&&(r.Type=t.enums===String?g.Data.DataType[e.Type]:e.Type),null!=e.Data&&e.hasOwnProperty("Data")&&(r.Data=t.bytes===String?y.base64.encode(e.Data,0,e.Data.length):t.bytes===Array?Array.prototype.slice.call(e.Data):e.Data),null!=e.filesize&&e.hasOwnProperty("filesize")&&("number"===typeof e.filesize?r.filesize=t.longs===String?String(e.filesize):e.filesize:r.filesize=t.longs===String?y.Long.prototype.toString.call(e.filesize):t.longs===Number?new y.LongBits(e.filesize.low>>>0,e.filesize.high>>>0).toNumber(!0):e.filesize),e.blocksizes&&e.blocksizes.length){r.blocksizes=[];for(var n=0;n<e.blocksizes.length;++n)"number"===typeof e.blocksizes[n]?r.blocksizes[n]=t.longs===String?String(e.blocksizes[n]):e.blocksizes[n]:r.blocksizes[n]=t.longs===String?y.Long.prototype.toString.call(e.blocksizes[n]):t.longs===Number?new y.LongBits(e.blocksizes[n].low>>>0,e.blocksizes[n].high>>>0).toNumber(!0):e.blocksizes[n]}return null!=e.hashType&&e.hasOwnProperty("hashType")&&("number"===typeof e.hashType?r.hashType=t.longs===String?String(e.hashType):e.hashType:r.hashType=t.longs===String?y.Long.prototype.toString.call(e.hashType):t.longs===Number?new y.LongBits(e.hashType.low>>>0,e.hashType.high>>>0).toNumber(!0):e.hashType),null!=e.fanout&&e.hasOwnProperty("fanout")&&("number"===typeof e.fanout?r.fanout=t.longs===String?String(e.fanout):e.fanout:r.fanout=t.longs===String?y.Long.prototype.toString.call(e.fanout):t.longs===Number?new y.LongBits(e.fanout.low>>>0,e.fanout.high>>>0).toNumber(!0):e.fanout),null!=e.mode&&e.hasOwnProperty("mode")&&(r.mode=e.mode),null!=e.mtime&&e.hasOwnProperty("mtime")&&(r.mtime=g.UnixTime.toObject(e.mtime,t)),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.DataType=function(){const e={},t=Object.create(e);return t[e[0]="Raw"]=0,t[e[1]="Directory"]=1,t[e[2]="File"]=2,t[e[3]="Metadata"]=3,t[e[4]="Symlink"]=4,t[e[5]="HAMTShard"]=5,t}(),e})(),w=(g.UnixTime=(()=>{function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.Seconds=y.Long?y.Long.fromBits(0,0,!1):0,e.prototype.FractionalNanoseconds=0,e.encode=function(e,t){return t||(t=f.create()),t.uint32(8).int64(e.Seconds),null!=e.FractionalNanoseconds&&Object.hasOwnProperty.call(e,"FractionalNanoseconds")&&t.uint32(21).fixed32(e.FractionalNanoseconds),t},e.decode=function(e,t){e instanceof p||(e=p.create(e));var r=void 0===t?e.len:e.pos+t,s=new g.UnixTime;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.Seconds=e.int64();break;case 2:s.FractionalNanoseconds=e.fixed32();break;default:e.skipType(7&n);break}}if(!s.hasOwnProperty("Seconds"))throw y.ProtocolError("missing required 'Seconds'",{instance:s});return s},e.fromObject=function(e){if(e instanceof g.UnixTime)return e;var t=new g.UnixTime;return null!=e.Seconds&&(y.Long?(t.Seconds=y.Long.fromValue(e.Seconds)).unsigned=!1:"string"===typeof e.Seconds?t.Seconds=parseInt(e.Seconds,10):"number"===typeof e.Seconds?t.Seconds=e.Seconds:"object"===typeof e.Seconds&&(t.Seconds=new y.LongBits(e.Seconds.low>>>0,e.Seconds.high>>>0).toNumber())),null!=e.FractionalNanoseconds&&(t.FractionalNanoseconds=e.FractionalNanoseconds>>>0),t},e.toObject=function(e,t){t||(t={});var r={};if(t.defaults){if(y.Long){var s=new y.Long(0,0,!1);r.Seconds=t.longs===String?s.toString():t.longs===Number?s.toNumber():s}else r.Seconds=t.longs===String?"0":0;r.FractionalNanoseconds=0}return null!=e.Seconds&&e.hasOwnProperty("Seconds")&&("number"===typeof e.Seconds?r.Seconds=t.longs===String?String(e.Seconds):e.Seconds:r.Seconds=t.longs===String?y.Long.prototype.toString.call(e.Seconds):t.longs===Number?new y.LongBits(e.Seconds.low>>>0,e.Seconds.high>>>0).toNumber():e.Seconds),null!=e.FractionalNanoseconds&&e.hasOwnProperty("FractionalNanoseconds")&&(r.FractionalNanoseconds=e.FractionalNanoseconds),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e})(),g.Metadata=(()=>{function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.MimeType="",e.encode=function(e,t){return t||(t=f.create()),null!=e.MimeType&&Object.hasOwnProperty.call(e,"MimeType")&&t.uint32(10).string(e.MimeType),t},e.decode=function(e,t){e instanceof p||(e=p.create(e));var r=void 0===t?e.len:e.pos+t,s=new g.Metadata;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.MimeType=e.string();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof g.Metadata)return e;var t=new g.Metadata;return null!=e.MimeType&&(t.MimeType=String(e.MimeType)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.MimeType=""),null!=e.MimeType&&e.hasOwnProperty("MimeType")&&(r.MimeType=e.MimeType),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e})(),m),b=["raw","directory","file","metadata","symlink","hamt-sharded-directory"],_=["directory","hamt-sharded-directory"],E=parseInt("0644",8),v=parseInt("0755",8);function S(e){if(null!=e)return"number"===typeof e?4095&e:(e=e.toString(),"0"===e.substring(0,1)?4095&parseInt(e,8):4095&parseInt(e,10))}function I(e){if(null==e)return;let t;if(null!=e.secs&&(t={secs:e.secs,nsecs:e.nsecs}),null!=e.Seconds&&(t={secs:e.Seconds,nsecs:e.FractionalNanoseconds}),Array.isArray(e)&&(t={secs:e[0],nsecs:e[1]}),e instanceof Date){const r=e.getTime(),s=Math.floor(r/1e3);t={secs:s,nsecs:1e3*(r-1e3*s)}}if(Object.prototype.hasOwnProperty.call(t,"secs")){if(null!=t&&null!=t.nsecs&&(t.nsecs<0||t.nsecs>999999999))throw h(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return t}}class k{static unmarshal(e){const t=w.decode(e),r=w.toObject(t,{defaults:!1,arrays:!0,longs:Number,objects:!1}),s=new k({type:b[r.Type],data:r.Data,blockSizes:r.blocksizes,mode:r.mode,mtime:r.mtime?{secs:r.mtime.Seconds,nsecs:r.mtime.FractionalNanoseconds}:void 0});return s._originalMode=r.mode||0,s}constructor(e={type:"file"}){const{type:t,data:r,blockSizes:s,hashType:n,fanout:i,mtime:o,mode:a}=e;if(t&&!b.includes(t))throw h(new Error("Type: "+t+" is not valid"),"ERR_INVALID_TYPE");this.type=t||"file",this.data=r,this.hashType=n,this.fanout=i,this.blockSizes=s||[],this._originalMode=0,this.mode=S(a),o&&(this.mtime=I(o),this.mtime&&!this.mtime.nsecs&&(this.mtime.nsecs=0))}set mode(e){this._mode=this.isDirectory()?v:E;const t=S(e);void 0!==t&&(this._mode=t)}get mode(){return this._mode}isDirectory(){return Boolean(this.type&&_.includes(this.type))}addBlockSize(e){this.blockSizes.push(e)}removeBlockSize(e){this.blockSizes.splice(e,1)}fileSize(){if(this.isDirectory())return 0;let e=0;return this.blockSizes.forEach((t=>{e+=t})),this.data&&(e+=this.data.length),e}marshal(){let e;switch(this.type){case"raw":e=w.DataType.Raw;break;case"directory":e=w.DataType.Directory;break;case"file":e=w.DataType.File;break;case"metadata":e=w.DataType.Metadata;break;case"symlink":e=w.DataType.Symlink;break;case"hamt-sharded-directory":e=w.DataType.HAMTShard;break;default:throw h(new Error("Type: "+e+" is not valid"),"ERR_INVALID_TYPE")}let t,r,s=this.data;if(this.data&&this.data.length||(s=void 0),null!=this.mode&&(t=4294963200&this._originalMode|(S(this.mode)||0),t!==E||this.isDirectory()||(t=void 0),t===v&&this.isDirectory()&&(t=void 0)),null!=this.mtime){const e=I(this.mtime);e&&(r={Seconds:e.secs,FractionalNanoseconds:e.nsecs},0===r.FractionalNanoseconds&&delete r.FractionalNanoseconds)}const n={Type:e,Data:s,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:t,mtime:r};return w.encode(n).finish()}}var R=r(81972),T=r(64936),A=r(81362);const C=42;function P(e){if(e.asCID!==e)return null;const t=A.CID.asCID(e);if(!t)return null;const r=new Uint8Array(t.bytes.byteLength+1);return r.set(t.bytes,1),[new T.WU(T.Dy.tag,C),new T.WU(T.Dy.bytes,r)]}function D(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function N(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const O={float64:!0,typeEncoders:{Object:P,undefined:D,number:N}};function L(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return A.CID.decode(e.subarray(1))}const x={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};x.tags[C]=L;const M="dag-cbor",B=113,U=e=>T.cv(e,O),j=e=>T.Jx(e,x);var V=r(16441),z=r(9885),F=r(59787),$=r(85989),K=r(85590),H=r(22042);class q extends Array{constructor(){super(),this.inRecursive=[]}prefix(e){const t=this.inRecursive[this.inRecursive.length-1];t&&(t.type===F.D.array&&(t.elements++,1!==t.elements&&e.push([44])),t.type===F.D.map&&(t.elements++,1!==t.elements&&(t.elements%2===1?e.push([44]):e.push([58]))))}[F.D.uint.major](e,t){this.prefix(e);const r=String(t.value),s=[];for(let n=0;n<r.length;n++)s[n]=r.charCodeAt(n);e.push(s)}[F.D.negint.major](e,t){this[F.D.uint.major](e,t)}[F.D.bytes.major](e,t){throw new Error(`${K.OO} unsupported type: Uint8Array`)}[F.D.string.major](e,t){this.prefix(e);const r=(0,H.mL)(JSON.stringify(t.value));e.push(r.length>32?(0,H.Dz)(r):r)}[F.D.array.major](e,t){this.prefix(e),this.inRecursive.push({type:F.D.array,elements:0}),e.push([91])}[F.D.map.major](e,t){this.prefix(e),this.inRecursive.push({type:F.D.map,elements:0}),e.push([123])}[F.D.tag.major](e,t){}[F.D.float.major](e,t){if("break"===t.type.name){const t=this.inRecursive.pop();if(t){if(t.type===F.D.array)e.push([93]);else{if(t.type!==F.D.map)throw new Error("Unexpected recursive type; this should not happen!");e.push([125])}return}throw new Error("Unexpected break; this should not happen!")}if(void 0===t.value)throw new Error(`${K.OO} unsupported type: undefined`);if(this.prefix(e),"true"===t.type.name)return void e.push([116,114,117,101]);if("false"===t.type.name)return void e.push([102,97,108,115,101]);if("null"===t.type.name)return void e.push([110,117,108,108]);const r=String(t.value),s=[];let n=!1;for(let i=0;i<r.length;i++)s[i]=r.charCodeAt(i),n||46!==s[i]&&101!==s[i]&&69!==s[i]||(n=!0);n||(s.push(46),s.push(48)),e.push(s)}}function G(e,t){if(Array.isArray(e[0])||Array.isArray(t[0]))throw new Error(`${K.OO} complex map keys are not supported`);const r=e[0],s=t[0];if(r.type!==F.D.string||s.type!==F.D.string)throw new Error(`${K.OO} non-string map keys are not supported`);if(r<s)return-1;if(r>s)return 1;throw new Error(`${K.OO} unexpected duplicate map keys, this is not supported`)}const W={addBreakTokens:!0,mapSorter:G};function Y(e,t){return t=Object.assign({},W,t),(0,$.w$)(e,new q,t)}var Q=r(61287);class Z{constructor(e,t={}){this.pos=0,this.data=e,this.options=t,this.modeStack=["value"],this.lastToken=""}done(){return this.pos>=this.data.length}ch(){return this.data[this.pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let e=this.ch();while(32===e||9===e||13===e||10===e)e=this.data[++this.pos]}expect(e){if(this.data.length-this.pos<e.length)throw new Error(`${K.IR} unexpected end of input at position ${this.pos}`);for(let t=0;t<e.length;t++)if(this.data[this.pos++]!==e[t])throw new Error(`${K.IR} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...e)}'`)}parseNumber(){const e=this.pos;let t=!1,r=!1;const s=e=>{while(!this.done()){const t=this.ch();if(!e.includes(t))break;this.pos++}};if(45===this.ch()&&(t=!0,this.pos++),48===this.ch()){if(this.pos++,46!==this.ch())return new F.W(F.D.uint,0,this.pos-e);this.pos++,r=!0}if(s([48,49,50,51,52,53,54,55,56,57]),t&&this.pos===e+1)throw new Error(`${K.IR} unexpected token at position ${this.pos}`);if(!this.done()&&46===this.ch()){if(r)throw new Error(`${K.IR} unexpected token at position ${this.pos}`);r=!0,this.pos++,s([48,49,50,51,52,53,54,55,56,57])}this.done()||101!==this.ch()&&69!==this.ch()||(r=!0,this.pos++,this.done()||43!==this.ch()&&45!==this.ch()||this.pos++,s([48,49,50,51,52,53,54,55,56,57]));const n=String.fromCharCode.apply(null,this.data.subarray(e,this.pos)),i=parseFloat(n);return r?new F.W(F.D.float,i,this.pos-e):!0!==this.options.allowBigInt||Number.isSafeInteger(i)?new F.W(i>=0?F.D.uint:F.D.negint,i,this.pos-e):new F.W(i>=0?F.D.uint:F.D.negint,BigInt(n),this.pos-e)}parseString(){if(34!==this.ch())throw new Error(`${K.IR} unexpected character at position ${this.pos}; this shouldn't happen`);this.pos++;for(let n=this.pos,i=0;n<this.data.length&&i<65536;n++,i++){const e=this.data[n];if(92===e||e<32||e>=128)break;if(34===e){const e=String.fromCharCode.apply(null,this.data.subarray(this.pos,n));return this.pos=n+1,new F.W(F.D.string,e,i)}}const e=this.pos,t=[],r=()=>{if(this.pos+4>=this.data.length)throw new Error(`${K.IR} unexpected end of unicode escape sequence at position ${this.pos}`);let e=0;for(let t=0;t<4;t++){let t=this.ch();if(t>=48&&t<=57)t-=48;else if(t>=97&&t<=102)t=t-97+10;else{if(!(t>=65&&t<=70))throw new Error(`${K.IR} unexpected unicode escape character at position ${this.pos}`);t=t-65+10}e=16*e+t,this.pos++}return e},s=()=>{const e=this.ch();let r,s,n,i,o=null,a=e>239?4:e>223?3:e>191?2:1;if(this.pos+a>this.data.length)throw new Error(`${K.IR} unexpected unicode sequence at position ${this.pos}`);switch(a){case 1:e<128&&(o=e);break;case 2:r=this.data[this.pos+1],128===(192&r)&&(i=(31&e)<<6|63&r,i>127&&(o=i));break;case 3:r=this.data[this.pos+1],s=this.data[this.pos+2],128===(192&r)&&128===(192&s)&&(i=(15&e)<<12|(63&r)<<6|63&s,i>2047&&(i<55296||i>57343)&&(o=i));break;case 4:r=this.data[this.pos+1],s=this.data[this.pos+2],n=this.data[this.pos+3],128===(192&r)&&128===(192&s)&&128===(192&n)&&(i=(15&e)<<18|(63&r)<<12|(63&s)<<6|63&n,i>65535&&i<1114112&&(o=i))}null===o?(o=65533,a=1):o>65535&&(o-=65536,t.push(o>>>10&1023|55296),o=56320|1023&o),t.push(o),this.pos+=a};while(!this.done()){const n=this.ch();let i;switch(n){case 92:if(this.pos++,this.done())throw new Error(`${K.IR} unexpected string termination at position ${this.pos}`);switch(i=this.ch(),this.pos++,i){case 34:case 39:case 92:case 47:t.push(i);break;case 98:t.push(8);break;case 116:t.push(9);break;case 110:t.push(10);break;case 102:t.push(12);break;case 114:t.push(13);break;case 117:t.push(r());break;default:throw new Error(`${K.IR} unexpected string escape character at position ${this.pos}`)}break;case 34:return this.pos++,new F.W(F.D.string,(0,H.Pu)(t),this.pos-e);default:if(n<32)throw new Error(`${K.IR} invalid control character at position ${this.pos}`);n<128?(t.push(n),this.pos++):s()}}throw new Error(`${K.IR} unexpected end of string at position ${this.pos}`)}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this.pos++,new F.W(F.D.map,1/0,1);case 91:return this.modeStack.push("array-start"),this.pos++,new F.W(F.D.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new F.W(F.D["null"],null,4);case 102:return this.expect([102,97,108,115,101]),new F.W(F.D["false"],!1,5);case 116:return this.expect([116,114,117,101]),new F.W(F.D["true"],!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error(`${K.IR} unexpected character at position ${this.pos}`)}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":if(this.modeStack.pop(),93===this.ch())return this.pos++,this.skipWhitespace(),new F.W(F.D["break"],void 0,1);if(44!==this.ch())throw new Error(`${K.IR} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);return this.pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue();case"array-start":return this.modeStack.pop(),93===this.ch()?(this.pos++,this.skipWhitespace(),new F.W(F.D["break"],void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(125===this.ch())return this.modeStack.pop(),this.pos++,this.skipWhitespace(),new F.W(F.D["break"],void 0,1);if(44!==this.ch())throw new Error(`${K.IR} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);this.pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),125===this.ch())return this.pos++,this.skipWhitespace(),new F.W(F.D["break"],void 0,1);const e=this.parseString();if(this.skipWhitespace(),58!==this.ch())throw new Error(`${K.IR} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);return this.pos++,this.modeStack.push("obj-value"),e}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error(`${K.IR} unexpected parse state at position ${this.pos}; this shouldn't happen`)}}}function X(e,t){return t=Object.assign({tokenizer:new Z(e,t)},t),(0,Q.Jx)(e,t)}function J(e){if(e.asCID!==e)return null;const t=V.k0.asCID(e);if(!t)return null;const r=t.toString();return[new T.WU(T.Dy.map,1/0,1),new T.WU(T.Dy.string,"/",1),new T.WU(T.Dy.string,r,r.length),new T.WU(T.Dy["break"],void 0,1)]}function ee(e){const t=z.base64.encode(e).slice(1);return[new T.WU(T.Dy.map,1/0,1),new T.WU(T.Dy.string,"/",1),new T.WU(T.Dy.map,1/0,1),new T.WU(T.Dy.string,"bytes",5),new T.WU(T.Dy.string,t,t.length),new T.WU(T.Dy["break"],void 0,1),new T.WU(T.Dy["break"],void 0,1)]}function te(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function re(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const se={typeEncoders:{Object:J,Uint8Array:ee,Buffer:ee,undefined:te,number:re}};class ne extends Z{constructor(e,t){super(e,t),this.tokenBuffer=[]}done(){return 0===this.tokenBuffer.length&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===T.Dy.map){const e=this._next();if(e.type===T.Dy.string&&"/"===e.value){const e=this._next();if(e.type===T.Dy.string){const t=this._next();if(t.type!==T.Dy["break"])throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(e),new T.WU(T.Dy.tag,42,0)}if(e.type===T.Dy.map){const e=this._next();if(e.type===T.Dy.string&&"bytes"===e.value){const e=this._next();if(e.type===T.Dy.string){for(let e=0;e<2;e++){const e=this._next();if(e.type!==T.Dy["break"])throw new Error("Invalid encoded Bytes form")}const t=z.base64.decode(`m${e.value}`);return new T.WU(T.Dy.bytes,t,e.value.length)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}return e}}const ie={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};ie.tags[42]=V.k0.parse;const oe="dag-json",ae=297,ce=e=>Y(e,se),le=e=>{const t=Object.assign(ie,{tokenizer:new ne(e,ie)});return X(e,t)};function ue(e){return z.base64url.encode(e).slice(1)}function he(e){return z.base64url.decode(`u${e}`)}function de(e){const[t,r,s]=e;return{payload:r,signatures:[{protected:t,signature:s}],link:A.CID.decode(he(r))}}function pe(e){const t={signature:he(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=he(e.protected)),t}function fe(e){const t=he(e.payload);try{A.CID.decode(t)}catch(r){throw new Error("Not a valid DagJWS")}return{payload:t,signatures:e.signatures.map(pe)}}function ye(e){const t={signature:ue(e.signature)};return e.header&&(t.header=e.header),e.protected&&(t.protected=ue(e.protected)),t}function ge(e){const t={payload:ue(e.payload),signatures:e.signatures.map(ye)};return t.link=A.CID.decode(new Uint8Array(e.payload)),t}function me(e){const[t,r,s,n,i]=e,o={ciphertext:n,iv:s,protected:t,tag:i};return r&&(o.recipients=[{encrypted_key:r}]),o}function we(e){const t={};return e.encrypted_key&&(t.encrypted_key=he(e.encrypted_key)),e.header&&(t.header=e.header),t}function be(e){const t={ciphertext:he(e.ciphertext),protected:he(e.protected),iv:he(e.iv),tag:he(e.tag)};return e.aad&&(t.aad=he(e.aad)),e.recipients&&(t.recipients=e.recipients.map(we)),e.unprotected&&(t.unprotected=e.unprotected),t}function _e(e){const t={};return e.encrypted_key&&(t.encrypted_key=ue(e.encrypted_key)),e.header&&(t.header=e.header),t}function Ee(e){const t={ciphertext:ue(e.ciphertext),protected:ue(e.protected),iv:ue(e.iv),tag:ue(e.tag)};return e.aad&&(t.aad=ue(e.aad)),e.recipients&&(t.recipients=e.recipients.map(_e)),e.unprotected&&(t.unprotected=e.unprotected),t}const ve="dag-jose",Se=133;function Ie(e){return"payload"in e&&"string"===typeof e.payload&&"signatures"in e&&Array.isArray(e.signatures)}function ke(e){return"payload"in e&&e.payload instanceof Uint8Array&&"signatures"in e&&Array.isArray(e.signatures)}function Re(e){return"ciphertext"in e&&e.ciphertext instanceof Uint8Array&&"iv"in e&&e.iv instanceof Uint8Array&&"protected"in e&&e.protected instanceof Uint8Array&&"tag"in e&&e.tag instanceof Uint8Array}function Te(e){return"ciphertext"in e&&"string"===typeof e.ciphertext&&"iv"in e&&"string"===typeof e.iv&&"protected"in e&&"string"===typeof e.protected&&"tag"in e&&"string"===typeof e.tag}function Ae(e){if("string"===typeof e){const t=e.split(".");if(3===t.length)return de(t);if(5===t.length)return me(t);throw new Error("Not a valid JOSE string")}if(Ie(e)||Te(e))return e;throw new Error("Not a valid unencoded JOSE object")}function Ce(e){let t;if("string"===typeof e&&(e=Ae(e)),Ie(e))t=fe(e);else{if(!Te(e))throw new Error("Not a valid JOSE object");t=be(e)}return new Uint8Array(U(t))}function Pe(e){let t;try{t=j(e)}catch(r){throw new Error("Not a valid DAG-JOSE object")}if(ke(t))return ge(t);if(Re(t))return Ee(t);throw new Error("Not a valid DAG-JOSE object")}var De=r(78103),Ne=r(58404);function Oe(){}class Le extends Error{constructor(e="not initialized"){super(e),this.name="NotInitializedError",this.code=Le.code}}Le.code="ERR_NOT_INITIALIZED";class xe extends Error{constructor(e="cannot initialize an initializing node"){super(e),this.name="AlreadyInitializingError",this.code=Me.code}}xe.code="ERR_ALREADY_INITIALIZING";class Me extends Error{constructor(e="cannot re-initialize an initialized node"){super(e),this.name="AlreadyInitializedError",this.code=Me.code}}Me.code="ERR_ALREADY_INITIALIZED";class Be extends Error{constructor(e="not started"){super(e),this.name="NotStartedError",this.code=Be.code}}Be.code="ERR_NOT_STARTED";class Ue extends Error{constructor(e="cannot start, already startin"){super(e),this.name="AlreadyStartingError",this.code=Ue.code}}Ue.code="ERR_ALREADY_STARTING";class je extends Error{constructor(e="cannot start, already started"){super(e),this.name="AlreadyStartedError",this.code=je.code}}je.code="ERR_ALREADY_STARTED";class Ve extends Error{constructor(e="not enabled"){super(e),this.name="NotEnabledError",this.code=Ve.code}}Ve.code="ERR_NOT_ENABLED";var ze=r(52217),Fe=r(10715),$e=r(99086),Ke=r(22817),He=r(28924),qe=r(9824),Ge=r(76237),We=r(17745),Ye=r(92263);const Qe=/^\/(ip[fn]s)\/([^/?#]+)/,Ze=1,Xe=2,Je=/^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/,et=/^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;function tt(e){try{return nt(e)?Boolean(A.CID.parse(e)):e instanceof Uint8Array?Boolean(A.CID.decode(e)):Boolean(A.CID.asCID(e))}catch{return!1}}function rt(e,t,r=Ze,s=Xe){const n=it(e);if(!1===n)return!1;const i=n.match(t);if(null==i)return!1;if("ipfs"!==i[r])return!1;let o=i[s];return null!=o&&t===Je&&(o=o.toLowerCase()),tt(o)}function st(e,t,r=Ze,s=Xe){const n=it(e);if(!1===n)return!1;const i=n.match(t);if(null==i)return!1;if("ipns"!==i[r])return!1;let o=i[s];if(null!=o&&t===Je){if(o=o.toLowerCase(),tt(o))return!0;try{!o.includes(".")&&o.includes("-")&&(o=o.replace(/--/g,"@").replace(/-/g,".").replace(/@/g,"-"));const{hostname:e}=new We.URL(`http://${o}`);return et.test(e)}catch(a){return!1}}return!0}function nt(e){return"string"===typeof e}function it(e){return e instanceof Uint8Array?(0,Ye.B)(e,"base58btc"):!!nt(e)&&e}const ot=e=>rt(e,Qe)||st(e,Qe),at=e=>rt(e,Qe),ct=e=>st(e,Qe);var lt=r(73830),ut=r(32044);let ht=/(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/giu;function dt(e="",t="ms"){var r=null;return e=(e+"").replace(/(\d)[,_](\d)/g,"$1$2"),e.replace(ht,(function(e,t,s){s=pt(s),s&&(r=(r||0)+parseFloat(t,10)*s)})),r&&r/(pt(t)||1)}function pt(e){return dt[e]||dt[e.toLowerCase().replace(/s$/,"")]}dt.nanosecond=dt.ns=1e-6,dt["s"]=dt["s"]=dt.us=dt.microsecond=.001,dt.millisecond=dt.ms=dt[""]=1,dt.second=dt.sec=dt.s=1e3*dt.ms,dt.minute=dt.min=dt.m=60*dt.s,dt.hour=dt.hr=dt.h=60*dt.m,dt.day=dt.d=24*dt.h,dt.week=dt.wk=dt.w=7*dt.d,dt.month=dt.b=30.4375*dt.d,dt.year=dt.yr=dt.y=365.25*dt.d;var ft=dt;class yt extends Error{constructor(e="request timed out"){super(e),this.name="TimeoutError",this.code=yt.code}}function gt(e,t){return(...r)=>{const s=r[null==t?r.length-1:t];if(!s||!s.timeout)return e(...r);const n="string"===typeof s.timeout?ft(s.timeout):s.timeout,i=new Fe.TimeoutController(n);s.signal=(0,ut.anySignal)([s.signal,i.signal]);const o=e(...r),a=new Promise(((e,t)=>{i.signal.addEventListener("abort",(()=>{t(new yt)}))})),c=Date.now(),l=()=>{if(i.signal.aborted)throw new yt;const e=Date.now()-c;if(e>n)throw i.abort(),new yt};return o[Symbol.asyncIterator]?async function*(){const e=o[Symbol.asyncIterator]();try{while(1){const{value:t,done:r}=await Promise.race([e.next(),a]);if(r)break;l(),yield t}}catch(mu){throw l(),mu}finally{i.clear(),e.return&&e.return()}}():(async()=>{try{const e=await Promise.race([o,a]);return l(),e}catch(mu){throw l(),mu}finally{i.clear()}})()}}yt.code="ERR_TIMEOUT";const mt="/ipfs/";function wt(e){if(e instanceof Uint8Array)try{e=A.CID.decode(e)}catch(mu){throw h(mu,"ERR_INVALID_CID")}let t=A.CID.asCID(e);if(t)return{cid:t,path:void 0};e=e.toString(),e.startsWith(mt)&&(e=e.substring(mt.length));const r=e.split("/");let s;try{t=A.CID.parse(r.shift()||"")}catch(mu){throw h(mu,"ERR_INVALID_CID")}return r.length&&(s=`/${r.join("/")}`),{cid:t,path:s}}const bt="ERR_BAD_PATH",_t="This command must be run in online mode. Try running 'ipfs daemon' first.",Et=new lt.s("/local/filesroot"),vt=262144,St=e=>{const t=A.CID.asCID(e);if(t)return`/ipfs/${e}`;const r=e.toString();try{return`/ipfs/${A.CID.parse(r)}`}catch{}if(ot(r))return r;throw h(new Error(`invalid path: ${e}`),bt)},It=e=>e instanceof Uint8Array?A.CID.decode(e).toString():(e=e.toString(),0===e.indexOf("/ipfs/")&&(e=e.substring("/ipfs/".length)),"/"===e.charAt(e.length-1)&&(e=e.substring(0,e.length-1)),e),kt=async function(e,t,r,s={}){const{cid:n,path:i}=wt(r);i&&(s.path=i);let o=n,a=s.path||"";if(a.startsWith("/")&&(a=a.substring(1)),s.path)try{for await(const{value:r,remainderPath:i}of At(n,s.path,t,e,{signal:s.signal})){if(!A.CID.asCID(r))break;a=i,o=r}}catch(mu){throw mu.message.startsWith("Object has no property")&&(mu.message=`no link named "${a.split("/")[0]}" under ${o}`,mu.code="ERR_NO_LINK"),mu}return{cid:o,remainderPath:a||""}},Rt=e=>{if("file"!==e.type&&"directory"!==e.type&&"raw"!==e.type)throw new Error(`Unknown node type '${e.type}'`);const t={cid:e.cid,path:e.path,name:e.name,size:e.size,type:"file"};return"directory"===e.type&&(t.type="dir"),"file"===e.type&&(t.size=e.unixfs.fileSize()),"file"!==e.type&&"directory"!==e.type||(t.mode=e.unixfs.mode,void 0!==e.unixfs.mtime&&(t.mtime=e.unixfs.mtime)),t},Tt=gt((async(e,t)=>await e)),At=async function*(e,t,r,s,n){const i=async e=>{const t=await r.getCodec(e.code),i=await s.blocks.get(e,n);return t.decode(i)},o=t.split("/").filter(Boolean);let a=await i(e),c=e;while(o.length){const r=o.shift();if(!r)throw h(new Error(`Could not resolve path "${t}"`),"ERR_INVALID_PATH");if(e.code===R.code&&Array.isArray(a.Links)){const e=a.Links.find((e=>e.Name===r));if(e){yield{value:e.Hash,remainderPath:o.join("/")},a=await i(e.Hash),c=e.Hash;continue}}if(!Object.prototype.hasOwnProperty.call(a,r))throw h(new Error(`no link named "${r}" under ${c}`),"ERR_NO_LINK");a=a[r],yield{value:a,remainderPath:o.join("/")},A.CID.asCID(a)&&(c=a,a=await i(a))}yield{value:a,remainderPath:""}};class Ct{static create({start:e,stop:t}){return new Ct(e,t)}static async start(e,t){const{state:r,activate:s}=e;switch(r.status){case"stopped":try{const r=s(t);e.state={status:"starting",ready:r};const n=await r;return e.state={status:"started",value:n},n}catch(n){throw e.state={status:"stopped"},n}case"starting":throw new Ue;case"started":throw new je;case"stopping":return await r.ready,await Ct.start(e,t);default:return Ct.panic(e)}}static async stop(e){const{state:t,deactivate:r}=e;switch(t.status){case"stopped":break;case"starting":try{await t.ready}catch(s){}return await Ct.stop(e);case"stopping":return await t.ready;case"started":r&&await r(t.value),e.state={status:"stopped"};break;default:Ct.panic(t)}}static try({state:e}){switch(e.status){case"started":return e.value;default:return null}}static async use({state:e},t){switch(e.status){case"started":return e.value;case"starting":return await Tt(e.ready,t);default:throw new Be}}static panic({state:e}){const t=JSON.stringify({status:e.status});throw RangeError(`Service in invalid state ${t}, should never happen if you see this please report a bug`)}constructor(e,t){this.activate=e,this.deactivate=t,this.state={status:"stopped"}}async use(e){return await Ct.use(this,e)}try(){return Ct.try(this)}}function Pt({network:e,preload:t,peerId:r,keychain:s,repo:n,ipns:i,mfsPreload:o,print:a,hashers:c,options:l}){const u=async()=>{const{libp2p:u}=await Ct.start(e,{peerId:r,repo:n,print:a,hashers:c,options:l});await Promise.all([i.startOnline({keychain:s,libp2p:u,peerId:r,repo:n}),t.start(),o.start()])};return u}function Dt({network:e,preload:t,ipns:r,repo:s,mfsPreload:n}){const i=async()=>{await Promise.all([t.stop(),r.stop(),n.stop()]),await Ct.stop(e),await s.close()};return i}var Nt=r(70248);class Ot{constructor(e){this.lru=Nt(e)}get(e){const t=this.lru.get(e);if(t)return t.expire&&t.expire<Date.now()?void this.lru.remove(e):t.value}set(e,t,r){this.lru.set(e,{value:t,expire:Date.now()+r})}has(e){const t=this.get(e);return!!t}remove(e){this.lru.remove(e)}clear(){this.lru.clear()}}var Lt=r(64008),xt=r(67137);const Mt=new Ot(1e3),Bt=6e4,Ut=Lt.Z["default"]?Lt.Z["default"]:Lt.Z,jt=new Ut({concurrency:4}),Vt=e=>{if(e.Path)return e.Path;throw new Error(e.Message)};async function zt(e,t){const r=async(e,t={})=>{const r=new URLSearchParams(t);r.set("arg",e);const s=r.toString();if(!t.nocache&&Mt.has(s)){const e=Mt.get(s);return Vt(e)}const n=await jt.add((async()=>{const e=await xt.get("https://ipfs.io/api/v0/dns",{searchParams:r}),t=new URL(e.url).search.slice(1),s=await e.json();return Mt.set(t,s,Bt),s}));return Vt(n)};return r(e,t)}function Ft(e){return e.endsWith(".eth")&&(e=e.replace(/.eth$/,".eth.link")),e}function $t(){const e=async(e,t={recursive:!0})=>{if("string"!==typeof e)throw new Error("Invalid arguments, domain must be a string");return e=Ft(e),zt(e,t)};return gt(e)}function Kt({network:e}){return()=>{const t=e.try();return null!=t&&Boolean(t.libp2p.isStarted())}}var Ht=r(23366);function qt({repo:e,codecs:t,bases:r,name:s}){async function n(n,i={}){if(!ot(n))throw new Error("invalid argument "+n);if(ct(n))for await(const e of s.resolve(n,i))n=e;const[,o,a,...c]=n.split("/"),l=i.cidBase?await r.getBase(i.cidBase):void 0,u=Gt(a);if(0===c.length){const e=l?l.encoder.encode(u):a;return`/${o}/${e}`}const h=A.CID.decode(u);n=c.join("/");const d=At(h,n,t,e,i);let p=h,f=n;for await(const e of d)A.CID.asCID(e.value)&&(p=e.value,f=e.remainderPath);return`/ipfs/${p.toString(l&&l.encoder)}${f?"/"+f:""}`}return gt(n)}function Gt(e){try{return(0,Ht.jE)(e).toBytes()}catch{return A.CID.parse(e).bytes}}var Wt=r(93093);function Yt({addAll:e}){return(t,r={})=>{let s;const n=A.CID.asCID(t);return s=e(n?[{cid:n,...r}]:[{path:t.toString(),...r}],r),Wt(s)}}async function*Qt(e){if(null===e||void 0===e)throw h(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT");const t=A.CID.asCID(e);if(t)yield Zt({cid:t});else{if(!(e instanceof String||"string"===typeof e)){if(null!=e.cid||null!=e.path)return yield Zt(e);if(Symbol.iterator in e){const t=e[Symbol.iterator](),r=t.next();if(r.done)return t;if(A.CID.asCID(r.value)||r.value instanceof String||"string"===typeof r.value){yield Zt({cid:r.value});for(const e of t)yield Zt({cid:e});return}if(null!=r.value.cid||null!=r.value.path){yield Zt(r.value);for(const e of t)yield Zt(e);return}throw h(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}if(Symbol.asyncIterator in e){const t=e[Symbol.asyncIterator](),r=await t.next();if(r.done)return t;if(A.CID.asCID(r.value)||r.value instanceof String||"string"===typeof r.value){yield Zt({cid:r.value});for await(const e of t)yield Zt({cid:e});return}if(null!=r.value.cid||null!=r.value.path){yield Zt(r.value);for await(const e of t)yield Zt(e);return}throw h(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}throw h(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}yield Zt({path:e})}}function Zt(e){const t=e.cid||`${e.path}`;if(!t)throw h(new Error("Unexpected input: Please path either a CID or an IPFS path"),"ERR_UNEXPECTED_INPUT");const r={path:t,recursive:!1!==e.recursive};return null!=e.metadata&&(r.metadata=e.metadata),r}const Xt={direct:"direct",recursive:"recursive",indirect:"indirect",all:"all"};function Jt({repo:e,codecs:t}){async function*r(r,s={}){const n=async function*(){for await(const{path:s,recursive:n,metadata:i}of Qt(r)){const{cid:r}=await kt(e,t,s),{reason:o}=await e.pins.isPinnedWithType(r,[Xt.recursive,Xt.direct]);if("recursive"===o&&!n)throw new Error(`${r} already pinned recursively`);n?await e.pins.pinRecursively(r,{metadata:i}):await e.pins.pinDirectly(r,{metadata:i}),yield r}},i=Boolean(s.lock);if(!i)return void(yield*n());const o=await e.gcLock.readLock();try{yield*n()}finally{o()}}return gt(r)}function er(e,t,r){const s={type:e,cid:t};return r&&(s.metadata=r),s}function tr({repo:e,codecs:t}){async function*r(r={}){let s=Xt.all;if(r.type&&(s=r.type,!Object.keys(Xt).includes(s)))throw h(new Error("Invalid pin type"),"ERR_INVALID_PIN_TYPE");if(r.paths){let n=!1;for await(const{path:i}of Qt(r.paths)){const{cid:r}=await kt(e,t,i),{reason:o,pinned:a,parent:c,metadata:l}=await e.pins.isPinnedWithType(r,s);if(!a)throw h(new Error(`path '${i}' is not pinned`),"ERR_NOT_PINNED");switch(o){case Xt.direct:case Xt.recursive:n=!0,yield er(o,r,l);break;default:n=!0,yield er(`${Xt.indirect} through ${c}`,r,l)}}if(!n)throw new Error("No match found")}else{if(s===Xt.recursive||s===Xt.all)for await(const{cid:t,metadata:r}of e.pins.recursiveKeys())yield er(Xt.recursive,t,r);if(s===Xt.indirect||s===Xt.all)for await(const t of e.pins.indirectKeys(r))yield er(Xt.indirect,t);if(s===Xt.direct||s===Xt.all)for await(const{cid:t,metadata:r}of e.pins.directKeys())yield er(Xt.direct,t,r)}}return gt(r)}function rr({rmAll:e}){async function t(t,r={}){const s=await Wt(e([{path:t,...r}],r));if(!s)throw new Error("CID expected");return s}return t}function sr({repo:e,codecs:t}){async function*r(r,s={}){const n=await e.gcLock.readLock();try{for await(const{path:s,recursive:n}of Qt(r)){const{cid:r}=await kt(e,t,s),{pinned:i,reason:o}=await e.pins.isPinnedWithType(r,Xt.all);if(!i)throw new Error(`${r} is not pinned`);switch(o){case Xt.recursive:if(!n)throw new Error(`${r} is pinned recursively`);await e.pins.unpin(r),yield r;break;case Xt.direct:await e.pins.unpin(r),yield r;break;default:throw new Error(`${r} is pinned indirectly under ${o}`)}}}finally{n()}}return gt(r)}class nr{constructor({codecs:e,repo:t}){const r=Jt({codecs:e,repo:t});this.addAll=r,this.add=Yt({addAll:r});const s=sr({codecs:e,repo:t});this.rmAll=s,this.rm=rr({rmAll:s}),this.ls=tr({codecs:e,repo:t}),this.remote={add:(e,t={})=>Promise.reject(new Error("Not implemented")),ls:async function*(e,t={}){return Promise.reject(new Error("Not implemented"))},rm:(e,t={})=>Promise.reject(new Error("Not implemented")),rmAll:(e,t={})=>Promise.reject(new Error("Not implemented")),service:{add:(e,t)=>Promise.reject(new Error("Not implemented")),rm:(e,t={})=>Promise.reject(new Error("Not implemented")),ls:(e={})=>Promise.reject(new Error("Not implemented"))}}}}var ir=r(682);function or(e){return e=e||new Error("Cannot open database"),h(e,"ERR_DB_OPEN_FAILED")}function ar(e){return e=e||new Error("Delete failed"),h(e,"ERR_DB_DELETE_FAILED")}function cr(e){return e=e||new Error("Write failed"),h(e,"ERR_DB_WRITE_FAILED")}function lr(e){return e=e||new Error("Not Found"),h(e,"ERR_NOT_FOUND")}var ur=r(19588),hr=r(84957),dr=r(58320);const pr="ERR_IPNS_EXPIRED_RECORD",fr="ERR_UNRECOGNIZED_VALIDITY",yr="ERR_SIGNATURE_CREATION",gr="ERR_SIGNATURE_VERIFICATION",mr="ERR_UNRECOGNIZED_FORMAT",wr="ERR_UNDEFINED_PARAMETER",br="ERR_INVALID_RECORD_DATA",_r="ERR_INVALID_EMBEDDED_KEY",Er="ERR_MISSING_PRIVATE_KEY";var vr,Sr=r(25029);(function(e){let t,r,s;(function(e){e["EOL"]="EOL"})(t=e.ValidityType||(e.ValidityType={})),function(e){e[e["EOL"]=0]="EOL"}(r||(r={})),function(e){e.codec=()=>(0,Sr.Ji)(r)}(t=e.ValidityType||(e.ValidityType={})),e.codec=()=>(null==s&&(s=(0,Sr.yw)(((t,r,s={})=>{!1!==s.lengthDelimited&&r.fork(),null!=t.value&&(r.uint32(10),r.bytes(t.value)),null!=t.signature&&(r.uint32(18),r.bytes(t.signature)),null!=t.validityType&&(r.uint32(24),e.ValidityType.codec().encode(t.validityType,r)),null!=t.validity&&(r.uint32(34),r.bytes(t.validity)),null!=t.sequence&&(r.uint32(40),r.uint64(t.sequence)),null!=t.ttl&&(r.uint32(48),r.uint64(t.ttl)),null!=t.pubKey&&(r.uint32(58),r.bytes(t.pubKey)),null!=t.signatureV2&&(r.uint32(66),r.bytes(t.signatureV2)),null!=t.data&&(r.uint32(74),r.bytes(t.data)),!1!==s.lengthDelimited&&r.ldelim()}),((t,r)=>{const s={},n=null==r?t.len:t.pos+r;while(t.pos<n){const r=t.uint32();switch(r>>>3){case 1:s.value=t.bytes();break;case 2:s.signature=t.bytes();break;case 3:s.validityType=e.ValidityType.codec().decode(t);break;case 4:s.validity=t.bytes();break;case 5:s.sequence=t.uint64();break;case 6:s.ttl=t.uint64();break;case 7:s.pubKey=t.bytes();break;case 8:s.signatureV2=t.bytes();break;case 9:s.data=t.bytes();break;default:t.skipType(7&r);break}}return s}))),s),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(vr||(vr={}));var Ir=r(20605);const kr=(0,u.kg)("ipns:utils"),Rr=(0,ze.m)("/ipns/");function Tr(e){const t=new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),r=String(e).trim().match(t);if(null==r)throw new Error("Invalid format");const s=parseInt(r[1],10),n=parseInt(r[2],10)-1,i=parseInt(r[3],10),o=parseInt(r[4],10),a=parseInt(r[5],10),c=parseInt(r[6],10),l=parseInt(r[7].slice(0,-6),10);return new Date(Date.UTC(s,n,i,o,a,c,l))}const Ar=async(e,t)=>{if(null==t||null==e){const e=new Error("one or more of the provided parameters are not defined");throw kr.error(e),h(e,wr)}let r;if(null!=t.pubKey){try{r=(0,dr.unmarshalPublicKey)(t.pubKey)}catch(mu){throw kr.error(mu),mu}const s=await(0,Ht.y5)(t.pubKey);if(!s.equals(e))throw h(new Error("Embedded public key did not match PeerID"),_r)}else null!=e.publicKey&&(r=(0,dr.unmarshalPublicKey)(e.publicKey));if(null!=r)return r;throw h(new Error("no public key is available"),wr)},Cr=(e,t,r)=>{const s=(0,ze.m)(t);return(0,Ir.concat)([e,r,s])},Pr=e=>{const t=(0,ze.m)("ipns-signature:");return(0,Ir.concat)([t,e])},Dr=e=>vr.encode(e),Nr=e=>{const t=vr.decode(e);return null!=t.sequence&&(t.sequence=BigInt(t.sequence)),null!=t.ttl&&(t.ttl=BigInt(t.ttl)),{value:t.value??new Uint8Array(0),signature:t.signature??new Uint8Array(0),validityType:t.validityType??vr.ValidityType.EOL,validity:t.validity??new Uint8Array(0),sequence:t.sequence??0n,pubKey:t.pubKey,ttl:t.ttl??void 0,signatureV2:t.signatureV2,data:t.data}},Or=e=>(0,Ir.concat)([Rr,e.toBytes()]),Lr=e=>(0,Ht.cv)(e.slice(Rr.length)),xr=(e,t,r,s,n)=>{let i;if(r!==vr.ValidityType.EOL)throw h(new Error("Unknown validity type"),fr);i=0;const o={Value:e,Validity:t,ValidityType:i,Sequence:s,TTL:n};return T.cv(o)},Mr=e=>{const t=T.Jx(e);if(0!==t.ValidityType)throw h(new Error("Unknown validity type"),fr);return t.ValidityType=vr.ValidityType.EOL,Number.isInteger(t.Sequence)&&(t.Sequence=BigInt(t.Sequence)),Number.isInteger(t.TTL)&&(t.TTL=BigInt(t.TTL)),t},Br=(0,u.kg)("ipns"),Ur=De.identity.code,jr="/ipns/",Vr=jr.length,zr=async(e,t,r,s)=>{const n=new hr(Date.now()+Number(s)),i=vr.ValidityType.EOL,[o,a]=s.toString().split("."),c=BigInt(o)*BigInt(1e5)+BigInt(a??"0");return await Fr(e,t,r,i,n,c)},Fr=async(e,t,r,s,n,i)=>{r=BigInt(r);const o=(0,ze.m)(n.toString());if(null==e.privateKey)throw h(new Error("Missing private key"),Er);const a=await(0,dr.unmarshalPrivateKey)(e.privateKey),c=await Hr(a,t,s,o),l=xr(t,o,s,r,i),u=Pr(l),d=await a.sign(u),p={value:t,signature:c,validityType:s,validity:o,sequence:r,ttl:i,signatureV2:d,data:l};if(null!=e.publicKey){const t=He.Jx(e.toBytes());t.code===Ur&&(0,ur.f)(e.publicKey,t.digest)||(p.pubKey=e.publicKey)}return Br("ipns entry for %b created",t),p},$r=e=>Ke.base32upper.encode(e).slice(1),Kr=e=>new lt.s(`/ipns/${$r(e)}`),Hr=async(e,t,r,s)=>{try{const n=Cr(t,r,s);return await e.sign(n)}catch(n){throw Br.error("record signature creation failed",n),h(new Error("record signature creation failed"),yr)}},qr=(0,u.kg)("ipfs:ipns:publisher"),Gr=lr().code,Wr=36e5;class Yr{constructor(e,t){this._routing=e,this._datastore=t}async publishWithEOL(e,t,r,s){const n=await this._updateOrCreateRecord(e,t,r,s);return this._putRecordToRouting(n,e,s)}publish(e,t,r){return this.publishWithEOL(e,t,Wr,r)}async _putRecordToRouting(e,t,r){if(!(0,ir.I)(t)){const e="peerId received is not valid";throw qr.error(e),h(new Error(e),"ERR_INVALID_PEER_ID")}if(null==t.publicKey)throw h(new Error("Public key was missing"),"ERR_MISSING_PUBLIC_KEY");const s=Or(t);return await this._publishEntry(s,e,r),e}async _publishEntry(e,t,r){try{const s=await this._routing.put(e,t,r);return qr(`ipns record for ${(0,Ye.B)(e,"base32")} was stored in the routing`),s}catch(mu){const r=`ipns record for ${(0,Ye.B)(e,"base32")} could not be stored in the routing - ${mu.stack}`;throw qr.error(r),qr.error(mu),h(new Error(r),"ERR_PUTTING_TO_ROUTING")}}async _getPublished(e,t={}){if(!(0,ir.I)(e)){const e="peerId received is not valid";throw qr.error(e),h(new Error(e),"ERR_INVALID_PEER_ID")}const r=!1!==t.checkRouting;try{const t=await this._datastore.get(Kr(e.toBytes()));return this._unmarshalData(t)}catch(mu){if(mu.code!==Gr){const t=`unexpected error getting the ipns record ${e.toString()} from datastore`;throw qr.error(t),h(new Error(t),"ERR_UNEXPECTED_DATASTORE_RESPONSE")}if(!r)throw h(mu,"ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");try{const t=Or(e),r=await this._routing.get(t);return this._unmarshalData(r)}catch(mu){throw qr.error(mu),mu}}}_unmarshalData(e){try{return Nr(e)}catch(mu){throw h(mu,"ERR_INVALID_RECORD_DATA")}}async _updateOrCreateRecord(e,t,r,s){if(!(0,ir.I)(e)){const e="peerId received is not valid";throw qr.error(e),h(new Error(e),"ERR_INVALID_PEER_ID")}const n={checkRouting:!0};let i;try{i=await this._getPublished(e,n)}catch(mu){if(mu.code!==Gr){const r=`unexpected error when determining the last published IPNS record for ${e.toString()} ${mu.stack}`;throw qr.error(r),h(new Error(r),"ERR_DETERMINING_PUBLISHED_RECORD")}}let o,a=0n;i&&void 0!==i.sequence&&(a=(0,ur.f)(i.value,t)?i.sequence:i.sequence+BigInt(1));try{o=await zr(e,t,a,r)}catch(mu){const r=`ipns record for ${t} could not be created`;throw qr.error(mu),h(new Error(r),"ERR_CREATING_IPNS_RECORD")}try{const r=Dr(o);return await this._datastore.put(Kr(e.toBytes()),r,s),qr(`ipns record for ${(0,Ye.B)(t,"base32")} was stored in the datastore`),r}catch(mu){const r=`ipns record for ${t} could not be stored in the datastore`;throw qr.error(r),h(new Error(r),"ERR_STORING_IN_DATASTORE")}}}Yr.defaultRecordLifetime=Wr;const Qr=(0,u.kg)("ipfs:ipns:republisher"),Zr=6e4,Xr=60*Zr,Jr=4*Xr,es=24*Xr;class ts{constructor(e,t,r,s,n={pass:""}){this._publisher=e,this._datastore=t,this._peerId=r,this._keychain=s,this._options=n,this._republishHandle=null}async start(){if(this._republishHandle)throw h(new Error("republisher is already running"),"ERR_REPUBLISH_ALREADY_RUNNING");const e={_task:null,_inflightTask:null,_timeoutId:null,runPeriodically:t=>{e._timeoutId=setTimeout((async()=>{e._timeoutId=null;try{e._inflightTask=e._task(),await e._inflightTask,e._task&&e.runPeriodically(t)}catch(mu){Qr.error(mu)}}),t())},cancel:async()=>{null!=e._timeoutId&&clearTimeout(e._timeoutId),e._task=null,await e._inflightTask}},{pass:t}=this._options;let r=!0;e._task=async()=>{const e=new Fe.TimeoutController(3e4);try{await this._republishEntries(this._peerId,t,{signal:e.signal})}finally{e.clear()}},e.runPeriodically((()=>r?(r=!1,this._options.initialBroadcastInterval||Zr):this._options.broadcastInterval||Jr)),this._republishHandle=e}async stop(){const e=this._republishHandle;if(!e)throw h(new Error("republisher is not running"),"ERR_REPUBLISH_NOT_RUNNING");this._republishHandle=null,await e.cancel()}async _republishEntries(e,t,r){try{await this._republishEntry(e,r)}catch(mu){const t="cannot republish entry for the node's private key";return void Qr.error(t)}if(t)try{const e=await this._keychain.listKeys();for(const s of e){if("self"===s.name)continue;const e=await this._keychain.exportKey(s.name,t),n=await(0,dr.importKey)(e,t),i=await(0,Ht.y5)(n.public.bytes,n.bytes);await this._republishEntry(i,r)}}catch(mu){Qr.error(mu)}}async _republishEntry(e,t){try{const r=await this._getPreviousValue(e);await this._publisher.publishWithEOL(e,r,es,t)}catch(mu){if("ERR_NO_ENTRY_FOUND"===mu.code)return;throw mu}}async _getPreviousValue(e){if(!(0,ir.I)(e))throw h(new Error("invalid peer ID"),"ERR_INVALID_PEER_ID");try{const t=await this._datastore.get(Kr(e.toBytes()));if(!(t instanceof Uint8Array))throw h(new Error("found ipns record that we couldn't process"),"ERR_INVALID_IPNS_RECORD");try{const e=Nr(t);return e.value}catch(mu){throw Qr.error(mu),h(new Error("found ipns record that we couldn't convert to a value"),"ERR_INVALID_IPNS_RECORD")}}catch(mu){if(mu&&mu.notFound)throw h(new Error(`no previous entry for record with id: ${e.toString()}`),"ERR_NO_ENTRY_FOUND");throw mu}}}const rs=(0,u.kg)("ipns:validator"),ss=async(e,t)=>{const{value:r,validityType:s,validity:n}=t;let i,o,a;null!=t.signatureV2&&null!=t.data?(o=t.signatureV2,i=Pr(t.data),ns(t)):(o=t.signature??new Uint8Array(0),i=Cr(r,s,n));try{a=await e.verify(i,o)}catch(mu){a=!1}if(!a)throw rs.error("record signature verification failed"),h(new Error("record signature verification failed"),gr);if(null!=n&&s===vr.ValidityType.EOL){let e;try{e=Tr((0,Ye.B)(n))}catch(c){throw rs.error("unrecognized validity format (not an rfc3339 format)"),h(new Error("unrecognized validity format (not an rfc3339 format)"),mr)}if(e.getTime()<Date.now())throw rs.error("record has expired"),h(new Error("record has expired"),pr)}else if(null!=s)throw rs.error("unrecognized validity type"),h(new Error("unrecognized validity type"),fr);rs("ipns entry for %b is valid",r)},ns=e=>{if(null==e.data)throw h(new Error("Record data is missing"),br);const t=Mr(e.data);if(!(0,ur.f)(t.Value,e.value))throw h(new Error('Field "value" did not match between protobuf and CBOR'),gr);if(!(0,ur.f)(t.Validity,e.validity))throw h(new Error('Field "validity" did not match between protobuf and CBOR'),gr);if(t.ValidityType!==e.validityType)throw h(new Error('Field "validityType" did not match between protobuf and CBOR'),gr);if(t.Sequence!==e.sequence)throw h(new Error('Field "sequence" did not match between protobuf and CBOR'),gr);if(t.TTL!==e.ttl)throw h(new Error('Field "ttl" did not match between protobuf and CBOR'),gr)},is=async(e,t)=>{const r=Lr(e),s=Nr(t),n=await Ar(r,s);await ss(n,s)},os=(0,u.kg)("ipfs:ipns:resolver"),as=lr().code,cs=32;class ls{constructor(e){this._routing=e}async resolve(e,t={}){if("string"!==typeof e)throw h(new Error("invalid name"),"ERR_INVALID_NAME");const r=t.recursive&&"true"===t.recursive.toString(),s=e.split("/");if(3!==s.length||""!==s[0])throw h(new Error("invalid name"),"ERR_INVALID_NAME");const n=s[2];let i=1/0;r&&(i=cs);const o=await this.resolver(n,i,t);return os(`${e} was locally resolved correctly`),o}async resolver(e,t,r){if(0===t){const e=`could not resolve name (recursion limit of ${cs} exceeded)`;throw os.error(e),h(new Error(e),"ERR_RESOLVE_RECURSION_LIMIT")}const s=await this._resolveName(e,r),n=s.split("/");return"ipfs"!==n[1]&&t?this.resolver(n[2],t-1,r):s}async _resolveName(e,t){const r=(0,Ht.jE)(e),s=Or(r);let n;try{n=await this._routing.get(s,t)}catch(mu){if(os.error("could not get record from routing",mu),mu.code===as)throw h(new Error(`record requested for ${e} was not found in the network`),"ERR_NO_RECORD_FOUND");throw h(new Error(`unexpected error getting the ipns record ${r.toString()}`),"ERR_UNEXPECTED_ERROR_GETTING_RECORD")}return this._validateRecord(r,n)}async _validateRecord(e,t){await is((0,Ir.concat)([(0,ze.m)("/ipns/"),e.toBytes()]),t);const r=Nr(t);return(0,Ye.B)(r.value)}}class us{constructor(e){this.lru=Nt(e)}get(e){const t=this.lru.get(e);if(t)return t.expire&&t.expire<Date.now()?void this.lru.remove(e):t.value}set(e,t,r){this.lru.set(e,{value:t,expire:Date.now()+r})}has(e){const t=this.get(e);return!!t}remove(e){this.lru.remove(e)}clear(){this.lru.clear()}}const hs=(0,u.kg)("ipfs:ipns"),ds=6e4;class ps{constructor(e,t,r,s,n){this.publisher=new Yr(e,t),this.republisher=new ts(this.publisher,t,r,s,n),this.resolver=new ls(e),this.cache=new us(1e3),this.routing=e}async publish(e,t,r=Yr.defaultRecordLifetime,s){try{await this.publisher.publishWithEOL(e,t,r,s),hs(`IPNS value ${(0,Ye.B)(t,"base32")} was published correctly`);const n=e.toString(),i=parseFloat(r),o=i<ds?i:ds;return this.cache.set(n,t,o),hs(`IPNS value ${(0,Ye.B)(t,"base32")} was cached correctly`),{name:n,value:t}}catch(mu){throw hs.error(mu),mu}}async resolve(e,t={}){if("string"!==typeof e)throw h(new Error("name received is not valid"),"ERR_INVALID_NAME");if(!t.nocache&&!t.recursive){const t=e.split("/")[2],r=this.cache.get(t);if(r)return r}try{const r=await this.resolver.resolve(e,t);return hs(`IPNS record from ${e} was resolved correctly`),r}catch(mu){throw hs.error(mu),mu}}async initializeKeyspace(e,t,r){return this.publish(e,t,Yr.defaultRecordLifetime,r)}}var fs=r(31303);const ys=(e,t)=>async function*(){const r=await fs(e);yield*r.sort(t)}();var gs=r(64593),ms=r(55565),ws=r(37939);class bs{open(){return Promise.reject(new Error(".open is not implemented"))}close(){return Promise.reject(new Error(".close is not implemented"))}put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:s}of e)await this.put(r,s,t),yield{key:r,value:s}}async*getMany(e,t={}){for await(const r of e)yield this.get(r,t)}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(t,r){e.push({key:t,value:r})},delete(e){t.push(e)},commit:async r=>{await gs(this.putMany(e,r)),e=[],await gs(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(null!=e.prefix&&(r=ms(r,(t=>t.key.toString().startsWith(e.prefix)))),Array.isArray(e.filters)&&(r=e.filters.reduce(((e,t)=>ms(e,t)),r)),Array.isArray(e.orders)&&(r=e.orders.reduce(((e,t)=>ys(e,t)),r)),null!=e.offset){let t=0;r=ms(r,(()=>t++>=e.offset))}return null!=e.limit&&(r=ws(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(null!=e.prefix&&(r=ms(r,(t=>t.toString().startsWith(e.prefix)))),Array.isArray(e.filters)&&(r=e.filters.reduce(((e,t)=>ms(e,t)),r)),Array.isArray(e.orders)&&(r=e.orders.reduce(((e,t)=>ys(e,t)),r)),null!=e.offset){let t=0;r=ms(r,(()=>t++>=e.offset))}return null!=e.limit&&(r=ws(r,e.limit)),r}}var _s=r(94106);const Es=(0,u.kg)("datastore:core:tiered");class vs extends bs{constructor(e){super(),this.stores=e.slice()}async open(){try{await Promise.all(this.stores.map((e=>e.open())))}catch(mu){throw or()}}async put(e,t,r){try{await Promise.all(this.stores.map((s=>s.put(e,t,r))))}catch(mu){throw cr()}}async get(e,t){for(const r of this.stores)try{const s=await r.get(e,t);if(s)return s}catch(mu){Es.error(mu)}throw lr()}async has(e,t){for(const r of this.stores)if(await r.has(e,t))return!0;return!1}async delete(e,t){try{await Promise.all(this.stores.map((r=>r.delete(e,t))))}catch(mu){throw ar()}}async*putMany(e,t={}){let r;const s=this.stores.map((e=>{const s=(0,_s.d)({objectMode:!0});return gs(e.putMany(s,t)).catch((e=>{r=e})),s}));try{for await(const t of e){if(r)throw r;s.forEach((e=>e.push(t))),yield t}}finally{s.forEach((e=>e.end()))}}async*deleteMany(e,t={}){let r;const s=this.stores.map((e=>{const s=(0,_s.d)({objectMode:!0});return gs(e.deleteMany(s,t)).catch((e=>{r=e})),s}));try{for await(const t of e){if(r)throw r;s.forEach((e=>e.push(t))),yield t}}finally{s.forEach((e=>e.end()))}}async close(){await Promise.all(this.stores.map((e=>e.close())))}batch(){const e=this.stores.map((e=>e.batch()));return{put:(t,r)=>{e.forEach((e=>e.put(t,r)))},delete:t=>{e.forEach((e=>e.delete(t)))},commit:async t=>{for(const r of e)await r.commit(t)}}}query(e,t){return this.stores[this.stores.length-1].query(e,t)}queryKeys(e,t){return this.stores[this.stores.length-1].queryKeys(e,t)}}var Ss=r(26905);const Is=(e,t)=>{const r=t.map(((e,t)=>({entry:vr.decode(e),index:t})));return r.sort(((e,t)=>{if(null!=e.entry.signatureV2&&null==t.entry.signatureV2)return-1;if(null==e.entry.signatureV2&&null!=t.entry.signatureV2)return 1;const r=e.entry.sequence??0n,s=t.entry.sequence??0n;if(r>s)return-1;if(r<s)return 1;const n=e.entry.validity??new Uint8Array(0),i=t.entry.validity??new Uint8Array(0),o=Tr((0,Ye.B)(n)),a=Tr((0,Ye.B)(i));return o.getTime()>a.getTime()?-1:o.getTime()<a.getTime()?1:0})),r[0].index},ks="SHARDING",Rs="_README";class Ts extends bs{constructor(){super(),this.data={}}open(){return Promise.resolve()}close(){return Promise.resolve()}async put(e,t){this.data[e.toString()]=t}async get(e){const t=await this.has(e);if(!t)throw lr();return this.data[e.toString()]}async has(e){return void 0!==this.data[e.toString()]}async delete(e){delete this.data[e.toString()]}async*_all(){yield*Object.entries(this.data).map((([e,t])=>({key:new lt.s(e),value:t})))}async*_allKeys(){yield*Object.entries(this.data).map((([e])=>new lt.s(e)))}}var As=r(32121),Cs=r(88211);new lt.s(ks),new lt.s(Rs);var Ps=r(74014);const Ds="/record/";function Ns(e){return(0,Ye.B)(e,"base32")}function Os(e){("string"===typeof e||e instanceof String)&&(e=(0,ze.m)(e.toString()));const t=(0,Ye.B)(e,"base64url");return`${Ds}${t}`}function Ls(e){if(e.substring(0,Ds.length)!==Ds)throw h(new Error("topic received is not from a record"),"ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");const t=e.substring(Ds.length);return(0,ze.m)(t,"base64url")}const xs=(0,u.kg)("datastore-pubsub:publisher");class Ms extends bs{constructor(e,t,r,s,n,i){if(super(),!s)throw h(new TypeError("missing validator"),"ERR_INVALID_PARAMETERS");if("function"!==typeof s)throw h(new TypeError("missing validate function"),"ERR_INVALID_PARAMETERS");if("function"!==typeof n)throw h(new TypeError("missing select function"),"ERR_INVALID_PARAMETERS");if(i&&"function"!==typeof i)throw h(new TypeError("invalid subscriptionKeyFn received"),"ERR_INVALID_PARAMETERS");this._pubsub=e,this._datastore=t,this._peerId=r,this._validator=s,this._selector=n,this._handleSubscriptionKeyFn=i,this._onMessage=this._onMessage.bind(this),this._pubsub.addEventListener("message",this._onMessage)}async put(e,t,r){if(!(e instanceof Uint8Array)){const e="datastore key does not have a valid format";throw xs.error(e),h(new Error(e),"ERR_INVALID_DATASTORE_KEY")}if(!(t instanceof Uint8Array)){const e="received value is not a Uint8Array";throw xs.error(e),h(new Error(e),"ERR_INVALID_VALUE_RECEIVED")}const s=Os(e);xs(`publish value for topic ${s}`),await this._pubsub.publish(s,t)}async get(e,t){if(!(e instanceof Uint8Array)){const e="datastore key does not have a valid format";throw xs.error(e),h(new Error(e),"ERR_INVALID_DATASTORE_KEY")}const r=Os(e),s=await this._pubsub.getTopics();if(s&&Array.isArray(s)&&s.indexOf(r)>-1)return this._getLocal(e,t);try{await this._pubsub.subscribe(r)}catch(mu){const t=`cannot subscribe topic ${r}`;throw xs.error(t),h(new Error(t),"ERR_SUBSCRIBING_TOPIC")}return xs(`subscribed values for key ${r}`),this._getLocal(e)}unsubscribe(e){const t=Os(e);return this._pubsub.unsubscribe(t)}async _getLocal(e,t){const r=new lt.s("/"+Ns(e),!1);let s;try{s=await this._datastore.get(r,t)}catch(mu){if("ERR_NOT_FOUND"!==mu.code){const e=`unexpected error getting the ipns record for ${r.toString()}`;throw xs.error(e),h(new Error(e),"ERR_UNEXPECTED_ERROR_GETTING_RECORD")}const t=`local record requested was not found for ${r.toString()}`;throw xs.error(t),h(new Error(t),"ERR_NOT_FOUND")}if(!(s instanceof Uint8Array)){const e="found record that we couldn't convert to a value";throw xs.error(e),h(new Error(e),"ERR_INVALID_RECORD_RECEIVED")}return s}async _onMessage(e){const t=e.detail;if("signed"!==t.type)return void xs.error("unsigned message received, this module can only work with signed messages");const{data:r,from:s,topic:n}=t;let i;try{i=Ls(n)}catch(mu){return void xs.error(mu)}if(xs(`message received for topic ${n}`),this._peerId.equals(s))xs("message discarded as it is from the same peer");else{if(this._handleSubscriptionKeyFn){let e;try{e=await this._handleSubscriptionKeyFn(i)}catch(mu){return void xs.error("message discarded by the subscriptionKeyFn")}i=e}try{await this._storeIfSubscriptionIsBetter(i,r)}catch(mu){xs.error(mu)}}}async _storeIfSubscriptionIsBetter(e,t,r){let s=!1;try{s=await this._isBetter(e,t)}catch(mu){if("ERR_NOT_VALID_RECORD"!==mu.code)throw mu}s&&await this._storeRecord(e,t,r)}async _validateRecord(e,t){return this._validator(e,t)}async _selectRecord(e,t){const r=await this._selector(e,t);return 0===r}async _isBetter(e,t){try{await this._validateRecord(e,t)}catch(mu){const t="record received through pubsub is not valid";throw xs.error(t),h(new Error(t),"ERR_NOT_VALID_RECORD")}const r=new lt.s(e);let s;try{s=await this._getLocal(r.uint8Array())}catch(mu){return!0}return!(0,ur.f)(s,t)&&this._selectRecord(e,[s,t])}async _storeRecord(e,t,r){const s=new lt.s("/"+Ns(e),!1);await this._datastore.put(s,t,r),xs(`record for ${Os(e)} was stored in the datastore`)}}const Bs=(0,u.kg)("ipfs:ipns:pubsub");class Us{constructor(e,t,r){this._subscriptions={},this._handleSubscriptionKey=this._handleSubscriptionKey.bind(this),this._pubsubDs=new Ms(e,t,r,is,Is,this._handleSubscriptionKey)}async put(e,t,r){try{await this._pubsubDs.put(e,t,r)}catch(mu){throw Bs.error(mu),mu}}async get(e,t){let r,s;try{r=await this._pubsubDs.get(e,t)}catch(i){s=i}const n=e.slice(0,Vr);if((0,Ye.B)(n)===jr){const t=$e.base58btc.encode(e).substring(1),r=$e.base58btc.encode(e.slice(Vr)).substring(1);this._subscriptions[t]=r,Bs(`subscribed to pubsub topic ${t}, id ${r}`)}if(s)throw s;return r}_handleSubscriptionKey(e){e instanceof Uint8Array&&(e=(0,Ye.B)(e,"base58btc"));const t=this._subscriptions[e];if(!t)throw h(new Error(`key ${e} does not correspond to a subscription`),"ERR_INVALID_KEY");try{const e=Or((0,Ht.jE)(t));return e}catch(mu){throw Bs.error(mu),mu}}getSubscriptions(){const e=Object.values(this._subscriptions).filter(Boolean);return e.map((e=>`${jr}${e}`))}async cancel(e){if("string"!==typeof e)throw h(new Error("invalid subscription name"),"ERR_INVALID_SUBSCRIPTION_NAME");e.startsWith(jr)&&(e=e.substring(Vr));const t=Object.keys(this._subscriptions).find((t=>this._subscriptions[t]===e));if(!t)return{canceled:!1};const r=(0,ze.m)(t);return this._pubsubDs.unsubscribe(r),delete this._subscriptions[t],Bs(`unsubscribed pubsub ${t}: ${e}`),{canceled:!0}}}var js=r(21347);const Vs=(0,u.kg)("ipfs:ipns:offline-datastore");class zs{constructor(e){this._datastore=e,this.stores=[]}async put(e,t,r){if(!(e instanceof Uint8Array))throw h(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");if(!(t instanceof Uint8Array))throw h(new Error("Offline datastore value must be a Uint8Array"),"ERR_INVALID_VALUE");let s;try{s=this._routingKey(e)}catch(mu){throw Vs.error(mu),h(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const n=new js.Y(e,t,new Date);await this._datastore.put(s,n.serialize(),r)}async get(e,t){if(!(e instanceof Uint8Array))throw h(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");let r;try{r=this._routingKey(e)}catch(mu){throw Vs.error(mu),h(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const s=await this._datastore.get(r,t);let n;try{n=js.Y.deserialize(s)}catch(mu){throw Vs.error(mu),mu}return n.value}_routingKey(e){return new lt.s("/dht/record/"+(0,Ye.B)(e,"base32"),!1)}}const Fs=(0,u.kg)("ipfs:ipns:dht-datastore");class $s{constructor(e){this._dht=e}async put(e,t,r){try{await gs(this._dht.put(e,t,r))}catch(mu){throw Fs.error(mu),mu}}async get(e,t){for await(const r of this._dht.get(e,t))if("VALUE"===r.name)return r.value;throw lr()}}function Ks({libp2p:e,repo:t,peerId:r,options:s}){const n=[];let i;if(Ss(s,"EXPERIMENTAL.ipnsPubsub",!1)&&(i=new Us(e.pubsub,t.datastore,r),n.push(i)),!0!==Ss(s,"offline",!1)&&["dht","dhtclient","dhtserver"].includes(Ss(s,"config.Routing.Type","none"))&&n.push(new $s(e.dht)),Ss(s,"offline",!1)||0===n.length){const e=new zs(t.datastore);n.push(e)}return new vs(n)}const Hs=(0,u.kg)("ipfs:components:ipns");class qs{constructor(e={pass:""}){this.options=e,this.offline=null,this.online=null}getIPNS(){const e=this.online||this.offline;if(e)return e;throw new Le}get routing(){return this.getIPNS().routing}startOffline({repo:e,peerId:t,keychain:r}){if(null!=this.offline)throw new Me;Hs("initializing IPNS keyspace (offline)");const s=new zs(e.datastore),n=new ps(s,e.datastore,t,r,this.options);this.offline=n}async startOnline({libp2p:e,repo:t,peerId:r,keychain:s}){if(null!=this.online)throw new Me;const n=Ks({libp2p:e,repo:t,peerId:r,options:this.options}),i=new ps(n,t.datastore,r,s,this.options);await i.republisher.start(),this.online=i}async stop(){const e=this.online;e&&(await e.republisher.stop(),this.online=null)}publish(e,t,r,s){return this.getIPNS().publish(e,t,r,s)}resolve(e,t){return this.getIPNS().resolve(e,t)}initializeKeyspace(e,t,r){return this.getIPNS().initializeKeyspace(e,t,r)}}async function Gs({ipns:e,repo:t,codecs:r},s,n){if(ct(s))return e.resolve(s);const{cid:i,path:o}=wt(s);await gs(At(i,o||"",r,t,n))}const Ws=(0,u.kg)("ipfs:name:publish");function Ys({ipns:e,repo:t,codecs:r,peerId:s,isOnline:n,keychain:i}){const o=async e=>{let t;if("self"===e&&null!=s.privateKey)t=await(0,dr.unmarshalPrivateKey)(s.privateKey);else try{const r=await i.exportKey(e,"temp");t=await(0,dr.importKey)(r,"temp")}catch(mu){throw Ws.error(mu),h(mu,"ERR_CANNOT_GET_KEY")}return(0,Ht.y5)(t.public.bytes,t.bytes)};async function a(s,i={}){const a=!(!1===i.resolve),c=i.lifetime||"24h",l=i.key||"self";if(!n())throw h(new Error(_t),"OFFLINE_ERROR");try{s=St(s)}catch(mu){throw Ws.error(mu),mu}let u=0;try{u=ft(c)||0,u=parseFloat(u.toFixed(6))}catch(mu){throw Ws.error(mu),mu}const d=await Promise.all([o(l),a?Gs({ipns:e,repo:t,codecs:r},s):Promise.resolve()]),p=(0,ze.m)(s),f=await e.publish(d[0],p,u,i);return{name:f.name,value:(0,Ye.B)(f.value)}}return gt(a)}var Qs=r(98441),Zs=r(82734);const Xs=c.Z.bind({ignoreUndefined:!0}),Js=(0,u.kg)("ipfs:name:resolve"),en=(e,t)=>t.length>0?e+"/"+t.join("/"):e;function tn({dns:e,ipns:t,isOnline:r,options:{offline:s}}){async function*n(n,i={}){if(i=Xs({nocache:!1,recursive:!0},i),s&&i&&i.nocache)throw h(new Error("cannot specify both offline and nocache"),"ERR_NOCACHE_AND_OFFLINE");if(!r()&&!s)throw h(new Error(_t),"OFFLINE_ERROR");let o=n.toString();o.startsWith("/ipns/")||(o=`/ipns/${o}`);let[a,c,...l]=o.slice(1).split("/");try{if("1"===c.substring(0,1)){const e=(0,Ht.jE)(c),t=He.Jx(e.toBytes()),r=A.CID.createV1(114,t);c=r.toString(Qs.base36)}else{const e=A.CID.parse(c);1===e.version&&(c=e.toString(Qs.base36))}}catch(mu){if(Zs(c))return void(yield en(await e(c,i),l));throw Js.error(mu),h(new Error("Invalid IPNS name"),"ERR_IPNS_INVALID_NAME")}const u=await t.resolve(`/${a}/${c}`,i);yield en(u instanceof Uint8Array?(0,Ye.B)(u):u,l)}return gt(n)}function rn(e,t){if(!e||!t||!t.ipnsPubsub)throw h(new Error("IPNS pubsub subsystem is not enabled"),"ERR_IPNS_PUBSUB_NOT_ENABLED");if(e.routing instanceof Us)return e.routing;const r=(e.routing.stores||[]).find((e=>e instanceof Us));if(!r)throw h(new Error("IPNS pubsub datastore not found"),"ERR_PUBSUB_DATASTORE_NOT_FOUND");return r}function sn({ipns:e,options:t}){const r=t.EXPERIMENTAL;async function s(t,s={}){const n=rn(e,r);return n.cancel(t,s)}return gt(s)}function nn({ipns:e,options:t}){const r=t.EXPERIMENTAL;async function s(t={}){try{return{enabled:Boolean(rn(e,r))}}catch(mu){return{enabled:!1}}}return gt(s)}function on({ipns:e,options:t}){const r=t.EXPERIMENTAL;async function s(t={}){const s=rn(e,r);return s.getSubscriptions(t)}return gt(s)}class an{constructor({ipns:e,options:t}){this.cancel=sn({ipns:e,options:t}),this.state=nn({ipns:e,options:t}),this.subs=on({ipns:e,options:t})}}class cn{constructor({dns:e,ipns:t,repo:r,codecs:s,peerId:n,isOnline:i,keychain:o,options:a}){this.publish=Ys({ipns:t,repo:r,codecs:s,peerId:n,isOnline:i,keychain:o}),this.resolve=tn({dns:e,ipns:t,isOnline:i,options:a}),this.pubsub=new an({ipns:t,options:a})}}const ln=lr().code,un={default:"<dst>",edges:"<src> -> <dst>"};function hn({repo:e,codecs:t,resolve:r,preload:s}){async function*n(n,i={}){if(0===i.maxDepth)return;if(i.edges&&i.format&&i.format!==un.default)throw new Error("Cannot set edges to true and also specify format");if(i.format=i.edges?un.edges:i.format,"number"!==typeof i.maxDepth&&(i.maxDepth=i.recursive?1/0:1),i.timeout){const e=new Fe.TimeoutController(i.timeout),t=[e.signal];i.signal&&t.push(i.signal),i.signal=(0,ut.anySignal)(t)}const o=Array.isArray(n)?n:[n],a=o.map((e=>dn(s,e,i)));for(const s of a)try{yield*pn(r,e,t,s,i)}catch(mu){yield{ref:"",err:mu.message}}}return n}function dn(e,t,r){const{cid:s,path:n}=wt(t);return!1!==r.preload&&e(s),`/ipfs/${s}${n||""}`}async function*pn(e,t,r,s,n){const i=await e(s,n),{cid:o}=wt(i),a=null!=n.maxDepth?n.maxDepth:1/0,c=n.unique||!1;for await(const l of yn(t,r,o,a,c,n))l.parent&&(l.isDuplicate||(yield{ref:fn(l.parent.cid,l.node.cid,l.node.name,n.format)}))}function fn(e,t,r="",s=un.default){let n=s.replace(/<src>/g,e.toString());return n=n.replace(/<dst>/g,t.toString()),n=n.replace(/<linkname>/g,r),n}async function*yn(e,t,r,s,n,i){const o=new Set;async function*a(r,c){const l=c+1;if(!(l>s))try{for await(const s of gn(e,t,r.cid,i))yield{parent:r,node:s,isDuplicate:n&&o.has(s.cid.toString())},n&&o.add(s.cid.toString()),yield*a(s,l)}catch(mu){throw mu.code===ln&&(mu.message=`Could not find object with CID: ${r.cid}`),mu}}yield*a({cid:r},0)}async function*gn(e,t,r,s){const n=await e.blocks.get(r,s),i=await t.getCodec(r.code),o=i.decode(n),a=r.code===R.code,c=[];for(const[l,u]of mn(o,c)){if(a){const e=l.match(/^Links\/(\d+)\/Hash$/);if(e){const t=Number(e[1]);if(t<o.Links.length){yield{name:o.Links[t].Name,cid:u};continue}}}yield{name:l,cid:u}}}const mn=function*(e,t){if(null!=e&&!(e instanceof Uint8Array)){for(const[r,s]of Object.entries(e)){const e=[...t,r];if(null!=s&&"object"===typeof s)if(Array.isArray(s))for(const[t,r]of s.entries()){const s=[...e,t],n=A.CID.asCID(r);n?yield[s.join("/"),n]:"object"===typeof r&&(yield*mn(r,s))}else{const t=A.CID.asCID(s);t?yield[e.join("/"),t]:yield*mn(s,e)}}return[]}};function wn({repo:e}){async function*t(t={}){for await(const r of e.blocks.queryKeys({},{signal:t.signal}))yield{ref:r.toString()}}return gt(t)}function bn({network:e}){async function t(t={}){const{bitswap:r}=await e.use(t),s=r.getWantlist();return Array.from(s).map((e=>e[1].cid))}return gt(t)}function _n({network:e}){async function t(t,r={}){const{bitswap:s}=await e.use(r),n=s.wantlistForPeer(t);return Array.from(n).map((e=>e[1].cid))}return gt(t)}function En({network:e}){async function t(t,r={}){const{bitswap:s}=await e.use(r);return Array.isArray(t)||(t=[t]),s.unwant(t)}return gt(t)}function vn({network:e}){async function t(t={}){const r=(await e.use(t)).bitswap,s=r.stat().snapshot;return{provideBufLen:parseInt(s.providesBufferLength.toString()),blocksReceived:BigInt(s.blocksReceived.toString()),wantlist:Array.from(r.getWantlist()).map((e=>e[1].cid)),peers:r.peers(),dupBlksReceived:BigInt(s.dupBlksReceived.toString()),dupDataReceived:BigInt(s.dupDataReceived.toString()),dataReceived:BigInt(s.dataReceived.toString()),blocksSent:BigInt(s.blocksSent.toString()),dataSent:BigInt(s.dataSent.toString())}}return gt(t)}class Sn{constructor({network:e}){this.wantlist=bn({network:e}),this.wantlistForPeer=_n({network:e}),this.unwant=En({network:e}),this.stat=vn({network:e})}}function In(e){try{return Ge.Cz.matches(e)}catch(mu){return!1}}function kn({repo:e}){async function t(t,r={}){if(!In(t))throw new Error(`${t} is not a valid Multiaddr`);const s=await e.config.getAll(r),n=s.Bootstrap||[];return n.push(t.toString()),s.Bootstrap=Array.from(new Set(n)).sort(((e,t)=>e.localeCompare(t))),await e.config.replace(s),{Peers:[t]}}return gt(t)}function Rn({repo:e}){async function t(t={}){const r=await e.config.getAll(t),s=r.Bootstrap||[];return r.Bootstrap=[],await e.config.replace(r),{Peers:s.map((e=>(0,qe.HM)(e)))}}return gt(t)}function Tn({repo:e}){async function t(t={}){const r=await e.config.get("Bootstrap",t);return{Peers:(r||[]).map((e=>(0,qe.HM)(e)))}}return gt(t)}var An=()=>({Addresses:{Swarm:[],Announce:[],NoAnnounce:[],API:"",Gateway:"",RPC:"",Delegates:["/dns4/node0.delegate.ipfs.io/tcp/443/https","/dns4/node1.delegate.ipfs.io/tcp/443/https","/dns4/node2.delegate.ipfs.io/tcp/443/https","/dns4/node3.delegate.ipfs.io/tcp/443/https"]},Discovery:{MDNS:{Enabled:!1,Interval:10},webRTCStar:{Enabled:!0}},Bootstrap:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb","/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt","/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic","/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6","/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS","/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"],Pubsub:{Enabled:!0},Swarm:{ConnMgr:{LowWater:5,HighWater:20},DisableNatPortMap:!0},Routing:{Type:"dhtclient"}});function Cn({repo:e}){async function t(t={}){const r=await e.config.getAll(t);return r.Bootstrap=An().Bootstrap,await e.config.replace(r),{Peers:An().Bootstrap.map((e=>(0,qe.HM)(e)))}}return gt(t)}function Pn({repo:e}){async function t(t,r={}){if(!In(t))throw new Error(`${t} is not a valid Multiaddr`);const s=await e.config.getAll(r);return s.Bootstrap=(s.Bootstrap||[]).filter((e=>e.toString()!==t.toString())),await e.config.replace(s),{Peers:[t]}}return gt(t)}class Dn{constructor({repo:e}){this.add=kn({repo:e}),this.list=Tn({repo:e}),this.rm=Pn({repo:e}),this.clear=Rn({repo:e}),this.reset=Cn({repo:e})}}function Nn({preload:e,repo:t}){async function r(r,s={}){return!1!==s.preload&&e(r),t.blocks.get(r,s)}return gt(r)}function On({codecs:e,hashers:t,repo:r,preload:s}){async function n(n,i={}){const o=i.pin?await r.gcLock.readLock():null;try{const a=null!=i.version?i.version:0,c=i.format||(0===a?"dag-pb":"raw"),l=await t.getHasher(i.mhtype||"sha2-256"),u=await l.digest(n),h=await e.getCodec(c),d=A.CID.create(a,h.code,u);return await r.blocks.put(d,n,{signal:i.signal}),!1!==i.preload&&s(d),!0===i.pin&&await r.pins.pinRecursively(d,{signal:i.signal}),d}finally{o&&o()}}return gt(n)}var Ln=r(58869);function xn(e){return e instanceof Uint8Array?A.CID.decode(e):A.CID.parse(e.toString())}const Mn=8;function Bn({repo:e}){async function*t(t,r={}){Array.isArray(t)||(t=[t]);const s=await e.gcLock.writeLock();try{yield*(0,Cs.zG)(t,(t=>As(t,(t=>async()=>{t=xn(t);const s={cid:t};try{const r=await e.blocks.has(t);if(!r)throw h(new Error("block not found"),"ERR_BLOCK_NOT_FOUND");await e.blocks.delete(t)}catch(mu){r.force||(mu.message=`cannot remove ${t}: ${mu.message}`,s.error=mu)}return s}))),(e=>Ln(e,{concurrency:Mn})),(e=>ms(e,(()=>!r.quiet))))}finally{s()}}return gt(t)}function Un({repo:e,preload:t}){async function r(r,s={}){r=xn(r),!1!==s.preload&&t(r);const n=await e.blocks.get(r);return{cid:r,size:n.length}}return gt(r)}class jn{constructor({codecs:e,hashers:t,preload:r,repo:s}){this.get=Nn({preload:r,repo:s}),this.put=On({codecs:e,hashers:t,preload:r,repo:s}),this.rm=Bn({repo:s}),this.stat=Un({preload:r,repo:s})}}var Vn=r(86154),zn=r(23294),Fn=r(28132);function $n(e){return ArrayBuffer.isView(e)||e instanceof ArrayBuffer}function Kn(e){return e.constructor&&("Blob"===e.constructor.name||"File"===e.constructor.name)&&"function"===typeof e.stream}function Hn(e){return"object"===typeof e&&(e.path||e.content)}const qn=e=>e&&"function"===typeof e.getReader;async function*Gn(e){yield e}async function Wn(e){if($n(e))return Gn(Yn(e));if("string"===typeof e||e instanceof String)return Gn(Yn(e.toString()));if(Kn(e))return zn(e);if(qn(e)&&(e=Vn(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const t=Fn(e),{value:r,done:s}=await t.peek();if(s)return Gn(new Uint8Array(0));if(t.push(r),Number.isInteger(r))return Gn(Uint8Array.from(await fs(t)));if($n(r)||"string"===typeof r||r instanceof String)return As(t,Yn)}throw h(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT")}function Yn(e){return e instanceof Uint8Array?e:ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e instanceof ArrayBuffer?new Uint8Array(e):Array.isArray(e)?Uint8Array.from(e):(0,ze.m)(e.toString())}async function*Qn(e,t){if(null===e||void 0===e)throw h(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT");if("string"===typeof e||e instanceof String)yield Zn(e.toString(),t);else if($n(e)||Kn(e))yield Zn(e,t);else{if(qn(e)&&(e=Vn(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const r=Fn(e),{value:s,done:n}=await r.peek();if(n)return void(yield{content:[]});if(r.push(s),Number.isInteger(s)||$n(s)||"string"===typeof s||s instanceof String)return void(yield Zn(r,t));throw h(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"),"ERR_UNEXPECTED_INPUT")}if(!Hn(e))throw h(new Error('Unexpected input: cannot convert "'+typeof e+'" into ImportCandidate'),"ERR_UNEXPECTED_INPUT");yield Zn(e,t)}}async function Zn(e,t){const{path:r,mode:s,mtime:n,content:i}=e,o={path:r||"",mode:S(s),mtime:I(n)};return i?o.content=await t(i):r||(o.content=await t(e)),o}function Xn(e){return Qn(e,Wn)}function Jn({addAll:e}){async function t(t,r={}){const s=await Wt(e(Xn(t),r));if(null==s)throw Error("Failed to add a file, if you see this please report a bug");return s}return t}var ei=r(84810),ti=r(56155),ri=r(7225),si=r(40469);function ni(e){const t=new Array(4);for(let r=0;r<4;r++)t[r]=255&e,e>>=8;return new Uint8Array(t)}(0,ri.D)({name:"murmur3-32",code:35,encode:e=>ni(si.x86.hash32(e))});const ii=(0,ri.D)({name:"murmur3-128",code:34,encode:e=>V.aI.fromHex(si.x64.hash128(e))});async function oi(e){return(await ii.encode(e)).slice(0,8).reverse()}const ai={chunker:"fixed",strategy:"balanced",rawLeaves:!1,onlyHash:!1,reduceSingleLeafToSelf:!0,hasher:ti.sha256,leafType:"file",cidVersion:0,progress:()=>()=>{},shardSplitThreshold:1e3,fileImportConcurrency:50,blockWriteConcurrency:10,minChunkSize:262144,maxChunkSize:262144,avgChunkSize:262144,window:16,polynomial:0x3df305dfb2a804,maxChildrenPerNode:174,layerRepeat:4,wrapWithDirectory:!1,recursive:!1,hidden:!1,timeout:void 0,hamtHashFn:oi,hamtHashCode:34,hamtBucketBits:8};var ci=(e={})=>{const t=c.Z.bind({ignoreUndefined:!0});return t(ai,e)};const li=async(e,t,r)=>{r.codec||(r.codec=R),r.hasher||(r.hasher=ti.sha256),void 0===r.cidVersion&&(r.cidVersion=1),r.codec===R&&r.hasher!==ti.sha256&&(r.cidVersion=1);const s=await r.hasher.digest(e),n=A.CID.create(r.cidVersion,r.codec.code,s);return r.onlyHash||await t.put(n,e,{signal:r.signal}),n};var ui=li;const hi=async(e,t,r)=>{const s=new k({type:"directory",mtime:e.mtime,mode:e.mode}),n=(0,R.encode)((0,R.prepare)({Data:s.marshal()})),i=await ui(n,t,r),o=e.path;return{cid:i,path:o,unixfs:s,size:n.length}};var di=hi,pi=r(96945);async function fi(e,t){return t(await fs(e))}var yi=fi,gi=r(78165);function mi(e,t,r){return wi(e,t,r)}async function wi(e,t,r){const s=[];for await(const n of gi(e,r.maxChildrenPerNode))s.push(await t(n));return s.length>1?wi(s,t,r):s[0]}var bi=mi;async function _i(e,t,r){const s=new Si(r.layerRepeat);let n=0,i=1,o=s;for await(const a of gi(e,r.maxChildrenPerNode))o.isFull()&&(o!==s&&s.addChild(await o.reduce(t)),n&&n%r.layerRepeat===0&&i++,o=new vi(i,r.layerRepeat,n),n++),o.append(a);return o&&o!==s&&s.addChild(await o.reduce(t)),s.reduce(t)}var Ei=_i;class vi{constructor(e,t,r=0){this.maxDepth=e,this.layerRepeat=t,this.currentDepth=1,this.iteration=r,this.root=this.node=this.parent={children:[],depth:this.currentDepth,maxDepth:e,maxChildren:(this.maxDepth-this.currentDepth)*this.layerRepeat}}isFull(){if(!this.root.data)return!1;if(this.currentDepth<this.maxDepth&&this.node.maxChildren)return this._addNextNodeToParent(this.node),!1;const e=this._findParent(this.node,this.currentDepth);return!e||(this._addNextNodeToParent(e),!1)}_addNextNodeToParent(e){this.parent=e;const t={children:[],depth:e.depth+1,parent:e,maxDepth:this.maxDepth,maxChildren:Math.floor(e.children.length/this.layerRepeat)*this.layerRepeat};e.children.push(t),this.currentDepth=t.depth,this.node=t}append(e){this.node.data=e}reduce(e){return this._reduce(this.root,e)}async _reduce(e,t){let r=[];return e.children.length&&(r=await Promise.all(e.children.filter((e=>e.data)).map((e=>this._reduce(e,t))))),t((e.data||[]).concat(r))}_findParent(e,t){const r=e.parent;if(r&&0!==r.depth)return r.children.length!==r.maxChildren&&r.maxChildren?r:this._findParent(r,t)}}class Si extends vi{constructor(e){super(0,e),this.root.depth=0,this.currentDepth=1}addChild(e){this.root.children.push(e)}reduce(e){return e((this.root.data||[]).concat(this.root.children))}}async function*Ii(e,t,r){for await(let s of e.content)yield async()=>{let n;r.progress(s.length,e.path);const i={codec:R,cidVersion:r.cidVersion,hasher:r.hasher,onlyHash:r.onlyHash};return r.rawLeaves?(i.codec=pi,i.cidVersion=1):(n=new k({type:r.leafType,data:s}),s=R.encode({Data:n.marshal(),Links:[]})),{cid:await ui(s,t,i),unixfs:n,size:s.length}}}var ki=Ii;const Ri={flat:yi,balanced:bi,trickle:Ei};async function*Ti(e,t,r){let s,n,i=-1;n="function"===typeof r.bufferImporter?r.bufferImporter:ki;for await(const o of ei(n(e,t,r),r.blockWriteConcurrency))i++,0!==i?(1===i&&s&&(yield s,s=null),yield o):s=o;s&&(s.single=!0,yield s)}const Ai=(e,t,r)=>{async function s(s){if(1===s.length&&s[0].single&&r.reduceSingleLeafToSelf){const n=s[0];if(void 0!==e.mtime||void 0!==e.mode){let s=await t.get(n.cid);n.unixfs=new k({type:"file",mtime:e.mtime,mode:e.mode,data:s}),s=(0,R.encode)((0,R.prepare)({Data:n.unixfs.marshal()})),n.cid=await ui(s,t,{...r,codec:R,hasher:r.hasher,cidVersion:r.cidVersion}),n.size=s.length}return{cid:n.cid,path:e.path,unixfs:n.unixfs,size:n.size}}const n=new k({type:"file",mtime:e.mtime,mode:e.mode}),i=s.filter((e=>!(e.cid.code!==pi.code||!e.size)||(!(!e.unixfs||e.unixfs.data||!e.unixfs.fileSize())||Boolean(e.unixfs&&e.unixfs.data&&e.unixfs.data.length)))).map((e=>e.cid.code===pi.code?(n.addBlockSize(e.size),{Name:"",Tsize:e.size,Hash:e.cid}):(e.unixfs&&e.unixfs.data?n.addBlockSize(e.unixfs.data.length):n.addBlockSize(e.unixfs&&e.unixfs.fileSize()||0),{Name:"",Tsize:e.size,Hash:e.cid}))),o={Data:n.marshal(),Links:i},a=(0,R.encode)((0,R.prepare)(o)),c=await ui(a,t,r);return{cid:c,path:e.path,unixfs:n,size:a.length+o.Links.reduce(((e,t)=>e+t.Tsize),0)}}return s};function Ci(e,t,r){const s=Ri[r.strategy];if(!s)throw h(new Error(`Unknown importer build strategy name: ${r.strategy}`),"ERR_BAD_STRATEGY");return s(Ti(e,t,r),Ai(e,t,r),r)}var Pi=Ci,Di=r(9668),Ni=r(63060);async function*Oi(e,t){let r,s,n;if(t.minChunkSize&&t.maxChunkSize&&t.avgChunkSize)n=t.avgChunkSize,r=t.minChunkSize,s=t.maxChunkSize;else{if(!t.avgChunkSize)throw h(new Error("please specify an average chunk size"),"ERR_INVALID_AVG_CHUNK_SIZE");n=t.avgChunkSize,r=n/3,s=n+n/2}if(r<16)throw h(new Error("rabin min must be greater than 16"),"ERR_INVALID_MIN_CHUNK_SIZE");s<r&&(s=r),n<r&&(n=r);const i=Math.floor(Math.log2(n));for await(const o of xi(e,{min:r,max:s,bits:i,window:t.window,polynomial:t.polynomial}))yield o}var Li=Oi;async function*xi(e,t){const r=await(0,Ni.create)(t.bits,t.min,t.max,t.window),s=new Di;for await(const n of e){s.append(n);const e=r.fingerprint(n);for(let t=0;t<e.length;t++){const r=e[t],n=s.slice(0,r);s.consume(r),yield n}}s.length&&(yield s.slice(0))}async function*Mi(e,t){let r=new Di,s=0,n=!1;const i=t.maxChunkSize;for await(const o of e){r.append(o),s+=o.length;while(s>=i)if(yield r.slice(0,i),n=!0,i===r.length)r=new Di,s=0;else{const e=new Di;e.append(r.shallowSlice(i)),r=e,s-=i}}n&&!s||(yield r.slice(0,s))}var Bi=Mi;async function*Ui(e){for await(const t of e){if(void 0===t.length)throw h(new Error("Content was invalid"),"ERR_INVALID_CONTENT");if("string"===typeof t||t instanceof String)yield(0,ze.m)(t.toString());else if(Array.isArray(t))yield Uint8Array.from(t);else{if(!(t instanceof Uint8Array))throw h(new Error("Content was invalid"),"ERR_INVALID_CONTENT");yield t}}}var ji=Ui;function Vi(e){return Symbol.iterator in e}function zi(e){return Symbol.asyncIterator in e}function Fi(e){try{if(e instanceof Uint8Array)return async function*(){yield e}();if(Vi(e))return async function*(){yield*e}();if(zi(e))return e}catch{throw h(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}throw h(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}async function*$i(e,t,r){for await(const s of e)if(s.path&&("./"===s.path.substring(0,2)&&(r.wrapWithDirectory=!0),s.path=s.path.split("/").filter((e=>e&&"."!==e)).join("/")),s.content){let e,n;e="function"===typeof r.chunker?r.chunker:"rabin"===r.chunker?Li:Bi,n="function"===typeof r.chunkValidator?r.chunkValidator:ji;const i={path:s.path,mtime:s.mtime,mode:s.mode,content:e(n(Fi(s.content),r),r)};yield()=>Pi(i,t,r)}else{if(!s.path)throw new Error("Import candidate must have content or path or both");{const e={path:s.path,mtime:s.mtime,mode:s.mode};yield()=>di(e,t,r)}}}var Ki=$i;class Hi{constructor(e,t){this.options=t||{},this.root=e.root,this.dir=e.dir,this.path=e.path,this.dirty=e.dirty,this.flat=e.flat,this.parent=e.parent,this.parentKey=e.parentKey,this.unixfs=e.unixfs,this.mode=e.mode,this.mtime=e.mtime,this.cid=void 0,this.size=void 0}async put(e,t){}get(e){return Promise.resolve(this)}async*eachChildSeries(){}async*flush(e){}}var qi=Hi;class Gi extends qi{constructor(e,t){super(e,t),this._children={}}async put(e,t){this.cid=void 0,this.size=void 0,this._children[e]=t}get(e){return Promise.resolve(this._children[e])}childCount(){return Object.keys(this._children).length}directChildrenCount(){return this.childCount()}onlyChild(){return this._children[Object.keys(this._children)[0]]}async*eachChildSeries(){const e=Object.keys(this._children);for(let t=0;t<e.length;t++){const r=e[t];yield{key:r,child:this._children[r]}}}async*flush(e){const t=Object.keys(this._children),r=[];for(let c=0;c<t.length;c++){let s=this._children[t[c]];if(s instanceof qi)for await(const t of s.flush(e))s=t,yield s;null!=s.size&&s.cid&&r.push({Name:t[c],Tsize:s.size,Hash:s.cid})}const s=new k({type:"directory",mtime:this.mtime,mode:this.mode}),n={Data:s.marshal(),Links:r},i=(0,R.encode)((0,R.prepare)(n)),o=await ui(i,e,this.options),a=i.length+n.Links.reduce(((e,t)=>e+(null==t.Tsize?0:t.Tsize)),0);this.cid=o,this.size=a,yield{cid:o,unixfs:s,path:this.path,size:a}}}var Wi=Gi,Yi=r(20544);class Qi{constructor(e,t,r=0){this._options=e,this._popCount=0,this._parent=t,this._posAtParent=r,this._children=new Yi,this.key=null}async put(e,t){const r=await this._findNewBucketAndPos(e);await r.bucket._putAt(r,e,t)}async get(e){const t=await this._findChild(e);if(null!=t)return t.value}async del(e){const t=await this._findPlace(e),r=t.bucket._at(t.pos);null!=r&&r.key===e&&t.bucket._delAt(t.pos)}leafCount(){const e=this._children.compactArray();return e.reduce(((e,t)=>t instanceof Qi?e+t.leafCount():e+1),0)}childrenCount(){return this._children.length}onlyChild(){return this._children.get(0)}*eachLeafSeries(){const e=this._children.compactArray();for(const t of e)t instanceof Qi?yield*t.eachLeafSeries():yield t}serialize(e,t){const r=[];return t(this._children.reduce(((r,s,n)=>(null!=s&&(s instanceof Qi?r.push(s.serialize(e,t)):r.push(e(s,n))),r)),r))}async asyncTransform(e,t){return await eo(this,e,t)}toJSON(){return this.serialize(Xi,Ji)}prettyPrint(){return JSON.stringify(this.toJSON(),null,"  ")}tableSize(){return Math.pow(2,this._options.bits)}async _findChild(e){const t=await this._findPlace(e),r=t.bucket._at(t.pos);if(!(r instanceof Qi))return null!=r&&r.key===e?r:void 0}async _findPlace(e){const t=this._options.hash("string"===typeof e?(0,ze.m)(e):e),r=await t.take(this._options.bits),s=this._children.get(r);return s instanceof Qi?await s._findPlace(t):{bucket:this,pos:r,hash:t,existingChild:s}}async _findNewBucketAndPos(e){const t=await this._findPlace(e);if(null!=t.existingChild&&t.existingChild.key!==e){const e=new Qi(this._options,t.bucket,t.pos);t.bucket._putObjectAt(t.pos,e);const r=await e._findPlace(t.existingChild.hash);return r.bucket._putAt(r,t.existingChild.key,t.existingChild.value),await e._findNewBucketAndPos(t.hash)}return t}_putAt(e,t,r){this._putObjectAt(e.pos,{key:t,value:r,hash:e.hash})}_putObjectAt(e,t){null==this._children.get(e)&&this._popCount++,this._children.set(e,t)}_delAt(e){if(-1===e)throw new Error("Invalid position");null!=this._children.get(e)&&this._popCount--,this._children.unset(e),this._level()}_level(){if(null!=this._parent&&this._popCount<=1)if(1===this._popCount){const e=this._children.find(Zi);if(null!=e&&!(e instanceof Qi)){const t=e.hash;t.untake(this._options.bits);const r={pos:this._posAtParent,hash:t,bucket:this._parent};this._parent._putAt(r,e.key,e.value)}}else this._parent._delAt(this._posAtParent)}_at(e){return this._children.get(e)}}function Zi(e){return Boolean(e)}function Xi(e,t){return e.key}function Ji(e){return e}async function eo(e,t,r){const s=[];for(const n of e._children.compactArray())if(n instanceof Qi)await eo(n,t,r);else{const r=await t(n);s.push({bitField:e._children.bitField(),children:r})}return await r(s)}const to=[255,254,252,248,240,224,192,128],ro=[1,3,7,15,31,63,127,255];class so{constructor(e){this._value=e,this._currentBytePos=e.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+8*this._currentBytePos}totalBits(){return 8*this._value.length}take(e){let t=e,r=0;while(t>0&&this._haveBits()){const e=this._value[this._currentBytePos],s=this._currentBitPos+1,n=Math.min(s,t),i=no(e,s-n,n);r=(r<<n)+i,t-=n,this._currentBitPos-=n,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return r}untake(e){this._currentBitPos+=e;while(this._currentBitPos>7)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}}function no(e,t,r){const s=io(t,r);return(e&s)>>>t}function io(e,t){return to[e]&ro[Math.min(t+e-1,7)]}function oo(e){function t(t){return t instanceof ao?t:new ao(t,e)}return t}class ao{constructor(e,t){if(!(e instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=e,this._hashFn=t,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(e){let t=e;while(this._availableBits<t)await this._produceMoreBits();let r=0;while(t>0){const e=this._buffers[this._currentBufferIndex],s=Math.min(e.availableBits(),t),n=e.take(s);r=(r<<s)+n,t-=s,this._availableBits-=s,0===e.availableBits()&&this._currentBufferIndex++}return r}untake(e){let t=e;while(t>0){const e=this._buffers[this._currentBufferIndex],r=Math.min(e.totalBits()-e.availableBits(),t);e.untake(r),t-=r,this._availableBits+=r,this._currentBufferIndex>0&&e.totalBits()===e.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const e=this._depth>0?(0,Ir.concat)([this._value,Uint8Array.from([this._depth])]):this._value,t=await this._hashFn(e),r=new so(t);this._buffers.push(r),this._availableBits+=r.availableBits()}}function co(e){if(null==e||null==e.hashFn)throw new Error("please define an options.hashFn");const t={bits:e.bits??8,hash:oo(e.hashFn)};return new Qi(t)}class lo extends qi{constructor(e,t){super(e,t),this._bucket=co({hashFn:t.hamtHashFn,bits:t.hamtBucketBits})}async put(e,t){await this._bucket.put(e,t)}get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:t}of this._bucket.eachLeafSeries())yield{key:e,child:t}}async*flush(e){for await(const t of ho(this._bucket,e,this,this.options))yield{...t,path:this.path}}}var uo=lo;async function*ho(e,t,r,s){const n=e._children,i=[];let o=0;for(let p=0;p<n.length;p++){const e=n.get(p);if(!e)continue;const r=p.toString(16).toUpperCase().padStart(2,"0");if(e instanceof Qi){let n;for await(const r of await ho(e,t,null,s))n=r;if(!n)throw new Error("Could not flush sharded directory, no subshard found");i.push({Name:r,Tsize:n.size,Hash:n.cid}),o+=n.size}else if("function"===typeof e.value.flush){const s=e.value;let n;for await(const e of s.flush(t))n=e,yield n;const a=r+e.key;i.push({Name:a,Tsize:n.size,Hash:n.cid}),o+=n.size}else{const t=e.value;if(!t.cid)continue;const s=r+e.key,n=t.size;i.push({Name:s,Tsize:n,Hash:t.cid}),o+=n}}const a=Uint8Array.from(n.bitField().reverse()),c=new k({type:"hamt-sharded-directory",data:a,fanout:e.tableSize(),hashType:s.hamtHashCode,mtime:r&&r.mtime,mode:r&&r.mode}),l={Data:c.marshal(),Links:i},u=(0,R.encode)((0,R.prepare)(l)),h=await ui(u,t,s),d=u.length+o;yield{cid:h,unixfs:c,size:d}}async function po(e,t,r,s){let n=t;t instanceof Wi&&t.directChildrenCount()>=r&&(n=await fo(t,s));const i=n.parent;if(i){if(n!==t){if(e&&(e.parent=n),!n.parentKey)throw new Error("No parent key found");await i.put(n.parentKey,n)}return po(n,i,r,s)}return n}async function fo(e,t){const r=new uo({root:e.root,dir:!0,parent:e.parent,parentKey:e.parentKey,path:e.path,dirty:e.dirty,flat:!1,mtime:e.mtime,mode:e.mode},t);for await(const{key:s,child:n}of e.eachChildSeries())await r.put(s,n);return r}var yo=po;const go=(e="")=>(e.trim().match(/([^\\/]|\\\/)+/g)||[]).filter(Boolean);var mo=go;async function wo(e,t,r){const s=mo(e.path||""),n=s.length-1;let i=t,o="";for(let a=0;a<s.length;a++){const c=s[a];o+=`${o?"/":""}${c}`;const l=a===n;if(i.dirty=!0,i.cid=void 0,i.size=void 0,l)await i.put(c,e),t=await yo(null,i,r.shardSplitThreshold,r);else{let e=await i.get(c);e&&e instanceof qi||(e=new Wi({root:!1,dir:!0,parent:i,parentKey:c,path:o,dirty:!0,flat:!0,mtime:e&&e.unixfs&&e.unixfs.mtime,mode:e&&e.unixfs&&e.unixfs.mode},r)),await i.put(c,e),i=e}}return t}async function*bo(e,t){e instanceof qi?yield*e.flush(t):e&&e.unixfs&&e.unixfs.isDirectory()&&(yield e)}async function*_o(e,t,r){let s=new Wi({root:!0,dir:!0,path:"",dirty:!0,flat:!0},r);for await(const n of e)n&&(s=await wo(n,s,r),n.unixfs&&n.unixfs.isDirectory()||(yield n));if(r.wrapWithDirectory)yield*bo(s,t);else for await(const n of s.eachChildSeries())n&&(yield*bo(n.child,t))}var Eo=_o;async function*vo(e,t,r={}){const s=ci(r);let n,i,o;n="function"===typeof r.dagBuilder?r.dagBuilder:Ki,i="function"===typeof r.treeBuilder?r.treeBuilder:Eo,o=Symbol.asyncIterator in e||Symbol.iterator in e?e:[e];for await(const a of i(ei(n(o,t,s),s.fileImportConcurrency),t,s))yield{cid:a.cid,path:a.path,unixfs:a.unixfs,size:a.size}}async function*So(e,t){if("string"===typeof e||e instanceof String||$n(e)||Kn(e)||e._readableState)throw h(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(qn(e)&&(e=Vn(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const r=Fn(e),{value:s,done:n}=await r.peek();if(n)return void(yield*[]);if(r.push(s),Number.isInteger(s))throw h(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(s._readableState)return void(yield*As(r,(e=>Io({content:e},t))));if($n(s))return void(yield Io({content:r},t));if(Hn(s)||s[Symbol.iterator]||s[Symbol.asyncIterator]||qn(s)||Kn(s))return void(yield*As(r,(e=>Io(e,t))))}if(Hn(e))throw h(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");throw h(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")}async function Io(e,t){const{path:r,mode:s,mtime:n,content:i}=e,o={path:r||"",mode:S(s),mtime:I(n)};return i?o.content=await t(i):r||(o.content=await t(e)),o}function ko(e){return So(e,Wn)}const Ro=e=>{if(e){if(e.startsWith("size-")){const t=e.split("-")[1],r=parseInt(t);if(isNaN(r))throw new Error("Chunker parameter size must be an integer");return{chunker:"fixed",maxChunkSize:r}}if(e.startsWith("rabin"))return{chunker:"rabin",...To(e)};throw new Error(`Unrecognized chunker option: ${e}`)}return{chunker:"fixed"}},To=e=>{const t={},r=e.split("-");switch(r.length){case 1:t.avgChunkSize=262144;break;case 2:t.avgChunkSize=Ao(r[1],"avg");break;case 4:t.minChunkSize=Ao(r[1],"min"),t.avgChunkSize=Ao(r[2],"avg"),t.maxChunkSize=Ao(r[3],"max");break;default:throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"')}return t},Ao=(e,t)=>{const r=parseInt(e);if(isNaN(r))throw new Error(`Chunker parameter ${t} must be an integer`);return r},Co=c.Z.bind({ignoreUndefined:!0});function Po({repo:e,preload:t,hashers:r,options:s}){const n=s&&s.sharding;async function*i(s,i={}){const o=Co({shardSplitThreshold:n?1e3:1/0,strategy:"balanced"},i,{...Ro(i.chunker)});o.hashAlg&&"sha2-256"!==o.hashAlg&&1!==o.cidVersion&&(o.cidVersion=1),o.trickle&&(o.strategy="trickle"),"trickle"===o.strategy&&(o.leafType="raw",o.reduceSingleLeafToSelf=!1),o.cidVersion>0&&void 0===o.rawLeaves&&(o.rawLeaves=!0),void 0!==o.hashAlg&&void 0===o.rawLeaves&&(o.rawLeaves=!0),delete o.trickle;const a={};if(o.progress){const e=o.progress;o.progress=(t,r)=>{a[r]||(a[r]=0),a[r]+=t,e(a[r],r)}}let c;null!=o.hashAlg&&(c=await r.getHasher(o.hashAlg));const l=(0,Cs.zG)(ko(s),(t=>vo(t,e.blocks,{...o,hasher:c,pin:!1})),Do(o),No(t,o),Oo(e,o)),u=await e.gcLock.readLock();try{for await(const e of l){const t=e.path??e.cid.toString();delete a[t],yield{...e,path:t}}}finally{u()}}return gt(i)}function Do(e){async function*t(t){for await(const r of t){let t=r.cid;1===e.cidVersion&&(t=t.toV1());let s=r.path?r.path:t.toString();e.wrapWithDirectory&&!r.path&&(s=""),yield{path:s,cid:t,size:r.size,mode:r.unixfs&&r.unixfs.mode,mtime:r.unixfs&&r.unixfs.mtime}}}return t}function No(e,t){async function*r(r){for await(const s of r){const r=!s.path||t.wrapWithDirectory?""===s.path:!s.path.includes("/"),n=r&&!t.onlyHash&&!1!==t.preload;n&&e(s.cid),yield s}}return r}function Oo(e,t){async function*r(r){for await(const s of r){const r=!(s.path&&s.path.includes("/")),n=(null==t.pin||t.pin)&&r&&!t.onlyHash;n&&await e.pins.pinRecursively(s.cid),yield s}}return r}const Lo=async function(e){return(await ii.encode(e)).slice(0,8).reverse()},xo=(e,t,r)=>Promise.all(e.map((e=>{if(null==e.Name)throw new Error("Unexpected Link without a Name");if(2===e.Name.length){const s=parseInt(e.Name,16);return t._putObjectAt(s,new Qi({hash:r._options.hash,bits:r._options.bits},t,s))}return r.put(e.Name.substring(2),!0)}))),Mo=e=>e.toString(16).toUpperCase().padStart(2,"0").substring(0,2),Bo=e=>{let t=e.bucket;const r=[];while(t._parent)r.push(t),t=t._parent;return r.push(t),r.reverse()},Uo=async(e,t,r,s,n)=>{if(!s){const e=co({hashFn:Lo});s={rootBucket:e,hamtDepth:1,lastBucket:e}}await xo(e.Links,s.lastBucket,s.rootBucket);const i=await s.rootBucket._findNewBucketAndPos(t);let o=Mo(i.pos);const a=Bo(i);a.length>s.hamtDepth&&(s.lastBucket=a[s.hamtDepth],o=Mo(s.lastBucket._posAtParent));const c=e.Links.find((e=>{if(null==e.Name)return!1;const r=e.Name.substring(0,2),s=e.Name.substring(2);return r===o&&(!s||s===t)}));if(!c)return null;if(null!=c.Name&&c.Name.substring(2)===t)return c.Hash;s.hamtDepth++;const l=await r.get(c.Hash,n);return e=(0,R.decode)(l),Uo(e,t,r,s,n)};var jo=Uo;function Vo(e,t,r,s){const n=e.length,i=t+n;return r>=i||s<t?new Uint8Array(0):(s>=t&&s<i&&(e=e.subarray(0,s-t)),r>=t&&r<i&&(e=e.subarray(r-t)),e)}var zo=Vo;const Fo=(e,t,r)=>{if(t||(t=0),t<0)throw h(new Error("Offset must be greater than or equal to 0"),"ERR_INVALID_PARAMS");if(t>e)throw h(new Error("Offset must be less than the file size"),"ERR_INVALID_PARAMS");if(r||0===r||(r=e-t),r<0)throw h(new Error("Length must be greater than or equal to 0"),"ERR_INVALID_PARAMS");return t+r>e&&(r=e-t),{offset:t,length:r}};var $o=Fo;async function Ko(e,t,r,s,n,i,o,a){if(t instanceof Uint8Array)return void r.push(zo(t,s,n,i));if(null==t.Data)throw h(new Error("no data in PBNode"),"ERR_NOT_UNIXFS");let c;try{c=k.unmarshal(t.Data)}catch(mu){throw h(mu,"ERR_NOT_UNIXFS")}if(null!=c.data){const e=c.data,t=zo(e,s,n,i);r.push(t),s+=t.byteLength}const l=[];for(let u=0;u<t.Links.length;u++){const e=t.Links[u],r=s,o=r+c.blockSizes[u];if((n>=r&&n<o||i>=r&&i<=o||n<r&&i>o)&&l.push({link:e,blockStart:s}),s=o,s>i)break}await(0,Cs.zG)(l,(t=>As(t,(t=>async()=>{const r=await e.get(t.link.Hash,{signal:a.signal});return{...t,block:r}}))),(e=>Ln(e,{ordered:!0})),(async t=>{for await(const{link:s,block:c,blockStart:l}of t){let t;switch(s.Hash.code){case R.code:t=R.decode(c);break;case pi.code:t=c;break;default:return void r.end(h(new Error(`Unsupported codec: ${s.Hash.code}`),"ERR_NOT_UNIXFS"))}o.add((async()=>{await Ko(e,t,r,l,n,i,o,a)}))}}))}const Ho=(e,t,r,s,n,i,o)=>{async function*a(e={}){const s=r.fileSize();if(void 0===s)throw new Error("File was a directory");const{offset:n,length:i}=$o(s,e.offset,e.length);if(0===i)return;const a=new Lt.Z({concurrency:1}),c=(0,_s.d)();a.add((async()=>{await Ko(o,t,c,0,n,n+i,a,e)})),a.on("error",(e=>{c.end(e)}));let l=0;for await(const t of c)null!=t&&(l+=t.byteLength,l===i&&c.end(),yield t)}return a};var qo=Ho;const Go=(e,t,r,s,n,i,o)=>{async function*a(e={}){const r=e.offset||0,a=e.length||t.Links.length,c=t.Links.slice(r,a);for(const t of c){const r=await n(t.Hash,t.Name||"",`${s}/${t.Name||""}`,[],i+1,o,e);r.entry&&(yield r.entry)}}return a};var Wo=Go;const Yo=(e,t,r,s,n,i,o)=>{function a(e={}){return Qo(t,s,n,i,o,e)}return a};async function*Qo(e,t,r,s,n,i){const o=e.Links;for(const a of o){const o=null!=a.Name?a.Name.substring(2):null;if(o){const e=await r(a.Hash,o,`${t}/${o}`,[],s+1,n,i);yield e.entry}else{const o=await n.get(a.Hash);e=(0,R.decode)(o);for await(const a of Qo(e,t,r,s,n,i))yield a}}}var Zo=Yo;const Xo=(e,t)=>{const r=e.Links.find((e=>e.Name===t));return r&&r.Hash},Jo={raw:qo,file:qo,directory:Wo,"hamt-sharded-directory":Zo,metadata:(e,t,r,s,n,i,o)=>()=>[],symlink:(e,t,r,s,n,i,o)=>()=>[]},ea=async(e,t,r,s,n,i,o,a)=>{const c=await o.get(e,a),l=(0,R.decode)(c);let u,d;if(t||(t=e.toString()),null==l.Data)throw h(new Error("no data in PBNode"),"ERR_NOT_UNIXFS");try{u=k.unmarshal(l.Data)}catch(mu){throw h(mu,"ERR_NOT_UNIXFS")}if(r||(r=t),s.length){let e;if(e=u&&"hamt-sharded-directory"===u.type?await jo(l,s[0],o):Xo(l,s[0]),!e)throw h(new Error("file does not exist"),"ERR_NOT_FOUND");const t=s.shift(),n=`${r}/${t}`;d={cid:e,toResolve:s,name:t||"",path:n}}return{entry:{type:u.isDirectory()?"directory":"file",name:t,path:r,cid:e,content:Jo[u.type](e,l,u,r,n,i,o),unixfs:u,depth:i,node:l,size:u.fileSize()},next:d}};var ta=ea;const ra=e=>{async function*t(t={}){const{offset:r,length:s}=$o(e.length,t.offset,t.length);yield zo(e,0,r,r+s)}return t},sa=async(e,t,r,s,n,i,o,a)=>{if(s.length)throw h(new Error(`No link named ${r} found in raw node ${e}`),"ERR_NOT_FOUND");const c=await o.get(e,a);return{entry:{type:"raw",name:t,path:r,cid:e,content:ra(c),depth:i,size:c.length,node:c}}};var na=sa;const ia=async(e,t,r,s,n,i,o,a)=>{const c=await o.get(e),l=j(c);let u=l,d=r;while(s.length){const n=s[0];if(!(n in u))throw h(new Error(`No property named ${n} found in cbor node ${e}`),"ERR_NO_PROP");{s.shift(),d=`${d}/${n}`;const o=A.CID.asCID(u[n]);if(o)return{entry:{type:"object",name:t,path:r,cid:e,node:c,depth:i,size:c.length,content:async function*(){yield l}},next:{cid:o,name:n,path:d,toResolve:s}};u=u[n]}}return{entry:{type:"object",name:t,path:r,cid:e,node:c,depth:i,size:c.length,content:async function*(){yield l}}}};var oa=ia;const aa=e=>{async function*t(t={}){const{offset:r,length:s}=$o(e.length,t.offset,t.length);yield zo(e,0,r,r+s)}return t},ca=async(e,t,r,s,n,i,o,a)=>{if(s.length)throw h(new Error(`No link named ${r} found in raw node ${e}`),"ERR_NOT_FOUND");const c=await He.Jx(e.multihash.bytes);return{entry:{type:"identity",name:t,path:r,cid:e,content:aa(c.digest),depth:i,size:c.digest.length,node:c.digest}}};var la=ca;const ua={[R.code]:ta,[pi.code]:na,[B]:oa,[De.identity.code]:la};function ha(e,t,r,s,n,i,o){const a=ua[e.code];if(!a)throw h(new Error(`No resolver for code ${e.code}`),"ERR_NO_RESOLVER");return a(e,t,r,s,ha,n,i,o)}var da=ha;const pa=(e="")=>(e.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean),fa=e=>{if(e instanceof Uint8Array)return{cid:A.CID.decode(e),toResolve:[]};const t=A.CID.asCID(e);if(t)return{cid:t,toResolve:[]};if("string"===typeof e){0===e.indexOf("/ipfs/")&&(e=e.substring(6));const t=pa(e);return{cid:A.CID.parse(t[0]),toResolve:t.slice(1)}}throw h(new Error(`Unknown path type ${e}`),"ERR_BAD_PATH")};async function*ya(e,t,r={}){let{cid:s,toResolve:n}=fa(e),i=s.toString(),o=i;const a=n.length;while(1){const c=await da(s,i,o,n,a,t,r);if(!c.entry&&!c.next)throw h(new Error(`Could not resolve ${e}`),"ERR_NOT_FOUND");if(c.entry&&(yield c.entry),!c.next)return;n=c.next.toResolve,s=c.next.cid,i=c.next.name,o=c.next.path}}async function ga(e,t,r={}){const s=await Wt(ya(e,t,r));if(!s)throw h(new Error(`Could not resolve ${e}`),"ERR_NOT_FOUND");return s}async function*ma(e,t,r={}){const s=await ga(e,t,r);if(s&&(yield s,"directory"===s.type))for await(const i of n(s,r))yield i;async function*n(e,t){for await(const r of e.content(t))yield r,r instanceof Uint8Array||"directory"===r.type&&(yield*n(r,t))}}function wa({repo:e,preload:t}){async function*r(r,s={}){if(r=It(r),!1!==s.preload){const e=r.split("/");t(A.CID.parse(e[0]))}const n=await ga(r,e.blocks,s);if("directory"===n.type)throw new Error("this dag node is a directory");if(!n.content)throw new Error("this dag node has no content");yield*n.content(s)}return gt(r)}var ba=r(46218);"0".charCodeAt(0),(0,ze.m)("ustar\0","binary"),(0,ze.m)("ustar ","binary"),(0,ze.m)(" \0","binary");r(93489);var _a=r(71993),Ea=r(33053);const va="0000000000000000000",Sa="7777777777777777777",Ia="0".charCodeAt(0),ka=(0,ze.m)("ustar\0","binary"),Ra=(0,ze.m)("00","binary"),Ta=parseInt("7777",8),Aa=257,Ca=263,Pa=function(e){switch(e){case"file":return 0;case"link":return 1;case"symlink":return 2;case"character-device":return 3;case"block-device":return 4;case"directory":return 5;case"fifo":return 6;case"contiguous-file":return 7;case"pax-header":return 72;default:return 0}},Da=function(e){let t=256;for(let r=0;r<148;r++)t+=e[r];for(let r=156;r<512;r++)t+=e[r];return t},Na=function(e,t){const r=e.toString(8);return r.length>t?(0,ze.m)(Sa.slice(0,t)+" "):(0,ze.m)(va.slice(0,t-r.length)+r+" ")},Oa=function(e){const t=(0,ze.m)(e).byteLength;let r=Math.floor(Math.log(t)/Math.log(10))+1;return t+r>=Math.pow(10,r)&&r++,`${t+r}${e}`};function La(e){let t="";null!=e.name&&(t+=Oa(" path="+e.name+"\n")),null!=e.linkname&&(t+=Oa(" linkpath="+e.linkname+"\n"));const r=e.pax;if(null!=r)for(const s in r)Object.prototype.hasOwnProperty.call(r,s)&&(t+=Oa(" "+s+"="+r[s]+"\n"));return(0,ze.m)(t)}function xa(e){const t=new Uint8Array(512);let r=e.name,s="";if(5===e.typeflag&&"/"!==r[r.length-1]&&(r+="/"),(0,ze.m)(r).byteLength!==r.length)return null;while((0,ze.m)(r).byteLength>100){const e=r.indexOf("/");if(-1===e)return null;s+=""!==s?"/"+r.slice(0,e):r.slice(0,e),r=r.slice(e+1)}return(0,ze.m)(r).byteLength>100||(0,ze.m)(s).byteLength>155||null!=e.linkname&&(0,ze.m)(e.linkname).byteLength>100?null:(t.set((0,ze.m)(r),0),t.set(Na(e.mode&Ta,6),100),t.set(Na(e.uid,6),108),t.set(Na(e.gid,6),116),t.set(Na(e.size,11),124),t.set(Na(e.mtime.getTime()/1e3|0,11),136),t[156]=Ia+Pa(e.type),null!=e.linkname&&t.set((0,ze.m)(e.linkname),157),t.set(ka,Aa),t.set(Ra,Ca),null!=e.uname&&t.set((0,ze.m)(e.uname),265),null!=e.gname&&t.set((0,ze.m)(e.gname),297),t.set(Na(e.devmajor??0,6),329),t.set(Na(e.devminor??0,6),337),null!=s&&t.set((0,ze.m)(s),345),t.set(Na(Da(t),6),148),t)}const{S_IFMT:Ma,S_IFBLK:Ba,S_IFCHR:Ua,S_IFDIR:ja,S_IFIFO:Va,S_IFLNK:za}=_a,Fa=parseInt("755",8),$a=parseInt("644",8),Ka=new Uint8Array(1024);function Ha(e=0){switch(e&Ma){case Ba:return"block-device";case Ua:return"character-device";case ja:return"directory";case Va:return"fifo";case za:return"symlink";default:return"file"}}function qa(e){return e&=511,0!==e?Ka.subarray(0,512-e):new Uint8Array(0)}function Ga(e){if(null==e.pax){const t=xa(e);if(null!=t)return t}return Wa(e)}function Wa(e){const t=La(e),r={name:"PaxHeader",mode:e.mode,uid:e.uid,gid:e.gid,size:t.length,mtime:e.mtime,type:"pax-header",linkname:e.linkname,uname:e.uname,gname:e.gname,devmajor:e.devmajor,devminor:e.devminor};return new ba.H(xa(r)??new Uint8Array(0),t,qa(t.length),xa({...r,size:e.size,type:e.type})??new Uint8Array(0)).subarray()}function Ya(){return async function*(e){for await(let{header:t,body:r}of e){const e={...t,size:"symlink"===t.type?0:t.size??0,type:t.type??Ha(t.mode),mode:t.mode??("directory"===t.type?Fa:$a),uid:t.uid??0,gid:t.gid??0,mtime:t.mtime??new Date};if("string"===typeof r&&(r=(0,ze.m)(r)),r instanceof Uint8Array||(0,ba.Z)(r)){e.size=r.length,yield Ga(e),yield(0,ba.Z)(r)?r.subarray():r,yield qa(e.size);continue}if("symlink"===e.type&&null==e.linkname){if(null==r)throw new Error("type was symlink but no linkname or body specified");e.linkname=(0,Ye.B)(await Ea(r)),yield Ga(e);continue}if(yield Ga(e),"file"!==e.type&&"contiguous-file"!==e.type)continue;let s=0;for await(const t of r??[])s+=t.length,yield(0,ba.Z)(t)?t.subarray():t;if(s!==e.size)throw new Error(`size mismatch, wrote ${s} of ${e.size} bytes`);yield qa(e.size)}yield Ka}}
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Qa=4,Za=0,Xa=1,Ja=2;function ec(e){let t=e.length;while(--t>=0)e[t]=0}const tc=0,rc=1,sc=2,nc=3,ic=258,oc=29,ac=256,cc=ac+1+oc,lc=30,uc=19,hc=2*cc+1,dc=15,pc=16,fc=7,yc=256,gc=16,mc=17,wc=18,bc=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),_c=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Ec=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),vc=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Sc=512,Ic=new Array(2*(cc+2));ec(Ic);const kc=new Array(2*lc);ec(kc);const Rc=new Array(Sc);ec(Rc);const Tc=new Array(ic-nc+1);ec(Tc);const Ac=new Array(oc);ec(Ac);const Cc=new Array(lc);function Pc(e,t,r,s,n){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=s,this.max_length=n,this.has_stree=e&&e.length}let Dc,Nc,Oc;function Lc(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}ec(Cc);const xc=e=>e<256?Rc[e]:Rc[256+(e>>>7)],Mc=(e,t)=>{e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255},Bc=(e,t,r)=>{e.bi_valid>pc-r?(e.bi_buf|=t<<e.bi_valid&65535,Mc(e,e.bi_buf),e.bi_buf=t>>pc-e.bi_valid,e.bi_valid+=r-pc):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)},Uc=(e,t,r)=>{Bc(e,r[2*t],r[2*t+1])},jc=(e,t)=>{let r=0;do{r|=1&e,e>>>=1,r<<=1}while(--t>0);return r>>>1},Vc=e=>{16===e.bi_valid?(Mc(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)},zc=(e,t)=>{const r=t.dyn_tree,s=t.max_code,n=t.stat_desc.static_tree,i=t.stat_desc.has_stree,o=t.stat_desc.extra_bits,a=t.stat_desc.extra_base,c=t.stat_desc.max_length;let l,u,h,d,p,f,y=0;for(d=0;d<=dc;d++)e.bl_count[d]=0;for(r[2*e.heap[e.heap_max]+1]=0,l=e.heap_max+1;l<hc;l++)u=e.heap[l],d=r[2*r[2*u+1]+1]+1,d>c&&(d=c,y++),r[2*u+1]=d,u>s||(e.bl_count[d]++,p=0,u>=a&&(p=o[u-a]),f=r[2*u],e.opt_len+=f*(d+p),i&&(e.static_len+=f*(n[2*u+1]+p)));if(0!==y){do{d=c-1;while(0===e.bl_count[d])d--;e.bl_count[d]--,e.bl_count[d+1]+=2,e.bl_count[c]--,y-=2}while(y>0);for(d=c;0!==d;d--){u=e.bl_count[d];while(0!==u)h=e.heap[--l],h>s||(r[2*h+1]!==d&&(e.opt_len+=(d-r[2*h+1])*r[2*h],r[2*h+1]=d),u--)}}},Fc=(e,t,r)=>{const s=new Array(dc+1);let n,i,o=0;for(n=1;n<=dc;n++)s[n]=o=o+r[n-1]<<1;for(i=0;i<=t;i++){let t=e[2*i+1];0!==t&&(e[2*i]=jc(s[t]++,t))}},$c=()=>{let e,t,r,s,n;const i=new Array(dc+1);for(r=0,s=0;s<oc-1;s++)for(Ac[s]=r,e=0;e<1<<bc[s];e++)Tc[r++]=s;for(Tc[r-1]=s,n=0,s=0;s<16;s++)for(Cc[s]=n,e=0;e<1<<_c[s];e++)Rc[n++]=s;for(n>>=7;s<lc;s++)for(Cc[s]=n<<7,e=0;e<1<<_c[s]-7;e++)Rc[256+n++]=s;for(t=0;t<=dc;t++)i[t]=0;e=0;while(e<=143)Ic[2*e+1]=8,e++,i[8]++;while(e<=255)Ic[2*e+1]=9,e++,i[9]++;while(e<=279)Ic[2*e+1]=7,e++,i[7]++;while(e<=287)Ic[2*e+1]=8,e++,i[8]++;for(Fc(Ic,cc+1,i),e=0;e<lc;e++)kc[2*e+1]=5,kc[2*e]=jc(e,5);Dc=new Pc(Ic,bc,ac+1,cc,dc),Nc=new Pc(kc,_c,0,lc,dc),Oc=new Pc(new Array(0),Ec,0,uc,fc)},Kc=e=>{let t;for(t=0;t<cc;t++)e.dyn_ltree[2*t]=0;for(t=0;t<lc;t++)e.dyn_dtree[2*t]=0;for(t=0;t<uc;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*yc]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0},Hc=e=>{e.bi_valid>8?Mc(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0},qc=(e,t,r,s)=>{Hc(e),s&&(Mc(e,r),Mc(e,~r)),e.pending_buf.set(e.window.subarray(t,t+r),e.pending),e.pending+=r},Gc=(e,t,r,s)=>{const n=2*t,i=2*r;return e[n]<e[i]||e[n]===e[i]&&s[t]<=s[r]},Wc=(e,t,r)=>{const s=e.heap[r];let n=r<<1;while(n<=e.heap_len){if(n<e.heap_len&&Gc(t,e.heap[n+1],e.heap[n],e.depth)&&n++,Gc(t,s,e.heap[n],e.depth))break;e.heap[r]=e.heap[n],r=n,n<<=1}e.heap[r]=s},Yc=(e,t,r)=>{let s,n,i,o,a=0;if(0!==e.last_lit)do{s=e.pending_buf[e.d_buf+2*a]<<8|e.pending_buf[e.d_buf+2*a+1],n=e.pending_buf[e.l_buf+a],a++,0===s?Uc(e,n,t):(i=Tc[n],Uc(e,i+ac+1,t),o=bc[i],0!==o&&(n-=Ac[i],Bc(e,n,o)),s--,i=xc(s),Uc(e,i,r),o=_c[i],0!==o&&(s-=Cc[i],Bc(e,s,o)))}while(a<e.last_lit);Uc(e,yc,t)},Qc=(e,t)=>{const r=t.dyn_tree,s=t.stat_desc.static_tree,n=t.stat_desc.has_stree,i=t.stat_desc.elems;let o,a,c,l=-1;for(e.heap_len=0,e.heap_max=hc,o=0;o<i;o++)0!==r[2*o]?(e.heap[++e.heap_len]=l=o,e.depth[o]=0):r[2*o+1]=0;while(e.heap_len<2)c=e.heap[++e.heap_len]=l<2?++l:0,r[2*c]=1,e.depth[c]=0,e.opt_len--,n&&(e.static_len-=s[2*c+1]);for(t.max_code=l,o=e.heap_len>>1;o>=1;o--)Wc(e,r,o);c=i;do{o=e.heap[1],e.heap[1]=e.heap[e.heap_len--],Wc(e,r,1),a=e.heap[1],e.heap[--e.heap_max]=o,e.heap[--e.heap_max]=a,r[2*c]=r[2*o]+r[2*a],e.depth[c]=(e.depth[o]>=e.depth[a]?e.depth[o]:e.depth[a])+1,r[2*o+1]=r[2*a+1]=c,e.heap[1]=c++,Wc(e,r,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],zc(e,t),Fc(r,l,e.bl_count)},Zc=(e,t,r)=>{let s,n,i=-1,o=t[1],a=0,c=7,l=4;for(0===o&&(c=138,l=3),t[2*(r+1)+1]=65535,s=0;s<=r;s++)n=o,o=t[2*(s+1)+1],++a<c&&n===o||(a<l?e.bl_tree[2*n]+=a:0!==n?(n!==i&&e.bl_tree[2*n]++,e.bl_tree[2*gc]++):a<=10?e.bl_tree[2*mc]++:e.bl_tree[2*wc]++,a=0,i=n,0===o?(c=138,l=3):n===o?(c=6,l=3):(c=7,l=4))},Xc=(e,t,r)=>{let s,n,i=-1,o=t[1],a=0,c=7,l=4;for(0===o&&(c=138,l=3),s=0;s<=r;s++)if(n=o,o=t[2*(s+1)+1],!(++a<c&&n===o)){if(a<l)do{Uc(e,n,e.bl_tree)}while(0!==--a);else 0!==n?(n!==i&&(Uc(e,n,e.bl_tree),a--),Uc(e,gc,e.bl_tree),Bc(e,a-3,2)):a<=10?(Uc(e,mc,e.bl_tree),Bc(e,a-3,3)):(Uc(e,wc,e.bl_tree),Bc(e,a-11,7));a=0,i=n,0===o?(c=138,l=3):n===o?(c=6,l=3):(c=7,l=4)}},Jc=e=>{let t;for(Zc(e,e.dyn_ltree,e.l_desc.max_code),Zc(e,e.dyn_dtree,e.d_desc.max_code),Qc(e,e.bl_desc),t=uc-1;t>=3;t--)if(0!==e.bl_tree[2*vc[t]+1])break;return e.opt_len+=3*(t+1)+5+5+4,t},el=(e,t,r,s)=>{let n;for(Bc(e,t-257,5),Bc(e,r-1,5),Bc(e,s-4,4),n=0;n<s;n++)Bc(e,e.bl_tree[2*vc[n]+1],3);Xc(e,e.dyn_ltree,t-1),Xc(e,e.dyn_dtree,r-1)},tl=e=>{let t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return Za;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return Xa;for(t=32;t<ac;t++)if(0!==e.dyn_ltree[2*t])return Xa;return Za};let rl=!1;const sl=e=>{rl||($c(),rl=!0),e.l_desc=new Lc(e.dyn_ltree,Dc),e.d_desc=new Lc(e.dyn_dtree,Nc),e.bl_desc=new Lc(e.bl_tree,Oc),e.bi_buf=0,e.bi_valid=0,Kc(e)},nl=(e,t,r,s)=>{Bc(e,(tc<<1)+(s?1:0),3),qc(e,t,r,!0)},il=e=>{Bc(e,rc<<1,3),Uc(e,yc,Ic),Vc(e)},ol=(e,t,r,s)=>{let n,i,o=0;e.level>0?(e.strm.data_type===Ja&&(e.strm.data_type=tl(e)),Qc(e,e.l_desc),Qc(e,e.d_desc),o=Jc(e),n=e.opt_len+3+7>>>3,i=e.static_len+3+7>>>3,i<=n&&(n=i)):n=i=r+5,r+4<=n&&-1!==t?nl(e,t,r,s):e.strategy===Qa||i===n?(Bc(e,(rc<<1)+(s?1:0),3),Yc(e,Ic,kc)):(Bc(e,(sc<<1)+(s?1:0),3),el(e,e.l_desc.max_code+1,e.d_desc.max_code+1,o+1),Yc(e,e.dyn_ltree,e.dyn_dtree)),Kc(e),s&&Hc(e)},al=(e,t,r)=>(e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(Tc[r]+ac+1)]++,e.dyn_dtree[2*xc(t)]++),e.last_lit===e.lit_bufsize-1);var cl=sl,ll=nl,ul=ol,hl=al,dl=il,pl={_tr_init:cl,_tr_stored_block:ll,_tr_flush_block:ul,_tr_tally:hl,_tr_align:dl};const fl=(e,t,r,s)=>{let n=65535&e|0,i=e>>>16&65535|0,o=0;while(0!==r){o=r>2e3?2e3:r,r-=o;do{n=n+t[s++]|0,i=i+n|0}while(--o);n%=65521,i%=65521}return n|i<<16|0};var yl=fl;const gl=()=>{let e,t=[];for(var r=0;r<256;r++){e=r;for(var s=0;s<8;s++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t},ml=new Uint32Array(gl()),wl=(e,t,r,s)=>{const n=ml,i=s+r;e^=-1;for(let o=s;o<i;o++)e=e>>>8^n[255&(e^t[o])];return-1^e};var bl=wl,_l={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},El={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:vl,_tr_stored_block:Sl,_tr_flush_block:Il,_tr_tally:kl,_tr_align:Rl}=pl,{Z_NO_FLUSH:Tl,Z_PARTIAL_FLUSH:Al,Z_FULL_FLUSH:Cl,Z_FINISH:Pl,Z_BLOCK:Dl,Z_OK:Nl,Z_STREAM_END:Ol,Z_STREAM_ERROR:Ll,Z_DATA_ERROR:xl,Z_BUF_ERROR:Ml,Z_DEFAULT_COMPRESSION:Bl,Z_FILTERED:Ul,Z_HUFFMAN_ONLY:jl,Z_RLE:Vl,Z_FIXED:zl,Z_DEFAULT_STRATEGY:Fl,Z_UNKNOWN:$l,Z_DEFLATED:Kl}=El,Hl=9,ql=15,Gl=8,Wl=29,Yl=256,Ql=Yl+1+Wl,Zl=30,Xl=19,Jl=2*Ql+1,eu=15,tu=3,ru=258,su=ru+tu+1,nu=32,iu=42,ou=69,au=73,cu=91,lu=103,uu=113,hu=666,du=1,pu=2,fu=3,yu=4,gu=3,mu=(e,t)=>(e.msg=_l[t],t),wu=e=>(e<<1)-(e>4?9:0),bu=e=>{let t=e.length;while(--t>=0)e[t]=0};let _u=(e,t,r)=>(t<<e.hash_shift^r)&e.hash_mask,Eu=_u;const vu=e=>{const t=e.state;let r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(e.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+r),e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))},Su=(e,t)=>{Il(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,vu(e.strm)},Iu=(e,t)=>{e.pending_buf[e.pending++]=t},ku=(e,t)=>{e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t},Ru=(e,t,r,s)=>{let n=e.avail_in;return n>s&&(n=s),0===n?0:(e.avail_in-=n,t.set(e.input.subarray(e.next_in,e.next_in+n),r),1===e.state.wrap?e.adler=yl(e.adler,t,n,r):2===e.state.wrap&&(e.adler=bl(e.adler,t,n,r)),e.next_in+=n,e.total_in+=n,n)},Tu=(e,t)=>{let r,s,n=e.max_chain_length,i=e.strstart,o=e.prev_length,a=e.nice_match;const c=e.strstart>e.w_size-su?e.strstart-(e.w_size-su):0,l=e.window,u=e.w_mask,h=e.prev,d=e.strstart+ru;let p=l[i+o-1],f=l[i+o];e.prev_length>=e.good_match&&(n>>=2),a>e.lookahead&&(a=e.lookahead);do{if(r=t,l[r+o]===f&&l[r+o-1]===p&&l[r]===l[i]&&l[++r]===l[i+1]){i+=2,r++;do{}while(l[++i]===l[++r]&&l[++i]===l[++r]&&l[++i]===l[++r]&&l[++i]===l[++r]&&l[++i]===l[++r]&&l[++i]===l[++r]&&l[++i]===l[++r]&&l[++i]===l[++r]&&i<d);if(s=ru-(d-i),i=d-ru,s>o){if(e.match_start=t,o=s,s>=a)break;p=l[i+o-1],f=l[i+o]}}}while((t=h[t&u])>c&&0!==--n);return o<=e.lookahead?o:e.lookahead},Au=e=>{const t=e.w_size;let r,s,n,i,o;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=t+(t-su)){e.window.set(e.window.subarray(t,t+t),0),e.match_start-=t,e.strstart-=t,e.block_start-=t,s=e.hash_size,r=s;do{n=e.head[--r],e.head[r]=n>=t?n-t:0}while(--s);s=t,r=s;do{n=e.prev[--r],e.prev[r]=n>=t?n-t:0}while(--s);i+=t}if(0===e.strm.avail_in)break;if(s=Ru(e.strm,e.window,e.strstart+e.lookahead,i),e.lookahead+=s,e.lookahead+e.insert>=tu){o=e.strstart-e.insert,e.ins_h=e.window[o],e.ins_h=Eu(e,e.ins_h,e.window[o+1]);while(e.insert)if(e.ins_h=Eu(e,e.ins_h,e.window[o+tu-1]),e.prev[o&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=o,o++,e.insert--,e.lookahead+e.insert<tu)break}}while(e.lookahead<su&&0!==e.strm.avail_in)},Cu=(e,t)=>{let r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(Au(e),0===e.lookahead&&t===Tl)return du;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;const s=e.block_start+r;if((0===e.strstart||e.strstart>=s)&&(e.lookahead=e.strstart-s,e.strstart=s,Su(e,!1),0===e.strm.avail_out))return du;if(e.strstart-e.block_start>=e.w_size-su&&(Su(e,!1),0===e.strm.avail_out))return du}return e.insert=0,t===Pl?(Su(e,!0),0===e.strm.avail_out?fu:yu):(e.strstart>e.block_start&&(Su(e,!1),e.strm.avail_out),du)},Pu=(e,t)=>{let r,s;for(;;){if(e.lookahead<su){if(Au(e),e.lookahead<su&&t===Tl)return du;if(0===e.lookahead)break}if(r=0,e.lookahead>=tu&&(e.ins_h=Eu(e,e.ins_h,e.window[e.strstart+tu-1]),r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-su&&(e.match_length=Tu(e,r)),e.match_length>=tu)if(s=kl(e,e.strstart-e.match_start,e.match_length-tu),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=tu){e.match_length--;do{e.strstart++,e.ins_h=Eu(e,e.ins_h,e.window[e.strstart+tu-1]),r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!==--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=Eu(e,e.ins_h,e.window[e.strstart+1]);else s=kl(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(s&&(Su(e,!1),0===e.strm.avail_out))return du}return e.insert=e.strstart<tu-1?e.strstart:tu-1,t===Pl?(Su(e,!0),0===e.strm.avail_out?fu:yu):e.last_lit&&(Su(e,!1),0===e.strm.avail_out)?du:pu},Du=(e,t)=>{let r,s,n;for(;;){if(e.lookahead<su){if(Au(e),e.lookahead<su&&t===Tl)return du;if(0===e.lookahead)break}if(r=0,e.lookahead>=tu&&(e.ins_h=Eu(e,e.ins_h,e.window[e.strstart+tu-1]),r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=tu-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-su&&(e.match_length=Tu(e,r),e.match_length<=5&&(e.strategy===Ul||e.match_length===tu&&e.strstart-e.match_start>4096)&&(e.match_length=tu-1)),e.prev_length>=tu&&e.match_length<=e.prev_length){n=e.strstart+e.lookahead-tu,s=kl(e,e.strstart-1-e.prev_match,e.prev_length-tu),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=n&&(e.ins_h=Eu(e,e.ins_h,e.window[e.strstart+tu-1]),r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!==--e.prev_length);if(e.match_available=0,e.match_length=tu-1,e.strstart++,s&&(Su(e,!1),0===e.strm.avail_out))return du}else if(e.match_available){if(s=kl(e,0,e.window[e.strstart-1]),s&&Su(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return du}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(s=kl(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<tu-1?e.strstart:tu-1,t===Pl?(Su(e,!0),0===e.strm.avail_out?fu:yu):e.last_lit&&(Su(e,!1),0===e.strm.avail_out)?du:pu},Nu=(e,t)=>{let r,s,n,i;const o=e.window;for(;;){if(e.lookahead<=ru){if(Au(e),e.lookahead<=ru&&t===Tl)return du;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=tu&&e.strstart>0&&(n=e.strstart-1,s=o[n],s===o[++n]&&s===o[++n]&&s===o[++n])){i=e.strstart+ru;do{}while(s===o[++n]&&s===o[++n]&&s===o[++n]&&s===o[++n]&&s===o[++n]&&s===o[++n]&&s===o[++n]&&s===o[++n]&&n<i);e.match_length=ru-(i-n),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=tu?(r=kl(e,1,e.match_length-tu),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=kl(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(Su(e,!1),0===e.strm.avail_out))return du}return e.insert=0,t===Pl?(Su(e,!0),0===e.strm.avail_out?fu:yu):e.last_lit&&(Su(e,!1),0===e.strm.avail_out)?du:pu},Ou=(e,t)=>{let r;for(;;){if(0===e.lookahead&&(Au(e),0===e.lookahead)){if(t===Tl)return du;break}if(e.match_length=0,r=kl(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(Su(e,!1),0===e.strm.avail_out))return du}return e.insert=0,t===Pl?(Su(e,!0),0===e.strm.avail_out?fu:yu):e.last_lit&&(Su(e,!1),0===e.strm.avail_out)?du:pu};function Lu(e,t,r,s,n){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=s,this.func=n}const xu=[new Lu(0,0,0,0,Cu),new Lu(4,4,8,4,Pu),new Lu(4,5,16,8,Pu),new Lu(4,6,32,32,Pu),new Lu(4,4,16,16,Du),new Lu(8,16,32,32,Du),new Lu(8,16,128,128,Du),new Lu(8,32,128,256,Du),new Lu(32,128,258,1024,Du),new Lu(32,258,258,4096,Du)],Mu=e=>{e.window_size=2*e.w_size,bu(e.head),e.max_lazy_match=xu[e.level].max_lazy,e.good_match=xu[e.level].good_length,e.nice_match=xu[e.level].nice_length,e.max_chain_length=xu[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=tu-1,e.match_available=0,e.ins_h=0};function Bu(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Kl,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(2*Jl),this.dyn_dtree=new Uint16Array(2*(2*Zl+1)),this.bl_tree=new Uint16Array(2*(2*Xl+1)),bu(this.dyn_ltree),bu(this.dyn_dtree),bu(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(eu+1),this.heap=new Uint16Array(2*Ql+1),bu(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*Ql+1),bu(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const Uu=e=>{if(!e||!e.state)return mu(e,Ll);e.total_in=e.total_out=0,e.data_type=$l;const t=e.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?iu:uu,e.adler=2===t.wrap?0:1,t.last_flush=Tl,vl(t),Nl},ju=e=>{const t=Uu(e);return t===Nl&&Mu(e.state),t},Vu=(e,t)=>e&&e.state?2!==e.state.wrap?Ll:(e.state.gzhead=t,Nl):Ll,zu=(e,t,r,s,n,i)=>{if(!e)return Ll;let o=1;if(t===Bl&&(t=6),s<0?(o=0,s=-s):s>15&&(o=2,s-=16),n<1||n>Hl||r!==Kl||s<8||s>15||t<0||t>9||i<0||i>zl)return mu(e,Ll);8===s&&(s=9);const a=new Bu;return e.state=a,a.strm=e,a.wrap=o,a.gzhead=null,a.w_bits=s,a.w_size=1<<a.w_bits,a.w_mask=a.w_size-1,a.hash_bits=n+7,a.hash_size=1<<a.hash_bits,a.hash_mask=a.hash_size-1,a.hash_shift=~~((a.hash_bits+tu-1)/tu),a.window=new Uint8Array(2*a.w_size),a.head=new Uint16Array(a.hash_size),a.prev=new Uint16Array(a.w_size),a.lit_bufsize=1<<n+6,a.pending_buf_size=4*a.lit_bufsize,a.pending_buf=new Uint8Array(a.pending_buf_size),a.d_buf=1*a.lit_bufsize,a.l_buf=3*a.lit_bufsize,a.level=t,a.strategy=i,a.method=r,ju(e)},Fu=(e,t)=>zu(e,t,Kl,ql,Gl,Fl),$u=(e,t)=>{let r,s;if(!e||!e.state||t>Dl||t<0)return e?mu(e,Ll):Ll;const n=e.state;if(!e.output||!e.input&&0!==e.avail_in||n.status===hu&&t!==Pl)return mu(e,0===e.avail_out?Ml:Ll);n.strm=e;const i=n.last_flush;if(n.last_flush=t,n.status===iu)if(2===n.wrap)e.adler=0,Iu(n,31),Iu(n,139),Iu(n,8),n.gzhead?(Iu(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),Iu(n,255&n.gzhead.time),Iu(n,n.gzhead.time>>8&255),Iu(n,n.gzhead.time>>16&255),Iu(n,n.gzhead.time>>24&255),Iu(n,9===n.level?2:n.strategy>=jl||n.level<2?4:0),Iu(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(Iu(n,255&n.gzhead.extra.length),Iu(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=bl(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=ou):(Iu(n,0),Iu(n,0),Iu(n,0),Iu(n,0),Iu(n,0),Iu(n,9===n.level?2:n.strategy>=jl||n.level<2?4:0),Iu(n,gu),n.status=uu);else{let t=Kl+(n.w_bits-8<<4)<<8,r=-1;r=n.strategy>=jl||n.level<2?0:n.level<6?1:6===n.level?2:3,t|=r<<6,0!==n.strstart&&(t|=nu),t+=31-t%31,n.status=uu,ku(n,t),0!==n.strstart&&(ku(n,e.adler>>>16),ku(n,65535&e.adler)),e.adler=1}if(n.status===ou)if(n.gzhead.extra){r=n.pending;while(n.gzindex<(65535&n.gzhead.extra.length)){if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>r&&(e.adler=bl(e.adler,n.pending_buf,n.pending-r,r)),vu(e),r=n.pending,n.pending===n.pending_buf_size))break;Iu(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++}n.gzhead.hcrc&&n.pending>r&&(e.adler=bl(e.adler,n.pending_buf,n.pending-r,r)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=au)}else n.status=au;if(n.status===au)if(n.gzhead.name){r=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>r&&(e.adler=bl(e.adler,n.pending_buf,n.pending-r,r)),vu(e),r=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,Iu(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>r&&(e.adler=bl(e.adler,n.pending_buf,n.pending-r,r)),0===s&&(n.gzindex=0,n.status=cu)}else n.status=cu;if(n.status===cu)if(n.gzhead.comment){r=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>r&&(e.adler=bl(e.adler,n.pending_buf,n.pending-r,r)),vu(e),r=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,Iu(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>r&&(e.adler=bl(e.adler,n.pending_buf,n.pending-r,r)),0===s&&(n.status=lu)}else n.status=lu;if(n.status===lu&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&vu(e),n.pending+2<=n.pending_buf_size&&(Iu(n,255&e.adler),Iu(n,e.adler>>8&255),e.adler=0,n.status=uu)):n.status=uu),0!==n.pending){if(vu(e),0===e.avail_out)return n.last_flush=-1,Nl}else if(0===e.avail_in&&wu(t)<=wu(i)&&t!==Pl)return mu(e,Ml);if(n.status===hu&&0!==e.avail_in)return mu(e,Ml);if(0!==e.avail_in||0!==n.lookahead||t!==Tl&&n.status!==hu){let r=n.strategy===jl?Ou(n,t):n.strategy===Vl?Nu(n,t):xu[n.level].func(n,t);if(r!==fu&&r!==yu||(n.status=hu),r===du||r===fu)return 0===e.avail_out&&(n.last_flush=-1),Nl;if(r===pu&&(t===Al?Rl(n):t!==Dl&&(Sl(n,0,0,!1),t===Cl&&(bu(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),vu(e),0===e.avail_out))return n.last_flush=-1,Nl}return t!==Pl?Nl:n.wrap<=0?Ol:(2===n.wrap?(Iu(n,255&e.adler),Iu(n,e.adler>>8&255),Iu(n,e.adler>>16&255),Iu(n,e.adler>>24&255),Iu(n,255&e.total_in),Iu(n,e.total_in>>8&255),Iu(n,e.total_in>>16&255),Iu(n,e.total_in>>24&255)):(ku(n,e.adler>>>16),ku(n,65535&e.adler)),vu(e),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?Nl:Ol)},Ku=e=>{if(!e||!e.state)return Ll;const t=e.state.status;return t!==iu&&t!==ou&&t!==au&&t!==cu&&t!==lu&&t!==uu&&t!==hu?mu(e,Ll):(e.state=null,t===uu?mu(e,xl):Nl)},Hu=(e,t)=>{let r=t.length;if(!e||!e.state)return Ll;const s=e.state,n=s.wrap;if(2===n||1===n&&s.status!==iu||s.lookahead)return Ll;if(1===n&&(e.adler=yl(e.adler,t,r,0)),s.wrap=0,r>=s.w_size){0===n&&(bu(s.head),s.strstart=0,s.block_start=0,s.insert=0);let e=new Uint8Array(s.w_size);e.set(t.subarray(r-s.w_size,r),0),t=e,r=s.w_size}const i=e.avail_in,o=e.next_in,a=e.input;e.avail_in=r,e.next_in=0,e.input=t,Au(s);while(s.lookahead>=tu){let e=s.strstart,t=s.lookahead-(tu-1);do{s.ins_h=Eu(s,s.ins_h,s.window[e+tu-1]),s.prev[e&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=e,e++}while(--t);s.strstart=e,s.lookahead=tu-1,Au(s)}return s.strstart+=s.lookahead,s.block_start=s.strstart,s.insert=s.lookahead,s.lookahead=0,s.match_length=s.prev_length=tu-1,s.match_available=0,e.next_in=o,e.input=a,e.avail_in=i,s.wrap=n,Nl};var qu=Fu,Gu=zu,Wu=ju,Yu=Uu,Qu=Vu,Zu=$u,Xu=Ku,Ju=Hu,eh="pako deflate (from Nodeca project)",th={deflateInit:qu,deflateInit2:Gu,deflateReset:Wu,deflateResetKeep:Yu,deflateSetHeader:Qu,deflate:Zu,deflateEnd:Xu,deflateSetDictionary:Ju,deflateInfo:eh};const rh=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var sh=function(e){const t=Array.prototype.slice.call(arguments,1);while(t.length){const r=t.shift();if(r){if("object"!==typeof r)throw new TypeError(r+"must be non-object");for(const t in r)rh(r,t)&&(e[t]=r[t])}}return e},nh=e=>{let t=0;for(let s=0,n=e.length;s<n;s++)t+=e[s].length;const r=new Uint8Array(t);for(let s=0,n=0,i=e.length;s<i;s++){let t=e[s];r.set(t,n),n+=t.length}return r},ih={assign:sh,flattenChunks:nh};let oh=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(cx){oh=!1}const ah=new Uint8Array(256);for(let lx=0;lx<256;lx++)ah[lx]=lx>=252?6:lx>=248?5:lx>=240?4:lx>=224?3:lx>=192?2:1;ah[254]=ah[254]=1;var ch=e=>{if("function"===typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);let t,r,s,n,i,o=e.length,a=0;for(n=0;n<o;n++)r=e.charCodeAt(n),55296===(64512&r)&&n+1<o&&(s=e.charCodeAt(n+1),56320===(64512&s)&&(r=65536+(r-55296<<10)+(s-56320),n++)),a+=r<128?1:r<2048?2:r<65536?3:4;for(t=new Uint8Array(a),i=0,n=0;i<a;n++)r=e.charCodeAt(n),55296===(64512&r)&&n+1<o&&(s=e.charCodeAt(n+1),56320===(64512&s)&&(r=65536+(r-55296<<10)+(s-56320),n++)),r<128?t[i++]=r:r<2048?(t[i++]=192|r>>>6,t[i++]=128|63&r):r<65536?(t[i++]=224|r>>>12,t[i++]=128|r>>>6&63,t[i++]=128|63&r):(t[i++]=240|r>>>18,t[i++]=128|r>>>12&63,t[i++]=128|r>>>6&63,t[i++]=128|63&r);return t};const lh=(e,t)=>{if(t<65534&&e.subarray&&oh)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));let r="";for(let s=0;s<t;s++)r+=String.fromCharCode(e[s]);return r};var uh=(e,t)=>{const r=t||e.length;if("function"===typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));let s,n;const i=new Array(2*r);for(n=0,s=0;s<r;){let t=e[s++];if(t<128){i[n++]=t;continue}let o=ah[t];if(o>4)i[n++]=65533,s+=o-1;else{t&=2===o?31:3===o?15:7;while(o>1&&s<r)t=t<<6|63&e[s++],o--;o>1?i[n++]=65533:t<65536?i[n++]=t:(t-=65536,i[n++]=55296|t>>10&1023,i[n++]=56320|1023&t)}}return lh(i,n)},hh=(e,t)=>{t=t||e.length,t>e.length&&(t=e.length);let r=t-1;while(r>=0&&128===(192&e[r]))r--;return r<0||0===r?t:r+ah[e[r]]>t?r:t},dh={string2buf:ch,buf2string:uh,utf8border:hh};function ph(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var fh=ph;const yh=Object.prototype.toString,{Z_NO_FLUSH:gh,Z_SYNC_FLUSH:mh,Z_FULL_FLUSH:wh,Z_FINISH:bh,Z_OK:_h,Z_STREAM_END:Eh,Z_DEFAULT_COMPRESSION:vh,Z_DEFAULT_STRATEGY:Sh,Z_DEFLATED:Ih}=El;function kh(e){this.options=ih.assign({level:vh,method:Ih,chunkSize:16384,windowBits:15,memLevel:8,strategy:Sh},e||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new fh,this.strm.avail_out=0;let r=th.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==_h)throw new Error(_l[r]);if(t.header&&th.deflateSetHeader(this.strm,t.header),t.dictionary){let e;if(e="string"===typeof t.dictionary?dh.string2buf(t.dictionary):"[object ArrayBuffer]"===yh.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,r=th.deflateSetDictionary(this.strm,e),r!==_h)throw new Error(_l[r]);this._dict_set=!0}}function Rh(e,t){const r=new kh(t);if(r.push(e,!0),r.err)throw r.msg||_l[r.err];return r.result}function Th(e,t){return t=t||{},t.raw=!0,Rh(e,t)}function Ah(e,t){return t=t||{},t.gzip=!0,Rh(e,t)}kh.prototype.push=function(e,t){const r=this.strm,s=this.options.chunkSize;let n,i;if(this.ended)return!1;for(i=t===~~t?t:!0===t?bh:gh,"string"===typeof e?r.input=dh.string2buf(e):"[object ArrayBuffer]"===yh.call(e)?r.input=new Uint8Array(e):r.input=e,r.next_in=0,r.avail_in=r.input.length;;)if(0===r.avail_out&&(r.output=new Uint8Array(s),r.next_out=0,r.avail_out=s),(i===mh||i===wh)&&r.avail_out<=6)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else{if(n=th.deflate(r,i),n===Eh)return r.next_out>0&&this.onData(r.output.subarray(0,r.next_out)),n=th.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===_h;if(0!==r.avail_out){if(i>0&&r.next_out>0)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else if(0===r.avail_in)break}else this.onData(r.output)}return!0},kh.prototype.onData=function(e){this.chunks.push(e)},kh.prototype.onEnd=function(e){e===_h&&(this.result=ih.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Ch=kh,Ph=Rh,Dh=Th,Nh=Ah,Oh=El,Lh={Deflate:Ch,deflate:Ph,deflateRaw:Dh,gzip:Nh,constants:Oh};const xh=30,Mh=12;var Bh=function(e,t){let r,s,n,i,o,a,c,l,u,h,d,p,f,y,g,m,w,b,_,E,v,S,I,k;const R=e.state;r=e.next_in,I=e.input,s=r+(e.avail_in-5),n=e.next_out,k=e.output,i=n-(t-e.avail_out),o=n+(e.avail_out-257),a=R.dmax,c=R.wsize,l=R.whave,u=R.wnext,h=R.window,d=R.hold,p=R.bits,f=R.lencode,y=R.distcode,g=(1<<R.lenbits)-1,m=(1<<R.distbits)-1;e:do{p<15&&(d+=I[r++]<<p,p+=8,d+=I[r++]<<p,p+=8),w=f[d&g];t:for(;;){if(b=w>>>24,d>>>=b,p-=b,b=w>>>16&255,0===b)k[n++]=65535&w;else{if(!(16&b)){if(0===(64&b)){w=f[(65535&w)+(d&(1<<b)-1)];continue t}if(32&b){R.mode=Mh;break e}e.msg="invalid literal/length code",R.mode=xh;break e}_=65535&w,b&=15,b&&(p<b&&(d+=I[r++]<<p,p+=8),_+=d&(1<<b)-1,d>>>=b,p-=b),p<15&&(d+=I[r++]<<p,p+=8,d+=I[r++]<<p,p+=8),w=y[d&m];r:for(;;){if(b=w>>>24,d>>>=b,p-=b,b=w>>>16&255,!(16&b)){if(0===(64&b)){w=y[(65535&w)+(d&(1<<b)-1)];continue r}e.msg="invalid distance code",R.mode=xh;break e}if(E=65535&w,b&=15,p<b&&(d+=I[r++]<<p,p+=8,p<b&&(d+=I[r++]<<p,p+=8)),E+=d&(1<<b)-1,E>a){e.msg="invalid distance too far back",R.mode=xh;break e}if(d>>>=b,p-=b,b=n-i,E>b){if(b=E-b,b>l&&R.sane){e.msg="invalid distance too far back",R.mode=xh;break e}if(v=0,S=h,0===u){if(v+=c-b,b<_){_-=b;do{k[n++]=h[v++]}while(--b);v=n-E,S=k}}else if(u<b){if(v+=c+u-b,b-=u,b<_){_-=b;do{k[n++]=h[v++]}while(--b);if(v=0,u<_){b=u,_-=b;do{k[n++]=h[v++]}while(--b);v=n-E,S=k}}}else if(v+=u-b,b<_){_-=b;do{k[n++]=h[v++]}while(--b);v=n-E,S=k}while(_>2)k[n++]=S[v++],k[n++]=S[v++],k[n++]=S[v++],_-=3;_&&(k[n++]=S[v++],_>1&&(k[n++]=S[v++]))}else{v=n-E;do{k[n++]=k[v++],k[n++]=k[v++],k[n++]=k[v++],_-=3}while(_>2);_&&(k[n++]=k[v++],_>1&&(k[n++]=k[v++]))}break}}break}}while(r<s&&n<o);_=p>>3,r-=_,p-=_<<3,d&=(1<<p)-1,e.next_in=r,e.next_out=n,e.avail_in=r<s?s-r+5:5-(r-s),e.avail_out=n<o?o-n+257:257-(n-o),R.hold=d,R.bits=p};const Uh=15,jh=852,Vh=592,zh=0,Fh=1,$h=2,Kh=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Hh=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),qh=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),Gh=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),Wh=(e,t,r,s,n,i,o,a)=>{const c=a.bits;let l,u,h,d,p,f,y=0,g=0,m=0,w=0,b=0,_=0,E=0,v=0,S=0,I=0,k=null,R=0;const T=new Uint16Array(Uh+1),A=new Uint16Array(Uh+1);let C,P,D,N=null,O=0;for(y=0;y<=Uh;y++)T[y]=0;for(g=0;g<s;g++)T[t[r+g]]++;for(b=c,w=Uh;w>=1;w--)if(0!==T[w])break;if(b>w&&(b=w),0===w)return n[i++]=20971520,n[i++]=20971520,a.bits=1,0;for(m=1;m<w;m++)if(0!==T[m])break;for(b<m&&(b=m),v=1,y=1;y<=Uh;y++)if(v<<=1,v-=T[y],v<0)return-1;if(v>0&&(e===zh||1!==w))return-1;for(A[1]=0,y=1;y<Uh;y++)A[y+1]=A[y]+T[y];for(g=0;g<s;g++)0!==t[r+g]&&(o[A[t[r+g]]++]=g);if(e===zh?(k=N=o,f=19):e===Fh?(k=Kh,R-=257,N=Hh,O-=257,f=256):(k=qh,N=Gh,f=-1),I=0,g=0,y=m,p=i,_=b,E=0,h=-1,S=1<<b,d=S-1,e===Fh&&S>jh||e===$h&&S>Vh)return 1;for(;;){C=y-E,o[g]<f?(P=0,D=o[g]):o[g]>f?(P=N[O+o[g]],D=k[R+o[g]]):(P=96,D=0),l=1<<y-E,u=1<<_,m=u;do{u-=l,n[p+(I>>E)+u]=C<<24|P<<16|D|0}while(0!==u);l=1<<y-1;while(I&l)l>>=1;if(0!==l?(I&=l-1,I+=l):I=0,g++,0===--T[y]){if(y===w)break;y=t[r+o[g]]}if(y>b&&(I&d)!==h){0===E&&(E=b),p+=m,_=y-E,v=1<<_;while(_+E<w){if(v-=T[_+E],v<=0)break;_++,v<<=1}if(S+=1<<_,e===Fh&&S>jh||e===$h&&S>Vh)return 1;h=I&d,n[h]=b<<24|_<<16|p-i|0}}return 0!==I&&(n[p+I]=y-E<<24|64<<16|0),a.bits=b,0};var Yh=Wh;const Qh=0,Zh=1,Xh=2,{Z_FINISH:Jh,Z_BLOCK:ed,Z_TREES:td,Z_OK:rd,Z_STREAM_END:sd,Z_NEED_DICT:nd,Z_STREAM_ERROR:id,Z_DATA_ERROR:od,Z_MEM_ERROR:ad,Z_BUF_ERROR:cd,Z_DEFLATED:ld}=El,ud=1,hd=2,dd=3,pd=4,fd=5,yd=6,gd=7,md=8,wd=9,bd=10,_d=11,Ed=12,vd=13,Sd=14,Id=15,kd=16,Rd=17,Td=18,Ad=19,Cd=20,Pd=21,Dd=22,Nd=23,Od=24,Ld=25,xd=26,Md=27,Bd=28,Ud=29,jd=30,Vd=31,zd=32,Fd=852,$d=592,Kd=15,Hd=Kd,qd=e=>(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24);function Gd(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const Wd=e=>{if(!e||!e.state)return id;const t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=ud,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(Fd),t.distcode=t.distdyn=new Int32Array($d),t.sane=1,t.back=-1,rd},Yd=e=>{if(!e||!e.state)return id;const t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,Wd(e)},Qd=(e,t)=>{let r;if(!e||!e.state)return id;const s=e.state;return t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?id:(null!==s.window&&s.wbits!==t&&(s.window=null),s.wrap=r,s.wbits=t,Yd(e))},Zd=(e,t)=>{if(!e)return id;const r=new Gd;e.state=r,r.window=null;const s=Qd(e,t);return s!==rd&&(e.state=null),s},Xd=e=>Zd(e,Hd);let Jd,ep,tp=!0;const rp=e=>{if(tp){Jd=new Int32Array(512),ep=new Int32Array(32);let t=0;while(t<144)e.lens[t++]=8;while(t<256)e.lens[t++]=9;while(t<280)e.lens[t++]=7;while(t<288)e.lens[t++]=8;Yh(Zh,e.lens,0,288,Jd,0,e.work,{bits:9}),t=0;while(t<32)e.lens[t++]=5;Yh(Xh,e.lens,0,32,ep,0,e.work,{bits:5}),tp=!1}e.lencode=Jd,e.lenbits=9,e.distcode=ep,e.distbits=5},sp=(e,t,r,s)=>{let n;const i=e.state;return null===i.window&&(i.wsize=1<<i.wbits,i.wnext=0,i.whave=0,i.window=new Uint8Array(i.wsize)),s>=i.wsize?(i.window.set(t.subarray(r-i.wsize,r),0),i.wnext=0,i.whave=i.wsize):(n=i.wsize-i.wnext,n>s&&(n=s),i.window.set(t.subarray(r-s,r-s+n),i.wnext),s-=n,s?(i.window.set(t.subarray(r-s,r),0),i.wnext=s,i.whave=i.wsize):(i.wnext+=n,i.wnext===i.wsize&&(i.wnext=0),i.whave<i.wsize&&(i.whave+=n))),0},np=(e,t)=>{let r,s,n,i,o,a,c,l,u,h,d,p,f,y,g,m,w,b,_,E,v,S,I=0;const k=new Uint8Array(4);let R,T;const A=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return id;r=e.state,r.mode===Ed&&(r.mode=vd),o=e.next_out,n=e.output,c=e.avail_out,i=e.next_in,s=e.input,a=e.avail_in,l=r.hold,u=r.bits,h=a,d=c,S=rd;e:for(;;)switch(r.mode){case ud:if(0===r.wrap){r.mode=vd;break}while(u<16){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(2&r.wrap&&35615===l){r.check=0,k[0]=255&l,k[1]=l>>>8&255,r.check=bl(r.check,k,2,0),l=0,u=0,r.mode=hd;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&l)<<8)+(l>>8))%31){e.msg="incorrect header check",r.mode=jd;break}if((15&l)!==ld){e.msg="unknown compression method",r.mode=jd;break}if(l>>>=4,u-=4,v=8+(15&l),0===r.wbits)r.wbits=v;else if(v>r.wbits){e.msg="invalid window size",r.mode=jd;break}r.dmax=1<<r.wbits,e.adler=r.check=1,r.mode=512&l?bd:Ed,l=0,u=0;break;case hd:while(u<16){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(r.flags=l,(255&r.flags)!==ld){e.msg="unknown compression method",r.mode=jd;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=jd;break}r.head&&(r.head.text=l>>8&1),512&r.flags&&(k[0]=255&l,k[1]=l>>>8&255,r.check=bl(r.check,k,2,0)),l=0,u=0,r.mode=dd;case dd:while(u<32){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}r.head&&(r.head.time=l),512&r.flags&&(k[0]=255&l,k[1]=l>>>8&255,k[2]=l>>>16&255,k[3]=l>>>24&255,r.check=bl(r.check,k,4,0)),l=0,u=0,r.mode=pd;case pd:while(u<16){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}r.head&&(r.head.xflags=255&l,r.head.os=l>>8),512&r.flags&&(k[0]=255&l,k[1]=l>>>8&255,r.check=bl(r.check,k,2,0)),l=0,u=0,r.mode=fd;case fd:if(1024&r.flags){while(u<16){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}r.length=l,r.head&&(r.head.extra_len=l),512&r.flags&&(k[0]=255&l,k[1]=l>>>8&255,r.check=bl(r.check,k,2,0)),l=0,u=0}else r.head&&(r.head.extra=null);r.mode=yd;case yd:if(1024&r.flags&&(p=r.length,p>a&&(p=a),p&&(r.head&&(v=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Uint8Array(r.head.extra_len)),r.head.extra.set(s.subarray(i,i+p),v)),512&r.flags&&(r.check=bl(r.check,s,p,i)),a-=p,i+=p,r.length-=p),r.length))break e;r.length=0,r.mode=gd;case gd:if(2048&r.flags){if(0===a)break e;p=0;do{v=s[i+p++],r.head&&v&&r.length<65536&&(r.head.name+=String.fromCharCode(v))}while(v&&p<a);if(512&r.flags&&(r.check=bl(r.check,s,p,i)),a-=p,i+=p,v)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=md;case md:if(4096&r.flags){if(0===a)break e;p=0;do{v=s[i+p++],r.head&&v&&r.length<65536&&(r.head.comment+=String.fromCharCode(v))}while(v&&p<a);if(512&r.flags&&(r.check=bl(r.check,s,p,i)),a-=p,i+=p,v)break e}else r.head&&(r.head.comment=null);r.mode=wd;case wd:if(512&r.flags){while(u<16){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(l!==(65535&r.check)){e.msg="header crc mismatch",r.mode=jd;break}l=0,u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=Ed;break;case bd:while(u<32){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}e.adler=r.check=qd(l),l=0,u=0,r.mode=_d;case _d:if(0===r.havedict)return e.next_out=o,e.avail_out=c,e.next_in=i,e.avail_in=a,r.hold=l,r.bits=u,nd;e.adler=r.check=1,r.mode=Ed;case Ed:if(t===ed||t===td)break e;case vd:if(r.last){l>>>=7&u,u-=7&u,r.mode=Md;break}while(u<3){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}switch(r.last=1&l,l>>>=1,u-=1,3&l){case 0:r.mode=Sd;break;case 1:if(rp(r),r.mode=Cd,t===td){l>>>=2,u-=2;break e}break;case 2:r.mode=Rd;break;case 3:e.msg="invalid block type",r.mode=jd}l>>>=2,u-=2;break;case Sd:l>>>=7&u,u-=7&u;while(u<32){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if((65535&l)!==(l>>>16^65535)){e.msg="invalid stored block lengths",r.mode=jd;break}if(r.length=65535&l,l=0,u=0,r.mode=Id,t===td)break e;case Id:r.mode=kd;case kd:if(p=r.length,p){if(p>a&&(p=a),p>c&&(p=c),0===p)break e;n.set(s.subarray(i,i+p),o),a-=p,i+=p,c-=p,o+=p,r.length-=p;break}r.mode=Ed;break;case Rd:while(u<14){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(r.nlen=257+(31&l),l>>>=5,u-=5,r.ndist=1+(31&l),l>>>=5,u-=5,r.ncode=4+(15&l),l>>>=4,u-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=jd;break}r.have=0,r.mode=Td;case Td:while(r.have<r.ncode){while(u<3){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}r.lens[A[r.have++]]=7&l,l>>>=3,u-=3}while(r.have<19)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,R={bits:r.lenbits},S=Yh(Qh,r.lens,0,19,r.lencode,0,r.work,R),r.lenbits=R.bits,S){e.msg="invalid code lengths set",r.mode=jd;break}r.have=0,r.mode=Ad;case Ad:while(r.have<r.nlen+r.ndist){for(;;){if(I=r.lencode[l&(1<<r.lenbits)-1],g=I>>>24,m=I>>>16&255,w=65535&I,g<=u)break;if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(w<16)l>>>=g,u-=g,r.lens[r.have++]=w;else{if(16===w){T=g+2;while(u<T){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(l>>>=g,u-=g,0===r.have){e.msg="invalid bit length repeat",r.mode=jd;break}v=r.lens[r.have-1],p=3+(3&l),l>>>=2,u-=2}else if(17===w){T=g+3;while(u<T){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}l>>>=g,u-=g,v=0,p=3+(7&l),l>>>=3,u-=3}else{T=g+7;while(u<T){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}l>>>=g,u-=g,v=0,p=11+(127&l),l>>>=7,u-=7}if(r.have+p>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=jd;break}while(p--)r.lens[r.have++]=v}}if(r.mode===jd)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=jd;break}if(r.lenbits=9,R={bits:r.lenbits},S=Yh(Zh,r.lens,0,r.nlen,r.lencode,0,r.work,R),r.lenbits=R.bits,S){e.msg="invalid literal/lengths set",r.mode=jd;break}if(r.distbits=6,r.distcode=r.distdyn,R={bits:r.distbits},S=Yh(Xh,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,R),r.distbits=R.bits,S){e.msg="invalid distances set",r.mode=jd;break}if(r.mode=Cd,t===td)break e;case Cd:r.mode=Pd;case Pd:if(a>=6&&c>=258){e.next_out=o,e.avail_out=c,e.next_in=i,e.avail_in=a,r.hold=l,r.bits=u,Bh(e,d),o=e.next_out,n=e.output,c=e.avail_out,i=e.next_in,s=e.input,a=e.avail_in,l=r.hold,u=r.bits,r.mode===Ed&&(r.back=-1);break}for(r.back=0;;){if(I=r.lencode[l&(1<<r.lenbits)-1],g=I>>>24,m=I>>>16&255,w=65535&I,g<=u)break;if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(m&&0===(240&m)){for(b=g,_=m,E=w;;){if(I=r.lencode[E+((l&(1<<b+_)-1)>>b)],g=I>>>24,m=I>>>16&255,w=65535&I,b+g<=u)break;if(0===a)break e;a--,l+=s[i++]<<u,u+=8}l>>>=b,u-=b,r.back+=b}if(l>>>=g,u-=g,r.back+=g,r.length=w,0===m){r.mode=xd;break}if(32&m){r.back=-1,r.mode=Ed;break}if(64&m){e.msg="invalid literal/length code",r.mode=jd;break}r.extra=15&m,r.mode=Dd;case Dd:if(r.extra){T=r.extra;while(u<T){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}r.length+=l&(1<<r.extra)-1,l>>>=r.extra,u-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=Nd;case Nd:for(;;){if(I=r.distcode[l&(1<<r.distbits)-1],g=I>>>24,m=I>>>16&255,w=65535&I,g<=u)break;if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(0===(240&m)){for(b=g,_=m,E=w;;){if(I=r.distcode[E+((l&(1<<b+_)-1)>>b)],g=I>>>24,m=I>>>16&255,w=65535&I,b+g<=u)break;if(0===a)break e;a--,l+=s[i++]<<u,u+=8}l>>>=b,u-=b,r.back+=b}if(l>>>=g,u-=g,r.back+=g,64&m){e.msg="invalid distance code",r.mode=jd;break}r.offset=w,r.extra=15&m,r.mode=Od;case Od:if(r.extra){T=r.extra;while(u<T){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}r.offset+=l&(1<<r.extra)-1,l>>>=r.extra,u-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=jd;break}r.mode=Ld;case Ld:if(0===c)break e;if(p=d-c,r.offset>p){if(p=r.offset-p,p>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=jd;break}p>r.wnext?(p-=r.wnext,f=r.wsize-p):f=r.wnext-p,p>r.length&&(p=r.length),y=r.window}else y=n,f=o-r.offset,p=r.length;p>c&&(p=c),c-=p,r.length-=p;do{n[o++]=y[f++]}while(--p);0===r.length&&(r.mode=Pd);break;case xd:if(0===c)break e;n[o++]=r.length,c--,r.mode=Pd;break;case Md:if(r.wrap){while(u<32){if(0===a)break e;a--,l|=s[i++]<<u,u+=8}if(d-=c,e.total_out+=d,r.total+=d,d&&(e.adler=r.check=r.flags?bl(r.check,n,d,o-d):yl(r.check,n,d,o-d)),d=c,(r.flags?l:qd(l))!==r.check){e.msg="incorrect data check",r.mode=jd;break}l=0,u=0}r.mode=Bd;case Bd:if(r.wrap&&r.flags){while(u<32){if(0===a)break e;a--,l+=s[i++]<<u,u+=8}if(l!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=jd;break}l=0,u=0}r.mode=Ud;case Ud:S=sd;break e;case jd:S=od;break e;case Vd:return ad;case zd:default:return id}return e.next_out=o,e.avail_out=c,e.next_in=i,e.avail_in=a,r.hold=l,r.bits=u,(r.wsize||d!==e.avail_out&&r.mode<jd&&(r.mode<Md||t!==Jh))&&sp(e,e.output,e.next_out,d-e.avail_out),h-=e.avail_in,d-=e.avail_out,e.total_in+=h,e.total_out+=d,r.total+=d,r.wrap&&d&&(e.adler=r.check=r.flags?bl(r.check,n,d,e.next_out-d):yl(r.check,n,d,e.next_out-d)),e.data_type=r.bits+(r.last?64:0)+(r.mode===Ed?128:0)+(r.mode===Cd||r.mode===Id?256:0),(0===h&&0===d||t===Jh)&&S===rd&&(S=cd),S},ip=e=>{if(!e||!e.state)return id;let t=e.state;return t.window&&(t.window=null),e.state=null,rd},op=(e,t)=>{if(!e||!e.state)return id;const r=e.state;return 0===(2&r.wrap)?id:(r.head=t,t.done=!1,rd)},ap=(e,t)=>{const r=t.length;let s,n,i;return e&&e.state?(s=e.state,0!==s.wrap&&s.mode!==_d?id:s.mode===_d&&(n=1,n=yl(n,t,r,0),n!==s.check)?od:(i=sp(e,t,r,r),i?(s.mode=Vd,ad):(s.havedict=1,rd))):id};var cp=Yd,lp=Qd,up=Wd,hp=Xd,dp=Zd,pp=np,fp=ip,yp=op,gp=ap,mp="pako inflate (from Nodeca project)",wp={inflateReset:cp,inflateReset2:lp,inflateResetKeep:up,inflateInit:hp,inflateInit2:dp,inflate:pp,inflateEnd:fp,inflateGetHeader:yp,inflateSetDictionary:gp,inflateInfo:mp};function bp(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var _p=bp;const Ep=Object.prototype.toString,{Z_NO_FLUSH:vp,Z_FINISH:Sp,Z_OK:Ip,Z_STREAM_END:kp,Z_NEED_DICT:Rp,Z_STREAM_ERROR:Tp,Z_DATA_ERROR:Ap,Z_MEM_ERROR:Cp}=El;function Pp(e){this.options=ih.assign({chunkSize:65536,windowBits:15,to:""},e||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0===(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new fh,this.strm.avail_out=0;let r=wp.inflateInit2(this.strm,t.windowBits);if(r!==Ip)throw new Error(_l[r]);if(this.header=new _p,wp.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"===typeof t.dictionary?t.dictionary=dh.string2buf(t.dictionary):"[object ArrayBuffer]"===Ep.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(r=wp.inflateSetDictionary(this.strm,t.dictionary),r!==Ip)))throw new Error(_l[r])}function Dp(e,t){const r=new Pp(t);if(r.push(e),r.err)throw r.msg||_l[r.err];return r.result}function Np(e,t){return t=t||{},t.raw=!0,Dp(e,t)}Pp.prototype.push=function(e,t){const r=this.strm,s=this.options.chunkSize,n=this.options.dictionary;let i,o,a;if(this.ended)return!1;for(o=t===~~t?t:!0===t?Sp:vp,"[object ArrayBuffer]"===Ep.call(e)?r.input=new Uint8Array(e):r.input=e,r.next_in=0,r.avail_in=r.input.length;;){0===r.avail_out&&(r.output=new Uint8Array(s),r.next_out=0,r.avail_out=s),i=wp.inflate(r,o),i===Rp&&n&&(i=wp.inflateSetDictionary(r,n),i===Ip?i=wp.inflate(r,o):i===Ap&&(i=Rp));while(r.avail_in>0&&i===kp&&r.state.wrap>0&&0!==e[r.next_in])wp.inflateReset(r),i=wp.inflate(r,o);switch(i){case Tp:case Ap:case Rp:case Cp:return this.onEnd(i),this.ended=!0,!1}if(a=r.avail_out,r.next_out&&(0===r.avail_out||i===kp))if("string"===this.options.to){let e=dh.utf8border(r.output,r.next_out),t=r.next_out-e,n=dh.buf2string(r.output,e);r.next_out=t,r.avail_out=s-t,t&&r.output.set(r.output.subarray(e,e+t),0),this.onData(n)}else this.onData(r.output.length===r.next_out?r.output:r.output.subarray(0,r.next_out));if(i!==Ip||0!==a){if(i===kp)return i=wp.inflateEnd(this.strm),this.onEnd(i),this.ended=!0,!0;if(0===r.avail_in)break}}return!0},Pp.prototype.onData=function(e){this.chunks.push(e)},Pp.prototype.onEnd=function(e){e===Ip&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=ih.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Op=Pp,Lp=Dp,xp=Np,Mp=Dp,Bp=El,Up={Inflate:Op,inflate:Lp,inflateRaw:xp,ungzip:Mp,constants:Bp};const{Deflate:jp,deflate:Vp,deflateRaw:zp,gzip:Fp}=Lh,{Inflate:$p,inflate:Kp,inflateRaw:Hp,ungzip:qp}=Up;var Gp=jp,Wp=Vp,Yp=zp,Qp=Fp,Zp=$p,Xp=Kp,Jp=Hp,ef=qp,tf=El,rf={Deflate:Gp,deflate:Wp,deflateRaw:Yp,gzip:Qp,Inflate:Zp,inflate:Xp,inflateRaw:Jp,ungzip:ef,constants:tf};const sf=6;function nf({repo:e,preload:t}){async function*r(r,s={}){if(null!=s.compressionLevel&&(s.compressionLevel<-1||s.compressionLevel>9))throw h(new Error("Compression level must be between -1 and 9"),"ERR_INVALID_PARAMS");if(!1!==s.preload){let e;try{e=It(r).split("/")}catch(mu){throw h(mu,"ERR_INVALID_PATH")}t(A.CID.parse(e[0]))}const n=A.CID.asCID(r)||r,i=await ga(n,e.blocks,s);if("file"===i.type||"raw"===i.type){const e=[];return s.compress&&!0!==s.archive?e.push(i.content):e.push([{header:{name:i.path,mode:"file"===i.type&&i.unixfs.mode,mtime:"file"===i.type&&i.unixfs.mtime?new Date(1e3*i.unixfs.mtime.secs):void 0,size:i.size,type:"file"},body:i.content()}],Ya(),(e=>As(e,(e=>e.slice())))),s.compress&&e.push((async function*(e){const t=await Ea(e);yield rf.gzip(t,{level:s.compressionLevel||sf})})),void(yield*(0,Cs.zG)(...e))}if("directory"!==i.type)throw h(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");{const t=[ma(n,e.blocks,s),async function*(e){for await(const t of e){const e={header:{name:t.path,size:t.size}};if("file"===t.type)e.header.type="file",e.header.mode=null!=t.unixfs.mode?t.unixfs.mode:void 0,e.header.mtime=t.unixfs.mtime?new Date(1e3*t.unixfs.mtime.secs):void 0,e.body=t.content();else if("raw"===t.type)e.header.type="file",e.body=t.content();else{if("directory"!==t.type)throw h(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");e.header.type="directory",e.header.mode=null!=t.unixfs.mode?t.unixfs.mode:void 0,e.header.mtime=t.unixfs.mtime?new Date(1e3*t.unixfs.mtime.secs):void 0}yield e}},Ya(),e=>As(e,(e=>e.slice()))];if(s.compress){if(!s.archive)throw h(new Error("file is not regular"),"ERR_INVALID_PATH");s.compress&&t.push((async function*(e){const t=await Ea(e);yield rf.gzip(t,{level:s.compressionLevel||sf})}))}yield*(0,Cs.zG)(...t)}}return gt(r)}function of({repo:e,preload:t}){async function*r(r,s={}){const n=It(r),i=n.split("/");!1!==s.preload&&t(A.CID.parse(i[0]));const o=A.CID.asCID(n)||n,a=await ga(o,e.blocks,s);if("file"!==a.type){if("directory"!==a.type)throw h(new Error(`Unknown UnixFS type ${a.type}`),"ERR_UNKNOWN_UNIXFS_TYPE");for await(const e of a.content())yield Rt(e)}else yield Rt(a)}return gt(r)}class af{constructor({preload:e,repo:t,hashers:r,options:s}){const n=Po({preload:e,repo:t,options:s,hashers:r});this.addAll=n,this.add=Jn({addAll:n}),this.cat=wa({repo:t,preload:e}),this.get=nf({repo:t,preload:e}),this.ls=of({repo:t,preload:e})}}const cf="0.16.1",lf="d1f1e75b2060c5c2e64d133a7a6bbabd2641e5ef",uf="^0.156.1";function hf({repo:e}){async function t(t={}){const r=await e.version.get();return{version:cf,commit:lf,repo:`${r}`,"ipfs-core":cf,"interface-ipfs-core":uf}}return gt(t)}const df=(0,u.kg)("ipfs:components:id");function pf({peerId:e,network:t}){async function r(r={}){const s=t.try();if(!s){if(r.peerId)throw new Be;if(null==e.publicKey)throw h(new Error("Public key missing"),"ERR_MISSING_PUBLIC_KEY");return{id:e,publicKey:(0,Ye.B)(e.publicKey,"base64pad"),addresses:[],agentVersion:`js-ipfs/${cf}`,protocolVersion:"9000",protocols:[]}}const{libp2p:n}=s,i=r.peerId?r.peerId:e,o=await ff(i,n,r),a=(0,Ye.B)(o.metadata.get("AgentVersion")||new Uint8Array),c=(0,Ye.B)(o.metadata.get("ProtocolVersion")||new Uint8Array),l=o.id.toString(),u=o.publicKey?(0,Ye.B)(o.publicKey,"base64pad"):"";return{id:i,publicKey:u,addresses:(o.addresses||[]).map((e=>{const t=e.toString();return t.endsWith(`/p2p/${l}`)?t:`${t}/p2p/${l}`})).sort().map((e=>(0,qe.HM)(e))),agentVersion:a,protocolVersion:c,protocols:(o.protocols||[]).sort()}}return gt(r)}async function ff(e,t,r){let s=await t.peerStore.get(e);s||(s=await yf(e,t,r));let n=e.publicKey?e.publicKey:await t.peerStore.keyBook.get(e);if(null==n)try{n=await t.getPublicKey(e,r)}catch(mu){df.error("Could not load public key for",e.toString(),mu)}return{...s,publicKey:n,metadata:s.metadata||new Map,addresses:s.addresses.map((e=>e.multiaddr))}}async function yf(e,t,r){if(null==t.dht)throw h(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");for await(const n of t.dht.findPeer(e,r))if("FINAL_PEER"===n.name)break;const s=await t.peerStore.get(e);if(!s)throw h(new Error("Could not find peer"),"ERR_NOT_FOUND");return s}var gf=mf;function mf(e,t,r){var s,n,i;if(Array.isArray(t)&&(s=t.slice(0)),"string"==typeof t&&(s=t.split(".")),"symbol"==typeof t&&(s=[t]),!Array.isArray(s))throw new Error("props arg must be an array, a string or a symbol");if(n=s.pop(),!n)return!1;wf(n);while(i=s.shift())if(wf(i),"undefined"==typeof e[i]&&(e[i]={}),e=e[i],!e||"object"!=typeof e)return!1;return e[n]=r,!0}function wf(e){if("__proto__"==e||"constructor"==e||"prototype"==e)throw new Error("setting of prototype values not supported")}const bf={server:{description:"Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",transform:e=>(gf(e,"Discovery.MDNS.Enabled",!1),gf(e,"Discovery.webRTCStar.Enabled",!1),e.Swarm={...e.Swarm||{},DisableNatPortMap:!0},e)},"local-discovery":{description:"Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",transform:e=>(gf(e,"Discovery.MDNS.Enabled",!0),gf(e,"Discovery.webRTCStar.Enabled",!0),gf(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!1}),e)},test:{description:"Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",transform:e=>{const t=An();return gf(e,"Addresses.API",t.Addresses.API?"/ip4/127.0.0.1/tcp/0":""),gf(e,"Addresses.Gateway",t.Addresses.Gateway?"/ip4/127.0.0.1/tcp/0":""),gf(e,"Addresses.Swarm",t.Addresses.Swarm.length?["/ip4/127.0.0.1/tcp/0"]:[]),gf(e,"Addresses.Delegates",[]),gf(e,"Bootstrap",[]),gf(e,"Discovery.MDNS.Enabled",!1),gf(e,"Discovery.webRTCStar.Enabled",!1),gf(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!0}),e}},"default-networking":{description:"Restores default network settings. Inverse profile of the `test` profile.",transform:e=>{const t=An();return gf(e,"Addresses.API",t.Addresses.API),gf(e,"Addresses.Gateway",t.Addresses.Gateway),gf(e,"Addresses.Swarm",t.Addresses.Swarm),gf(e,"Addresses.Delegates",t.Addresses.Delegates),gf(e,"Bootstrap",t.Bootstrap),gf(e,"Discovery.MDNS.Enabled",t.Discovery.MDNS.Enabled),gf(e,"Discovery.webRTCStar.Enabled",t.Discovery.webRTCStar.Enabled),gf(e,"Swarm",{...e.Swarm||{},DisableNatPortMap:!1}),e}},lowpower:{description:"Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",transform:e=>{const t=e.Swarm||{},r=t.ConnMgr||{};return r.LowWater=20,r.HighWater=40,t.ConnMgr=r,e.Swarm=t,e}},"default-power":{description:'Inverse of "lowpower" profile.',transform:e=>{const t=An();return e.Swarm=t.Swarm,e}}},_f=(0,u.kg)("ipfs:core:config");function Ef({repo:e}){return{getAll:gt(t),get:gt(r),set:gt(s),replace:gt(n),profiles:{apply:gt(i),list:gt(vf)}};async function t(t={}){return e.config.getAll(t)}async function r(t,r){return t?e.config.get(t,r):Promise.reject(new Error("key argument is required"))}async function s(t,r,s){return e.config.set(t,r,s)}async function n(t,r){return e.config.replace(t,r)}async function i(t,r={dryRun:!1}){const{dryRun:s}=r,n=bf[t];if(!n)throw new Error(`No profile with name '${t}' exists`);try{const t=await e.config.getAll(r);let i=JSON.parse(JSON.stringify(t));return i=n.transform(i),s||await e.config.replace(i,r),delete t.Identity.PrivKey,delete i.Identity.PrivKey,{original:t,updated:i}}catch(mu){throw _f(mu),new Error(`Could not apply profile '${t}' to config: ${mu.message}`)}}}async function vf(e){return Object.keys(bf).map((e=>({name:e,description:bf[e].description})))}var Sf=r(2798),If=r(94676);function kf(e){const t=U({version:1,roots:e}),r=If.encode(t.length),s=new Uint8Array(r.length+t.length);return s.set(r,0),s.set(t,r.length),s}function Rf(e){return{async setRoots(t){const r=kf(t);await e.write(r)},async writeBlock(t){const{cid:r,bytes:s}=t;await e.write(new Uint8Array(If.encode(r.bytes.length+s.length))),await e.write(r.bytes),s.length&&await e.write(s)},async close(){await e.end()}}}function Tf(){}function Af(){const e=[];let t=null,r=Tf,s=!1,n=null,i=Tf;const o=()=>(t||(t=new Promise((e=>{r=()=>{t=null,r=Tf,e()}}))),t),a={write(t){e.push(t);const r=o();return i(),r},async end(){s=!0;const e=o();i(),await e}},c={async next(){const t=e.shift();return t?(0===e.length&&r(),{done:!1,value:t}):s?(r(),{done:!0,value:void 0}):(n||(n=new Promise((e=>{i=()=>(n=null,i=Tf,e(c.next()))}))),n)}};return{writer:a,iterator:c}}const Cf={Null:e=>null===e,Int:e=>Number.isInteger(e),Float:e=>"number"===typeof e&&Number.isFinite(e),String:e=>"string"===typeof e,Bool:e=>"boolean"===typeof e,Bytes:e=>e instanceof Uint8Array,Link:e=>!Cf.Null(e)&&"object"===typeof e&&e.asCID===e,List:e=>Array.isArray(e),Map:e=>!Cf.Null(e)&&"object"===typeof e&&e.asCID!==e&&!Cf.List(e)&&!Cf.Bytes(e)},Pf={Int:Cf.Int,"CarHeader > version":e=>Pf.Int(e),"CarHeader > roots (anon) > valueType (anon)":Cf.Link,"CarHeader > roots (anon)":e=>Cf.List(e)&&Array.prototype.every.call(e,Pf["CarHeader > roots (anon) > valueType (anon)"]),"CarHeader > roots":e=>Pf["CarHeader > roots (anon)"](e),CarHeader:e=>{const t=e&&Object.keys(e);return Cf.Map(e)&&["version"].every((e=>t.includes(e)))&&Object.entries(e).every((([e,t])=>Pf["CarHeader > "+e]&&Pf["CarHeader > "+e](t)))}},Df=Pf.CarHeader,Nf={SHA2_256:18,LENGTH:32,DAG_PB:112},Of=40;async function Lf(e){const t=await e.upTo(8);if(!t.length)throw new Error("Unexpected end of data");const r=If.decode(t);return e.seek(If.decode.bytes),r}async function xf(e){const t=await e.exactly(Of),r=new DataView(t.buffer,t.byteOffset,t.byteLength);let s=0;const n={version:2,characteristics:[r.getBigUint64(s,!0),r.getBigUint64(s+=8,!0)],dataOffset:Number(r.getBigUint64(s+=8,!0)),dataSize:Number(r.getBigUint64(s+=8,!0)),indexOffset:Number(r.getBigUint64(s+=8,!0))};return e.seek(Of),n}async function Mf(e,t){const r=await Lf(e);if(0===r)throw new Error("Invalid CAR header (zero length)");const s=await e.exactly(r);e.seek(r);const n=j(s);if(!Df(n))throw new Error("Invalid CAR header format");if(1!==n.version&&2!==n.version||void 0!==t&&n.version!==t)throw new Error(`Invalid CAR version: ${n.version}${void 0!==t?` (expected ${t})`:""}`);const i=Array.isArray(n.roots);if(1===n.version&&!i||2===n.version&&i)throw new Error("Invalid CAR header format");if(1===n.version)return n;const o=await xf(e);e.seek(o.dataOffset-e.pos);const a=await Mf(e,1);return Object.assign(a,o)}async function Bf(e){const t=await e.upTo(8);If.decode(t);const r=If.decode.bytes,s=If.decode(t.subarray(If.decode.bytes)),n=If.decode.bytes,i=r+n+s,o=await e.exactly(i);return e.seek(i),o}async function Uf(e){const t=await e.exactly(2);if(t[0]===Nf.SHA2_256&&t[1]===Nf.LENGTH){const t=await e.exactly(34);e.seek(34);const r=He.Jx(t);return A.CID.create(0,Nf.DAG_PB,r)}const r=await Lf(e);if(1!==r)throw new Error(`Unexpected CID version (${r})`);const s=await Lf(e),n=await Bf(e),i=He.Jx(n);return A.CID.create(r,s,i)}async function jf(e){const t=e.pos;let r=await Lf(e);if(0===r)throw new Error("Invalid CAR section (zero length)");r+=e.pos-t;const s=await Uf(e),n=r-Number(e.pos-t);return{cid:s,length:r,blockLength:n}}async function Vf(e){const{cid:t,blockLength:r}=await jf(e),s=await e.exactly(r);return e.seek(r),{bytes:s,cid:t}}async function zf(e){const t=e.pos,{cid:r,length:s,blockLength:n}=await jf(e),i={cid:r,length:s,blockLength:n,offset:t,blockOffset:e.pos};return e.seek(i.blockLength),i}function Ff(e){const t=(async()=>{const t=await Mf(e);if(2===t.version){const r=e.pos-t.dataOffset;e=qf(e,t.dataSize-r)}return t})();return{header:()=>t,async*blocks(){await t;while((await e.upTo(8)).length>0)yield await Vf(e)},async*blocksIndex(){await t;while((await e.upTo(8)).length>0)yield await zf(e)}}}function $f(e){let t=0;return{async upTo(r){return e.subarray(t,t+Math.min(r,e.length-t))},async exactly(r){if(r>e.length-t)throw new Error("Unexpected end of data");return e.subarray(t,t+r)},seek(e){t+=e},get pos(){return t}}}function Kf(e){let t=0,r=0,s=0,n=new Uint8Array(0);const i=async t=>{r=n.length-s;const i=[n.subarray(s)];while(r<t){const t=await e();if(null==t)break;r<0?t.length>r&&i.push(t.subarray(-r)):i.push(t),r+=t.length}n=new Uint8Array(i.reduce(((e,t)=>e+t.length),0));let o=0;for(const e of i)n.set(e,o),o+=e.length;s=0};return{async upTo(e){return n.length-s<e&&await i(e),n.subarray(s,s+Math.min(n.length-s,e))},async exactly(e){if(n.length-s<e&&await i(e),n.length-s<e)throw new Error("Unexpected end of data");return n.subarray(s,s+e)},seek(e){t+=e,s+=e},get pos(){return t}}}function Hf(e){const t=e[Symbol.asyncIterator]();async function r(){const e=await t.next();return e.done?null:e.value}return Kf(r)}function qf(e,t){let r=0;return{async upTo(s){let n=await e.upTo(s);return n.length+r>t&&(n=n.subarray(0,t-r)),n},async exactly(s){const n=await e.exactly(s);if(n.length+r>t)throw new Error("Unexpected end of data");return n},seek(t){r+=t,e.seek(t)},get pos(){return e.pos}}}class Gf{constructor(e,t){this._encoder=t,this._mutex=t.setRoots(e),this._ended=!1}async put(e){if(!(e.bytes instanceof Uint8Array)||!e.cid)throw new TypeError("Can only write {cid, bytes} objects");if(this._ended)throw new Error("Already closed");const t=A.CID.asCID(e.cid);if(!t)throw new TypeError("Can only write {cid, bytes} objects");return this._mutex=this._mutex.then((()=>this._encoder.writeBlock({cid:t,bytes:e.bytes}))),this._mutex}async close(){if(this._ended)throw new Error("Already closed");return await this._mutex,this._ended=!0,this._encoder.close()}static create(e){e=Qf(e);const{encoder:t,iterator:r}=Yf(),s=new Gf(e,t),n=new Wf(r);return{writer:s,out:n}}static createAppender(){const{encoder:e,iterator:t}=Yf();e.setRoots=()=>Promise.resolve();const r=new Gf([],e),s=new Wf(t);return{writer:r,out:s}}static async updateRootsInBytes(e,t){const r=$f(e);await Mf(r);const s=kf(t);if(Number(r.pos)!==s.length)throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${r.pos} bytes, new header is ${s.length} bytes)`);return e.set(s,0),e}}class Wf{constructor(e){this._iterator=e}[Symbol.asyncIterator](){if(this._iterating)throw new Error("Multiple iterator not supported");return this._iterating=!0,this._iterator}}function Yf(){const e=Af(),{writer:t,iterator:r}=e,s=Rf(t);return{encoder:s,iterator:r}}function Qf(e){if(void 0===e)return[];if(!Array.isArray(e)){const t=A.CID.asCID(e);if(!t)throw new TypeError("roots must be a single CID or an array of CIDs");return[t]}const t=[];for(const r of e){const e=A.CID.asCID(r);if(!e)throw new TypeError("roots must be a single CID or an array of CIDs");t.push(e)}return t}var Zf=r(40950);const Xf=async({cid:e,load:t,seen:r})=>{r=r||new Set;const s=e.toString($e.base58btc);if(r.has(s))return;const n=await t(e);if(r.add(s),null!==n)for(const[,i]of n.links())await Xf({cid:i,load:t,seen:r})},Jf=(0,u.kg)("ipfs:components:dag:import"),ey=[pi.code,Zf.code];function ty({repo:e,preload:t,codecs:r}){async function*s(s,n={}){!1!==n.preload&&t(s);const i=A.CID.asCID(s);if(!i)throw new Error(`Unexpected error converting CID type: ${s}`);Jf(`Exporting ${i} as car`);const{writer:o,out:a}=await Gf.create([i]);let c=null;(async()=>{try{const t=ry(e,o,{signal:n.signal,timeout:n.timeout},r);await Xf({cid:i,load:t})}catch(t){c=t}finally{o.close()}})();for await(const e of a){if(c)break;yield e}if(c)throw c}return gt(s)}function ry(e,t,r,s){return async n=>{const i=await s.getCodec(n.code);if(!i)throw new Error(`Can't decode links in block with codec 0x${n.code.toString(16)} to form complete DAG`);const o=await e.blocks.get(n,r);return Jf(`Adding block ${n} to car`),await t.put({cid:n,bytes:o}),ey.includes(n.code)?null:(0,Sf.createUnsafe)({bytes:o,cid:n,codec:i})}}var sy=r(72262);function ny({codecs:e,repo:t,preload:r}){const s=async function(s,n={}){if(!1!==n.preload&&r(s),n.path){const r=n.localResolve?await sy(At(s,n.path,e,t,n)):await Wt(At(s,n.path,e,t,n)),i=r;if(!i)throw h(new Error("Not found"),"ERR_NOT_FOUND");return i}const i=await e.getCodec(s.code),o=await t.blocks.get(s,n),a=i.decode(o);return{value:a,remainderPath:""}};return gt(s)}class iy{constructor(e,t,r){this._version=e,this._roots=t,this._iterable=r,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class oy extends iy{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(e){const{version:t,roots:r,iterator:s}=await cy(e);return new oy(t,r,s)}static async fromIterable(e){const{version:t,roots:r,iterator:s}=await ly(e);return new oy(t,r,s)}}class ay extends(null){[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");this._decoded=!0;const e=this._iterable[Symbol.asyncIterator]();return{async next(){const t=await e.next();return t.done?t:{done:!1,value:t.value.cid}}}}static async fromBytes(e){const{version:t,roots:r,iterator:s}=await cy(e);return new ay(t,r,s)}static async fromIterable(e){const{version:t,roots:r,iterator:s}=await ly(e);return new ay(t,r,s)}}async function cy(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return uy($f(e))}async function ly(e){if(!e||"function"!==typeof e[Symbol.asyncIterator])throw new TypeError("fromIterable() requires an async iterable");return uy(Hf(e))}async function uy(e){const t=Ff(e),{version:r,roots:s}=await t.header();return{version:r,roots:s,iterator:t.blocks()}}const hy=(0,u.kg)("ipfs:components:dag:import");function dy({repo:e}){async function*t(t,r={}){const s=await e.gcLock.readLock();try{const n={signal:r.signal,timeout:r.timeout},i=Fn(t),{value:o,done:a}=await i.peek();if(a)return;let c;o&&i.push(o),c=o instanceof Uint8Array?[i]:i;for await(const t of c){const s=await py(e,n,t);if(!1!==r.pinRoots)for(const t of s){let r="";try{await e.blocks.has(t)?(hy(`Pinning root ${t}`),await e.pins.pinRecursively(t)):r="blockstore: block not found"}catch(mu){r=mu.message}yield{root:{cid:t,pinErrorMsg:r}}}}}finally{s()}}return gt(t)}async function py(e,t,r){const s=await oy.fromIterable(r),n=await s.getRoots();return await gs(e.blocks.putMany(As(s,(({cid:e,bytes:t})=>(hy(`Import block ${e}`),{key:e,value:t}))),{signal:t.signal})),n}function fy({repo:e,codecs:t,hashers:r,preload:s}){async function n(n,i={}){const o=i.pin?await e.gcLock.readLock():null;try{const a=await t.getCodec(i.storeCodec||"dag-cbor");if(!a)throw new Error(`Unknown storeCodec ${i.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(i.inputCodec){if(!(n instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");const e=await t.getCodec(i.inputCodec);if(!e)throw new Error(`Unknown inputCodec ${i.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);n=e.decode(n)}const c=null!=i.version?i.version:1,l=await r.getHasher(i.hashAlg||"sha2-256");if(!l)throw new Error(`Unknown hash algorithm ${i.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);const u=a.encode(n),h=await l.digest(u),d=A.CID.create(c,a.code,h);return await e.blocks.put(d,u,{signal:i.signal}),i.pin&&await e.pins.pinRecursively(d),!1!==i.preload&&s(d),d}finally{o&&o()}}return gt(n)}function yy({repo:e,codecs:t,preload:r}){async function s(s,n={}){const{cid:i}=wt(s);return!1!==n.preload&&r(i),kt(e,t,s,n)}return gt(s)}class gy{constructor({repo:e,codecs:t,hashers:r,preload:s}){this.export=ty({repo:e,preload:s,codecs:t}),this.get=ny({codecs:t,repo:e,preload:s}),this.import=dy({repo:e}),this.resolve=yy({repo:e,codecs:t,preload:s}),this.put=fy({repo:e,codecs:t,hashers:r,preload:s})}}var my=r(45182);function wy(e){if(!Array.isArray(e))throw new TypeError("Expected an array, got "+typeof e);e=[...e];for(let t=e.length-1;t>0;t--){const r=Math.floor(Math.random()*(t+1));[e[t],e[r]]=[e[r],e[t]]}return e}const by=(0,u.kg)("ipfs:preload"),_y=Lt.Z["default"]?Lt.Z["default"]:Lt.Z,Ey=new _y({concurrency:4});function vy(e,t={}){return by(e),Ey.add((async()=>{const r=await xt.post(e,{signal:t.signal}),s=r.body.getReader();try{while(1){const{done:e}=await s.read();if(e)return}}finally{s.releaseLock()}}))}const Sy=(0,u.kg)("ipfs:preload");function Iy(e={}){if(e.enabled=Boolean(e.enabled),e.addresses=e.addresses||[],e.cache=e.cache||1e3,!e.enabled||!e.addresses.length){Sy("preload disabled");const e=()=>{};return Object.assign(e,{start:()=>{},stop:()=>{}})}let t=!0,r=[];const s=e.addresses.map((e=>(0,my.k)(e))),n=Nt(e.cache),i=async e=>{try{if(t)throw new Error(`preload ${e} but preloader is not started`);const i=e.toString();if(n.has(i))return;n.set(i,!0);const o=wy(s);let a=!1;const c=Date.now();for(const e of o){if(t)throw new Error(`preload aborted for ${i}`);let s;try{s=new AbortController,r=r.concat(s),await vy(`${e}/api/v0/refs?r=true&arg=${encodeURIComponent(i)}`,{signal:s.signal}),a=!0}catch(mu){"aborted"!==mu.type&&Sy.error(mu)}finally{r=r.filter((e=>e!==s))}if(a)break}Sy(`${a?"":"un"}successfully preloaded ${i} in ${Date.now()-c}ms`)}catch(mu){Sy.error(mu)}};return i.start=()=>{t=!1},i.stop=()=>{t=!0,Sy(`aborting ${r.length} pending preload request(s)`),r.forEach((e=>e.abort())),r=[]},i}const ky=(0,u.kg)("ipfs:mfs-preload");function Ry({preload:e,files:t,options:r={}}){if(r.interval=r.interval||3e4,!r.enabled){ky("MFS preload disabled");const e=async()=>{};return{start:e,stop:e}}let s,n="";const i=async()=>{try{const o=await t.stat("/"),a=o.cid.toString();n!==a&&(ky(`preloading updated MFS root ${n} -> ${o.cid}`),await e(o.cid),n=a)}catch(mu){ky.error("failed to preload MFS root",mu)}finally{s=setTimeout(i,r.interval)}};return{async start(){const e=await t.stat("/");n=e.cid.toString(),ky(`monitoring MFS root ${e.cid}`),s=setTimeout(i,r.interval)},stop(){clearTimeout(s)}}}class Ty extends Error{constructor(e){super(e),this.name="TimeoutError"}}class Ay extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const Cy=e=>void 0===globalThis.DOMException?new Ay(e):new DOMException(e),Py=e=>{const t=void 0===e.reason?Cy("This operation was aborted."):e.reason;return t instanceof Error?t:Cy(t)};function Dy(e,t){const{milliseconds:r,fallback:s,message:n,customTimers:i={setTimeout:setTimeout,clearTimeout:clearTimeout}}=t;let o;const a=new Promise(((a,c)=>{if("number"!==typeof r||1!==Math.sign(r))throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${r}\``);if(r!==Number.POSITIVE_INFINITY){if(t.signal){const{signal:e}=t;e.aborted&&c(Py(e)),e.addEventListener("abort",(()=>{c(Py(e))}))}o=i.setTimeout.call(void 0,(()=>{if(s){try{a(s())}catch(o){c(o)}return}const t="string"===typeof n?n:`Promise timed out after ${r} milliseconds`,i=n instanceof Error?n:new Ty(t);"function"===typeof e.cancel&&e.cancel(),c(i)}),r),(async()=>{try{a(await e)}catch(t){c(t)}finally{i.clearTimeout.call(void 0,o)}})()}else a(e)}));return a.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},a}var Ny=r(53416);const Oy="lock:worker:request-read",Ly="lock:worker:release-read",xy="lock:master:grant-read",My="lock:worker:request-write",By="lock:worker:release-write",Uy="lock:master:grant-write",jy={},Vy=e=>{e.addEventListener("message",(t=>{Vy.dispatchEvent("message",e,t)})),null!=e.port&&e.port.addEventListener("message",(t=>{Vy.dispatchEvent("message",e,t)}))};Vy.addEventListener=(e,t)=>{null==jy[e]&&(jy[e]=[]),jy[e].push(t)},Vy.removeEventListener=(e,t)=>{null!=jy[e]&&(jy[e]=jy[e].filter((e=>e===t)))},Vy.dispatchEvent=function(e,t,r){null!=jy[e]&&jy[e].forEach((e=>e(t,r)))};var zy=Vy;const Fy=(e,t,r,s,n)=>(i,o)=>{if(o.data.type!==r)return;const a={type:o.data.type,name:o.data.name,identifier:o.data.identifier};e.dispatchEvent(new MessageEvent(t,{data:{name:a.name,handler:async()=>(i.postMessage({type:n,name:a.name,identifier:a.identifier}),await new Promise((e=>{const t=r=>{if(null==r||null==r.data)return;const n={type:r.data.type,name:r.data.name,identifier:r.data.identifier};n.type===s&&n.identifier===a.identifier&&(i.removeEventListener("message",t),e())};i.addEventListener("message",t)})))}}))},$y=(e,t,r,s)=>async()=>{const n=(0,Ny.x0)();return globalThis.postMessage({type:t,identifier:n,name:e}),await new Promise((t=>{const i=o=>{if(null==o||null==o.data)return;const a={type:o.data.type,identifier:o.data.identifier};a.type===r&&a.identifier===n&&(globalThis.removeEventListener("message",i),t((()=>{globalThis.postMessage({type:s,identifier:n,name:e})})))};globalThis.addEventListener("message",i)}))},Ky={singleProcess:!1};var Hy=e=>{e=Object.assign({},Ky,e);const t=Boolean(globalThis.document)||e.singleProcess;if(t){const e=new EventTarget;return zy.addEventListener("message",Fy(e,"requestReadLock",Oy,Ly,xy)),zy.addEventListener("message",Fy(e,"requestWriteLock",My,By,Uy)),e}return{isWorker:!0,readLock:e=>$y(e,Oy,xy,Ly),writeLock:e=>$y(e,My,Uy,By)}};const qy={};let Gy;async function Wy(e,t){let r;const s=new Promise((e=>{r=e}));return e.add((async()=>await Dy((async()=>await new Promise((e=>{r((()=>{e()}))})))(),{milliseconds:t.timeout}))),await s}const Yy=(e,t)=>{if(!0===Gy.isWorker)return{readLock:Gy.readLock(e,t),writeLock:Gy.writeLock(e,t)};const r=new Lt.Z({concurrency:1});let s;return{async readLock(){if(null!=s)return await Wy(s,t);s=new Lt.Z({concurrency:t.concurrency,autoStart:!1});const e=s,n=Wy(s,t);return r.add((async()=>(e.start(),await e.onIdle().then((()=>{s===e&&(s=null)}))))),await n},async writeLock(){return s=null,await Wy(r,t)}}},Qy={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function Zy(e){const t=Object.assign({},Qy,e);return null==Gy&&(Gy=Hy(t),!0!==Gy.isWorker&&(Gy.addEventListener("requestReadLock",(e=>{null!=qy[e.data.name]&&qy[e.data.name].readLock().then((async t=>await e.data.handler().finally((()=>t()))))})),Gy.addEventListener("requestWriteLock",(async e=>{null!=qy[e.data.name]&&qy[e.data.name].writeLock().then((async t=>await e.data.handler().finally((()=>t()))))})))),null==qy[t.name]&&(qy[t.name]=Yy(t.name,t)),qy[t.name]}let Xy;function Jy(e=!1){if(Xy)return Xy;const t=Zy({singleProcess:e});return Xy={readLock:e=>async(...r)=>{const s=await t.readLock();try{return await e.apply(null,r)}finally{s()}},writeLock:e=>async(...r)=>{const s=await t.writeLock();try{return await e.apply(null,r)}finally{s()}}},Xy}const eg=(0,u.kg)("ipfs:mfs:utils:with-mfs-root");async function tg(e,t){if(t&&t.signal&&t.signal.aborted)throw h(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});let r;await e.repo.datastore.open();try{const t=await e.repo.datastore.get(Et);r=A.CID.decode(t)}catch(mu){if("ERR_NOT_FOUND"!==mu.code)throw mu;eg("Creating new MFS root");const n=R.encode({Data:new k({type:"directory"}).marshal(),Links:[]}),i=await ti.sha256.digest(n);if(r=A.CID.createV0(i),await e.repo.blocks.put(r,n),t&&t.signal&&t.signal.aborted)throw h(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});await e.repo.datastore.put(Et,r.bytes)}return eg(`Loaded MFS root /ipfs/${r}`),r}function rg(e=""){return(e.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean)}const sg="ipfs",ng=async(e,t,r)=>{const s=await tg(e,r);let n={entryType:"file"},i="";if(i=A.CID.asCID(t)?`/ipfs/${t}`:t.toString(),i=i.trim(),i=i.replace(/(\/\/+)/g,"/"),i.endsWith("/")&&i.length>1&&(i=i.substring(0,i.length-1)),!i)throw h(new Error("paths must not be empty"),"ERR_NO_PATH");if("/"!==i.substring(0,1))throw h(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");"/"===i.substring(i.length-1)&&(i=i.substring(0,i.length-1));const o=rg(i);if(o[0]===sg){let e;e=2===o.length?`/${o.join("/")}`:`/${o.slice(0,o.length-1).join("/")}`,n={type:"ipfs",depth:o.length-2,entryType:"file",mfsPath:`/${o.join("/")}`,mfsDirectory:e,parts:o,path:`/${o.join("/")}`,name:o[o.length-1]}}else{const e=`/${sg}/${s}${o.length?"/"+o.join("/"):""}`,t=`/${sg}/${s}/${o.slice(0,o.length-1).join("/")}`;n={type:"mfs",depth:o.length,entryType:"file",mfsDirectory:t,mfsPath:e,parts:o,path:`/${o.join("/")}`,name:o[o.length-1]}}const a="mfs"===n.type?n.mfsPath:n.path;try{const t=await ga(a,e.repo.blocks,r);n.cid=t.cid,n.mfsPath=`/ipfs/${t.path}`,n.entryType=t.type,n.content=t.content,"file"!==n.entryType&&"directory"!==n.entryType||"file"!==t.type&&"directory"!==t.type||(n.unixfs=t.unixfs)}catch(mu){if("ERR_NOT_FOUND"!==mu.code)throw mu}return n.exists=Boolean(n.cid),n},ig=c.Z.bind({ignoreUndefined:!0}),og=(0,u.kg)("ipfs:mfs:stat"),ag={withLocal:!1};function cg(e){async function t(t,r={}){r=ig(ag,r),og(`Fetching stats for ${t}`);const{type:s,cid:n,mfsPath:i}=await ng(e,t,r),o="ipfs"===s&&n?n:i;let a;try{a=await ga(o,e.repo.blocks)}catch(mu){if("ERR_NOT_FOUND"===mu.code)throw h(new Error(`${t} does not exist`),"ERR_NOT_FOUND");throw mu}if(!lg[a.type])throw new Error(`Cannot stat codec ${a.cid.code}`);return lg[a.type](a)}return gt(t)}const lg={raw:e=>({cid:e.cid,size:e.node.length,cumulativeSize:e.node.length,blocks:0,type:"file",local:void 0,sizeLocal:void 0,withLocality:!1}),file:e=>{const t={cid:e.cid,type:"file",size:e.unixfs.fileSize(),cumulativeSize:R.encode(e.node).length+(e.node.Links||[]).reduce(((e,t)=>e+(t.Tsize||0)),0),blocks:e.unixfs.blockSizes.length,local:void 0,sizeLocal:void 0,withLocality:!1,mode:e.unixfs.mode};return e.unixfs.mtime&&(t.mtime=e.unixfs.mtime),t},directory:e=>{const t={cid:e.cid,type:"directory",size:0,cumulativeSize:R.encode(e.node).length+(e.node.Links||[]).reduce(((e,t)=>e+(t.Tsize||0)),0),blocks:e.node.Links.length,local:void 0,sizeLocal:void 0,withLocality:!1,mode:e.unixfs.mode};return e.unixfs.mtime&&(t.mtime=e.unixfs.mtime),t},object:e=>({cid:e.cid,size:e.node.length,cumulativeSize:e.node.length,type:"file",blocks:0,local:void 0,sizeLocal:void 0,withLocality:!1}),identity:e=>({cid:e.cid,size:e.node.length,cumulativeSize:e.node.length,blocks:0,type:"file",local:void 0,sizeLocal:void 0,withLocality:!1})},ug=(0,u.kg)("ipfs:mfs:utils:to-trail");async function hg(e,t){ug(`Creating trail for path ${t}`);const r=[];for await(const s of ya(t,e.repo.blocks))r.push({name:s.name,cid:s.cid,size:s.size,type:s.type});return r}const dg=async(e,t,r)=>{r.codec||(r.codec=R),r.hasher||(r.hasher=ti.sha256),void 0===r.cidVersion&&(r.cidVersion=1),r.codec===R&&r.hasher!==ti.sha256&&(r.cidVersion=1);const s=await r.hasher.digest(e),n=A.CID.create(r.cidVersion,r.codec.code,s);return r.onlyHash||await t.put(n,e,{signal:r.signal}),n},pg=ii.code,fg=8;async function yg(e){return(await ii.encode(e)).slice(0,8).reverse()}class gg{constructor(e,t){this.options=t||{},this.root=e.root,this.dir=e.dir,this.path=e.path,this.dirty=e.dirty,this.flat=e.flat,this.parent=e.parent,this.parentKey=e.parentKey,this.unixfs=e.unixfs,this.mode=e.mode,this.mtime=e.mtime,this.cid=void 0,this.size=void 0}async put(e,t){}get(e){return Promise.resolve(this)}async*eachChildSeries(){}async*flush(e){}}class mg extends gg{constructor(e,t){super(e,t),this._bucket=co({hashFn:yg,bits:fg})}async put(e,t){await this._bucket.put(e,t)}get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:t}of this._bucket.eachLeafSeries())yield{key:e,child:t}}async*flush(e){yield*wg(this._bucket,e,this,this.options)}}async function*wg(e,t,r,s){const n=e._children,i=[];let o=0;for(let p=0;p<n.length;p++){const e=n.get(p);if(!e)continue;const r=p.toString(16).toUpperCase().padStart(2,"0");if(e instanceof Qi){let n;for await(const r of await wg(e,t,null,s))n=r;if(!n)throw new Error("Could not flush sharded directory, no subshard found");i.push({Name:r,Tsize:n.size,Hash:n.cid}),o+=n.size}else if("function"===typeof e.value.flush){const s=e.value;let n;for await(const e of s.flush(t))n=e,yield n;const a=r+e.key;i.push({Name:a,Tsize:n.size,Hash:n.cid}),o+=n.size}else{const t=e.value;if(!t.cid)continue;const s=r+e.key,n=t.size;i.push({Name:s,Tsize:n,Hash:t.cid}),o+=n}}const a=Uint8Array.from(n.bitField().reverse()),c=new k({type:"hamt-sharded-directory",data:a,fanout:e.tableSize(),hashType:pg,mtime:r&&r.mtime,mode:r&&r.mode}),l={Data:c.marshal(),Links:i},u=(0,R.encode)((0,R.prepare)(l)),h=await dg(u,t,s),d=u.length+o;yield{cid:h,node:l,size:d}}const bg=(0,u.kg)("ipfs:mfs:core:utils:hamt-utils"),_g=async(e,t,r,s)=>{if(!s.parent.Data)throw new Error("Could not update HAMT directory because parent had no data");const n=Uint8Array.from(r._children.bitField().reverse()),i=k.unmarshal(s.parent.Data),o=new k({type:"hamt-sharded-directory",data:n,fanout:r.tableSize(),hashType:pg,mode:i.mode,mtime:i.mtime}),a=await e.hashers.getHasher(s.hashAlg),c={Data:o.marshal(),Links:t.sort(((e,t)=>(e.Name||"").localeCompare(t.Name||"")))},l=R.encode(c),u=await a.digest(l),h=A.CID.create(s.cidVersion,R.code,u);return s.flush&&await e.repo.blocks.put(h,l),{node:c,cid:h,size:t.reduce(((e,t)=>e+(t.Tsize||0)),l.length)}},Eg=async(e,t,r,s,n)=>{const i=new Qi({hash:r._options.hash,bits:r._options.bits},s,n);return s._putObjectAt(n,i),await Sg(e,t,i,r),i},vg=async e=>{const t=co({hashFn:yg,bits:fg});return await Promise.all(e.map((async e=>{const r=e.Name||"";if(2===r.length){const e=parseInt(r,16),s=new Qi({hash:t._options.hash,bits:t._options.bits},t,e);return t._putObjectAt(e,s),Promise.resolve()}return t.put(r.substring(2),{size:e.Tsize,cid:e.Hash})}))),t},Sg=async(e,t,r,s)=>{await Promise.all(t.map((async t=>{const n=t.Name||"";if(2===n.length){bg("Populating sub bucket",n);const i=parseInt(n,16),o=await e.repo.blocks.get(t.Hash),a=R.decode(o),c=new Qi({hash:s._options.hash,bits:s._options.bits},r,i);return r._putObjectAt(i,c),await Sg(e,a.Links,c,s),Promise.resolve()}return s.put(n.substring(2),{size:t.Tsize,cid:t.Hash})})))},Ig=e=>e.toString(16).toUpperCase().padStart(2,"0").substring(0,2),kg=async(e,t,r)=>{const s=await vg(r.Links),n=await s._findNewBucketAndPos(t),i=[{bucket:n.bucket,prefix:Ig(n.pos)}];let o=n.bucket;while(o!==s)i.push({bucket:o,prefix:Ig(o._posAtParent)}),o=o._parent;i.reverse(),i[0].node=r;for(let a=0;a<i.length;a++){const r=i[a];if(!r.node)throw new Error("Could not generate HAMT path");const n=r.node.Links.filter((e=>(e.Name||"").substring(0,2)===r.prefix)).pop();if(!n){bg(`Link ${r.prefix}${t} will be added`);continue}if(n.Name===`${r.prefix}${t}`){bg(`Link ${r.prefix}${t} will be replaced`);continue}bg(`Found subshard ${r.prefix}`);const o=await e.repo.blocks.get(n.Hash),c=R.decode(o);if(!i[a+1]){bg(`Loaded new subshard ${r.prefix}`),await Eg(e,c.Links,s,r.bucket,parseInt(r.prefix,16));const n=await s._findNewBucketAndPos(t);i.push({bucket:n.bucket,prefix:Ig(n.pos),node:c});continue}const l=i[a+1];await Sg(e,c.Links,l.bucket,s),l.node=c}return await s.put(t,!0),i.reverse(),{rootBucket:s,path:i}},Rg=async(e,t,r={})=>{const s=new mg({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mtime:r.mtime,mode:r.mode},r);for(let i=0;i<t.length;i++)await s._bucket.put(t[i].name,{size:t[i].size,cid:t[i].cid});const n=await Wt(s.flush(e.repo.blocks));if(!n)throw new Error("Flushing shard yielded no result");return n},Tg=(0,u.kg)("ipfs:mfs:core:utils:add-link");async function Ag(e,t){let r=t.parent;if(t.parentCid){const s=A.CID.asCID(t.parentCid);if(null===s)throw h(new Error("Invalid CID passed to addLink"),"EINVALIDPARENTCID");if(s.code!==R.code)throw h(new Error("Unsupported codec. Only DAG-PB is supported"),"EINVALIDPARENTCID");Tg(`Loading parent node ${s}`);const n=await e.repo.blocks.get(s);r=R.decode(n)}if(!r)throw h(new Error("No parent node or CID passed to addLink"),"EINVALIDPARENT");if(!t.cid)throw h(new Error("No child cid passed to addLink"),"EINVALIDCHILDCID");if(!t.name)throw h(new Error("No child name passed to addLink"),"EINVALIDCHILDNAME");if(!t.size&&0!==t.size)throw h(new Error("No child size passed to addLink"),"EINVALIDCHILDSIZE");if(!r.Data)throw h(new Error("Parent node with no data passed to addLink"),"ERR_INVALID_PARENT");const s=k.unmarshal(r.Data);return"hamt-sharded-directory"===s.type?(Tg("Adding link to sharded directory"),Dg(e,{...t,parent:r})):r.Links.length>=t.shardSplitThreshold?(Tg("Converting directory to sharded directory"),Cg(e,{...t,parent:r,mtime:s.mtime,mode:s.mode})):(Tg(`Adding ${t.name} (${t.cid}) to regular directory`),Pg(e,{...t,parent:r}))}const Cg=async(e,t)=>{const r=await Rg(e,t.parent.Links.map((e=>({name:e.Name||"",size:e.Tsize||0,cid:e.Hash}))).concat({name:t.name,size:t.size,cid:t.cid}),t);return Tg(`Converted directory to sharded directory ${r.cid}`),r},Pg=async(e,t)=>{const r=t.parent.Links.filter((e=>e.Name!==t.name));if(r.push({Name:t.name,Tsize:t.size,Hash:t.cid}),!t.parent.Data)throw h(new Error("Parent node with no data passed to addToDirectory"),"ERR_INVALID_PARENT");const s=k.unmarshal(t.parent.Data);let n;if(s.mtime){const e=Date.now(),t=Math.floor(e/1e3);s.mtime={secs:t,nsecs:1e3*(e-1e3*t)},n=s.marshal()}else n=t.parent.Data;t.parent=R.prepare({Data:n,Links:r});const i=await e.hashers.getHasher(t.hashAlg),o=R.encode(t.parent),a=await i.digest(o),c=A.CID.create(t.cidVersion,R.code,a);return t.flush&&await e.repo.blocks.put(c,o),{node:t.parent,cid:c,size:o.length}},Dg=async(e,t)=>{const{shard:r,path:s}=await Ng(e,t),n=await Wt(r.flush(e.repo.blocks));if(!n)throw new Error("No result from flushing shard");const i=await e.repo.blocks.get(n.cid),o=R.decode(i),a=t.parent.Links.filter((e=>(e.Name||"").substring(0,2)!==s[0].prefix)),c=o.Links.find((e=>(e.Name||"").substring(0,2)===s[0].prefix));if(!c)throw new Error(`No link found with prefix ${s[0].prefix}`);return a.push(c),_g(e,a,s[0].bucket,t)},Ng=async(e,t)=>{const r={name:t.name,cid:t.cid,size:t.size};if(!t.parent.Data)throw h(new Error("Parent node with no data passed to addFileToShardedDirectory"),"ERR_INVALID_PARENT");const s=await vg(t.parent.Links),n=k.unmarshal(t.parent.Data),i=new mg({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mode:n.mode},t);i._bucket=s,n.mtime&&(i.mtime={secs:Math.round(Date.now()/1e3)});const o=await s._findNewBucketAndPos(r.name),a=Og(o);a[0].node=t.parent;let c=0;while(c<a.length){const t=a[c];c++;const n=t.node;if(!n)throw new Error("Segment had no node");const i=n.Links.find((e=>(e.Name||"").substring(0,2)===t.prefix));if(!i){Tg(`Link ${t.prefix}${r.name} will be added`),c=a.length;break}if(i.Name===`${t.prefix}${r.name}`){Tg(`Link ${t.prefix}${r.name} will be replaced`),c=a.length;break}if((i.Name||"").length>2){Tg(`Link ${i.Name} ${i.Hash} will be replaced with a subshard`),c=a.length;break}Tg(`Found subshard ${t.prefix}`);const o=await e.repo.blocks.get(i.Hash),l=R.decode(o);if(!a[c]){Tg(`Loaded new subshard ${t.prefix}`),await Eg(e,l.Links,s,t.bucket,parseInt(t.prefix,16));const n=await s._findNewBucketAndPos(r.name);a.push({bucket:n.bucket,prefix:Ig(n.pos),node:l});break}const u=a[c];await Sg(e,l.Links,u.bucket,s),u.node=l}return await i._bucket.put(r.name,{size:r.size,cid:r.cid}),{shard:i,path:a}},Og=e=>{const t=[{bucket:e.bucket,prefix:Ig(e.pos)}];let r=e.bucket._parent,s=e.bucket._posAtParent;while(r)t.push({bucket:r,prefix:Ig(s)}),s=r._posAtParent,r=r._parent;return t.reverse(),t},Lg=(0,u.kg)("ipfs:mfs:utils:update-tree"),xg={shardSplitThreshold:1e3};async function Mg(e,t,r){r=Object.assign({},xg,r),Lg("Trail",t),t=t.slice().reverse();let s,n=0;for await(const o of e.repo.blocks.getMany(t.map((e=>e.cid)))){const i=(0,R.decode)(o),a=t[n].cid,c=t[n].name;if(n++,!s){s={cid:a,name:c,size:o.length};continue}const l=await Ag(e,{parent:i,name:s.name,cid:s.cid,size:s.size,flush:r.flush,shardSplitThreshold:r.shardSplitThreshold,hashAlg:r.hashAlg,cidVersion:r.cidVersion});s={cid:l.cid,name:c,size:l.size}}const{cid:i}=s;return Lg(`Final CID ${i}`),i}const Bg=(0,u.kg)("ipfs:mfs:utils:update-mfs-root");async function Ug(e,t,r){if(r&&r.signal&&r.signal.aborted)throw h(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});return Bg(`New MFS root will be ${t}`),await e.repo.datastore.put(Et,t.bytes),t}async function jg(e,t,r){const s=new k({type:t,mode:r.mode,mtime:r.mtime}),n=await e.hashers.getHasher(r.hashAlg),i={Data:s.marshal(),Links:[]},o=R.encode(i),a=await n.digest(o),c=A.CID.create(r.cidVersion,R.code,a);return r.flush&&await e.repo.blocks.put(c,o),{cid:c,node:i}}const Vg=c.Z.bind({ignoreUndefined:!0}),zg=(0,u.kg)("ipfs:mfs:mkdir"),Fg={parents:!1,hashAlg:"sha2-256",cidVersion:0,shardSplitThreshold:1e3,flush:!0};function $g(e){async function t(t,r={}){const s=Vg(Fg,r);if(!t)throw new Error("no path given to Mkdir");if(t=t.trim(),"/"===t){if(s.parents)return;throw h(new Error("cannot create directory '/': Already exists"),"ERR_INVALID_PATH")}if("/"!==t.substring(0,1))throw h(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");zg(`Creating ${t}`);const n=rg(t);if("ipfs"===n[0])throw h(new Error("path cannot have the prefix 'ipfs'"),"ERR_INVALID_PATH");const i=await tg(e,s);let o;const a=[],c=await jg(e,"directory",s);for(let u=0;u<=n.length;u++){const r=n.slice(0,u),l=`/ipfs/${i}/${r.join("/")}`;try{if(o=await ga(l,e.repo.blocks),"file"!==o.type&&"directory"!==o.type)throw h(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");if(u===n.length){if(s.parents)return;throw h(new Error("file already exists"),"ERR_ALREADY_EXISTS")}a.push({name:o.name,cid:o.cid})}catch(mu){if("ERR_NOT_FOUND"!==mu.code)throw mu;if(u<n.length&&!s.parents)throw h(new Error(`Intermediate directory path ${l} does not exist, use the -p flag to create it`),"ERR_NOT_FOUND");await Kg(e,r[r.length-1],c,a[a.length-1],a,s)}}const l=await Mg(e,a,s);await Ug(e,l,s)}return gt(t)}const Kg=async(e,t,r,s,n,i)=>{zg(`Adding empty dir called ${t} to ${s.cid}`);const o=await Ag(e,{parent:s.node,parentCid:s.cid,size:0,cid:r.cid,name:t,hashAlg:i.hashAlg,cidVersion:i.cidVersion,flush:i.flush,shardSplitThreshold:i.shardSplitThreshold});n[n.length-1].cid=o.cid,n.push({name:t,cid:r.cid})},Hg=c.Z.bind({ignoreUndefined:!0}),qg=(0,u.kg)("ipfs:mfs:cp"),Gg={parents:!1,flush:!0,hashAlg:"sha2-256",cidVersion:0,shardSplitThreshold:1e3};function Wg(e){async function t(t,r,s={}){const n=Hg(Gg,s);Array.isArray(t)||(t=[t]);const i=await Promise.all(t.map((t=>ng(e,t,n))));let o=await ng(e,r,n);if(!i.length||!o)throw h(new Error("Please supply at least one source"),"ERR_INVALID_PARAMS");const a=i.find((e=>!e.exists));if(a)throw h(new Error(`${a.path} does not exist`),"ERR_INVALID_PARAMS");const c=Yg(o);if(o.exists){if(qg("Destination exists"),1===i.length&&!c)throw h(new Error("directory already has entry by that name"),"ERR_ALREADY_EXISTS")}else if(qg("Destination does not exist"),i.length>1){if(!n.parents)throw h(new Error("destination did not exist, pass -p to create intermediate directories"),"ERR_INVALID_PARAMS");await $g(e)(o.path,n),o=await ng(e,o.path,n)}else if(o.parts.length>1){const t=`/${o.parts.slice(0,-1).join("/")}`;try{await cg(e)(t,n)}catch(mu){if("ERR_NOT_FOUND"!==mu.code)throw mu;if(!n.parents)throw h(new Error("destination did not exist, pass -p to create intermediate directories"),"ERR_INVALID_PARAMS");await $g(e)(t,n),o=await ng(e,o.path,n)}}const l=Yg(o)?o.mfsPath:o.mfsDirectory,u=await hg(e,l);if(1===i.length){const t=i.pop();if(!t)throw h(new Error("could not find source"),"ERR_INVALID_PARAMS");const r=c?t.name:o.name;return qg(`Only one source, copying to destination ${c?"directory":"file"} ${r}`),Qg(e,t,r,u,n)}return qg("Multiple sources, wrapping in a directory"),Zg(e,i,o,u,n)}return gt(t)}const Yg=e=>e.unixfs&&e.unixfs.type&&e.unixfs.type.includes("directory"),Qg=async(e,t,r,s,n)=>{let i=s.pop();if(!i)throw h(new Error("destination had no parent"),"ERR_INVALID_PARAMS");i=await Xg(e,t,r,i,n),s.push(i);const o=await Mg(e,s,n);await Ug(e,o,n)},Zg=async(e,t,r,s,n)=>{for(let o=0;o<t.length;o++){const s=t[o];r=await Xg(e,s,s.name,r,n)}s[s.length-1]=r;const i=await Mg(e,s,n);await Ug(e,i,n)},Xg=async(e,t,r,s,n)=>{const i=await e.repo.blocks.get(t.cid),{node:o,cid:a,size:c}=await Ag(e,{parentCid:s.cid,size:i.length,cid:t.cid,name:r,hashAlg:n.hashAlg,cidVersion:n.cidVersion,flush:n.flush,shardSplitThreshold:n.shardSplitThreshold});return s.node=o,s.cid=a,s.size=c,s},Jg=(0,u.kg)("ipfs:mfs:core:utils:remove-link");async function em(e,t){let r=t.parent;if(t.parentCid){const s=A.CID.asCID(t.parentCid);if(null===s)throw h(new Error("Invalid CID passed to removeLink"),"EINVALIDPARENTCID");Jg(`Loading parent node ${s}`);const n=await e.repo.blocks.get(s);r=R.decode(n)}if(!r)throw h(new Error("No parent node or CID passed to removeLink"),"EINVALIDPARENT");if(!t.name)throw h(new Error("No child name passed to removeLink"),"EINVALIDCHILDNAME");if(!r.Data)throw h(new Error("Parent node had no data"),"ERR_INVALID_NODE");const s=k.unmarshal(r.Data);return"hamt-sharded-directory"===s.type?(Jg(`Removing ${t.name} from sharded directory`),rm(e,{...t,parent:r})):(Jg(`Removing link ${t.name} regular directory`),tm(e,{...t,parent:r}))}const tm=async(e,t)=>{t.parent.Links=t.parent.Links.filter((e=>e.Name!==t.name));const r=await R.encode(t.parent),s=await e.hashers.getHasher(t.hashAlg),n=await s.digest(r),i=A.CID.create(t.cidVersion,R.code,n);return await e.repo.blocks.put(i,r),Jg(`Updated regular directory ${i}`),{node:t.parent,cid:i}},rm=async(e,t)=>{const{rootBucket:r,path:s}=await kg(e,t.name,t.parent);await r.del(t.name);const{node:n}=await sm(e,s,t.name,t);return _g(e,n.Links,r,t)},sm=async(e,t,r,s)=>{const n=t.pop();if(!n)throw h(new Error("Could not find parent"),"EINVALIDPARENT");const{bucket:i,prefix:o,node:a}=n;if(!a)throw h(new Error("Could not find parent"),"EINVALIDPARENT");const c=a.Links.find((e=>(e.Name||"").substring(0,2)===o));if(!c)throw h(new Error(`No link found with prefix ${o} for file ${r}`),"ERR_NOT_FOUND");if(c.Name===`${o}${r}`){Jg(`Removing existing link ${c.Name}`);const t=a.Links.filter((e=>e.Name!==c.Name));return await i.del(r),_g(e,t,i,s)}Jg(`Descending into sub-shard ${c.Name} for ${o}${r}`);const l=await sm(e,t,r,s);let u=l.cid,d=l.size,p=o;if(1===l.node.Links.length){Jg(`Removing subshard for ${o}`);const e=l.node.Links[0];p=`${o}${(e.Name||"").substring(2)}`,u=e.Hash,d=e.Tsize||0}return Jg(`Updating shard ${o} with name ${p}`),nm(e,i,a,o,p,d,u,s)},nm=(e,t,r,s,n,i,o,a)=>{const c=r.Links.filter((e=>e.Name!==s));return c.push({Name:n,Tsize:i,Hash:o}),_g(e,c,t,a)},im=c.Z.bind({ignoreUndefined:!0}),om={recursive:!1,cidVersion:0,hashAlg:"sha2-256",flush:!0,shardSplitThreshold:1e3};function am(e){async function t(t,r={}){const s=im(om,r);Array.isArray(t)||(t=[t]);const n=await Promise.all(t.map((t=>ng(e,t,s))));if(!n.length)throw h(new Error("Please supply at least one path to remove"),"ERR_INVALID_PARAMS");n.forEach((e=>{if("/"===e.path)throw h(new Error("Cannot delete root"),"ERR_INVALID_PARAMS")}));for(const i of n)await cm(e,i.path,s)}return gt(t)}const cm=async(e,t,r)=>{const s=await ng(e,t,r),n=await hg(e,s.mfsPath),i=n[n.length-1];n.pop();const o=n[n.length-1];if(!o)throw h(new Error(`${t} does not exist`),"ERR_NOT_FOUND");if("directory"===i.type&&!r.recursive)throw h(new Error(`${t} is a directory, use -r to remove directories`),"ERR_WAS_DIR");const{cid:a}=await em(e,{parentCid:o.cid,name:i.name,hashAlg:r.hashAlg,cidVersion:r.cidVersion,flush:r.flush,shardSplitThreshold:r.shardSplitThreshold});o.cid=a;const c=await Mg(e,n,r);await Ug(e,c,r)},lm=c.Z.bind({ignoreUndefined:!0}),um=(0,u.kg)("ipfs:mfs:touch"),hm={flush:!0,shardSplitThreshold:1e3,hashAlg:"sha2-256",cidVersion:0,recursive:!1};function dm(e,t,r){let s=0;return(e.includes("x")||e.includes("X")&&(r||1&t||8&t||64&t))&&(s+=1),e.includes("w")&&(s+=2),e.includes("r")&&(s+=4),s}function pm(e,t){let r=0;return e.includes("u")&&(r+=t<<6),e.includes("g")&&(r+=t<<3),e.includes("o")&&(r+=t),r}function fm(e,t,r){return t.includes("t")&&(r+=parseInt("1000",8)),t.includes("s")&&(e.includes("u")&&(r+=parseInt("4000",8)),e.includes("g")&&(r+=parseInt("2000",8))),r}function ym(e,t,r){t||(t=0);const s=e.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);if(!s)throw new Error(`Invalid file mode: ${e}`);let[,n,i,o]=s;"a"!==n&&n||(n="ugo");let a=dm(o,t,r);return a=pm(n,a),a=fm(n,o,a),"="===i?(n.includes("u")&&(t&=parseInt("7077",8),t|=a),n.includes("g")&&(t&=parseInt("7707",8),t|=a),n.includes("o")&&(t&=parseInt("7770",8),t|=a),t):"+"===i?a|t:"-"===i?a^t:t}function gm(e,t){if(e instanceof String||"string"===typeof e){const r=`${e}`;e=r.match(/^\d+$/g)?parseInt(r,8):0+r.split(",").reduce(((e,r)=>ym(r,e,t.isDirectory())),t.mode||0)}return e}function mm(e){async function t(t,r,s={}){const n=lm(hm,s);um(`Fetching stats for ${t}`);const{cid:i,mfsDirectory:o,name:a}=await ng(e,t,n);if(i.code!==R.code)throw h(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");if(n.recursive){const s=await(0,Cs.zG)((async function*(){for await(const s of ma(i,e.repo.blocks)){if("file"!==s.type&&"directory"!==s.type)throw h(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");s.unixfs.mode=gm(r,s.unixfs);const e=R.prepare({Data:s.unixfs.marshal(),Links:s.node.Links});yield{path:s.path,content:e}}}),(t=>vo(t,e.repo.blocks,{...n,pin:!1,dagBuilder:async function*(e,t,r){for await(const s of e)yield async function(){const e=s.content,n=R.encode(e),i=await dg(n,t,r);if(!e.Data)throw h(new Error(`${i} had no data`),"ERR_INVALID_NODE");const o=k.unmarshal(e.Data);return{cid:i,size:n.length,path:s.path,unixfs:o}}}})),(e=>Wt(e)));if(!s)throw h(new Error(`Could not chmod ${t}`),"ERR_COULD_NOT_CHMOD");return await am(e)(t,n),void await Wg(e)(`/ipfs/${s.cid}`,t,n)}const c=await e.repo.blocks.get(i),l=R.decode(c);if(!l.Data)throw h(new Error(`${i} had no data`),"ERR_INVALID_NODE");const u=k.unmarshal(l.Data);u.mode=gm(r,u);const d=R.encode({Data:u.marshal(),Links:l.Links}),p=n.hashAlg||hm.hashAlg,f=await e.hashers.getHasher(p),y=await f.digest(d),g=A.CID.create(n.cidVersion,R.code,y);n.flush&&await e.repo.blocks.put(g,d);const m=await hg(e,o),w=m[m.length-1],b=A.CID.decode(w.cid.bytes),_=await e.repo.blocks.get(b),E=R.decode(_),v=await Ag(e,{parent:E,name:a,cid:g,size:d.length,flush:n.flush,hashAlg:p,cidVersion:i.version,shardSplitThreshold:1/0});w.cid=v.cid;const S=await Mg(e,m,n);await Ug(e,S,n)}return gt(t)}const wm=c.Z.bind({ignoreUndefined:!0}),bm={};function _m(e){async function t(t,r={}){r=wm(bm,r);const{cid:s}=await cg(e)(t,r);return s}return gt(t)}const Em=c.Z.bind({ignoreUndefined:!0}),vm={parents:!1,flush:!0,cidVersion:0,hashAlg:"sha2-256",shardSplitThreshold:1e3};function Sm(e){async function t(t,r,s={}){const n=Em(vm,s);await Wg(e)(t,r,n),await am(e)(t,{...n,recursive:!0})}return gt(t)}const Im=c.Z.bind({ignoreUndefined:!0}),km=(0,u.kg)("ipfs:mfs:touch"),Rm={flush:!0,shardSplitThreshold:1e3,cidVersion:0,hashAlg:"sha2-256"};function Tm(e){async function t(t,r={}){const s=Im(Rm,r);s.mtime=s.mtime||new Date,km(`Touching ${t} mtime: ${s.mtime}`);const{cid:n,mfsDirectory:i,name:o,exists:a}=await ng(e,t,s),c=r.hashAlg||Rm.hashAlg,l=await e.hashers.getHasher(c);let u,d,p=s.cidVersion;if(a){if(n.code!==R.code)throw h(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");p=n.version;const r=await e.repo.blocks.get(n),i=R.decode(r);if(!i.Data)throw h(new Error(`${t} had no data`),"ERR_INVALID_NODE");const o=k.unmarshal(i.Data);o.mtime=s.mtime,u=R.encode({Data:o.marshal(),Links:i.Links});const a=await l.digest(u);d=A.CID.create(s.cidVersion,R.code,a),s.flush&&await e.repo.blocks.put(d,u)}else{const t=new k({type:"file",mtime:s.mtime});u=R.encode({Data:t.marshal(),Links:[]});const r=await l.digest(u);d=A.CID.create(s.cidVersion,R.code,r),s.flush&&await e.repo.blocks.put(d,u)}const f=await hg(e,i),y=f[f.length-1],g=y.cid,m=await e.repo.blocks.get(g),w=R.decode(m),b=await Ag(e,{parent:w,name:o,cid:d,size:u.length,flush:s.flush,shardSplitThreshold:s.shardSplitThreshold,hashAlg:s.hashAlg,cidVersion:p});y.cid=b.cid;const _=await Mg(e,f,s);await Ug(e,_,s)}return gt(t)}const Am=c.Z.bind({ignoreUndefined:!0}),Cm={offset:0,length:1/0};function Pm(e){function t(t,r={}){return r=Am(Cm,r),{[Symbol.asyncIterator]:async function*(){const s=await ng(e,t,r),n=await ga(s.mfsPath,e.repo.blocks);if("file"!==n.type)throw h(new Error(`${t} was not a file`),"ERR_NOT_FILE");if(!n.content)throw h(new Error(`Could not load content stream from ${t}`),"ERR_NO_CONTENT");for await(const e of n.content({offset:r.offset,length:r.length}))yield e}}}return gt(t)}const Dm=(0,u.kg)("ipfs:mfs:utils:to-async-iterator");function Nm(e){if(!e)throw h(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");if(("string"===typeof e||e instanceof String)&&(Dm("Content was a string"),e=(0,ze.m)(e.toString())),e.length)return Dm("Content was array-like"),{[Symbol.asyncIterator]:function*(){yield e}};if(e[Symbol.asyncIterator])return Dm("Content was an async iterator"),e;if(e[Symbol.iterator])return Dm("Content was an iterator"),e;if(global.Blob&&e instanceof global.Blob){Dm("Content was an HTML5 Blob");let t=0;const r={next:()=>t>e.size?{done:!0}:new Promise(((r,s)=>{const n=e.slice(t,vt);t+=vt;const i=new global.FileReader,o=e=>{if(i.removeEventListener("loadend",o,!1),e.error)return s(e.error);r({done:!1,value:new Uint8Array(i.result)})};i.addEventListener("loadend",o),i.readAsArrayBuffer(n)}))};return{[Symbol.asyncIterator]:()=>r}}throw h(new Error(`Don't know how to convert ${e} into an async iterator`),"ERR_INVALID_PARAMS")}const Om=c.Z.bind({ignoreUndefined:!0}),Lm=(0,u.kg)("ipfs:mfs:write"),xm={offset:0,length:1/0,create:!1,truncate:!1,rawLeaves:!1,reduceSingleLeafToSelf:!1,cidVersion:0,hashAlg:"sha2-256",parents:!1,progress:(e,t)=>{},strategy:"trickle",flush:!0,leafType:"raw",shardSplitThreshold:1e3};function Mm(e){async function t(t,r,s={}){const n=Om(xm,s);let i,o,a;if(Lm("Reading source, destination and parent"),await Jy().readLock((async()=>{i=await Nm(r),o=await ng(e,t,n),a=await ng(e,o.mfsDirectory,n)}))(),Lm("Read source, destination and parent"),!n.parents&&!a.exists)throw h(new Error("directory does not exist"),"ERR_NO_EXIST");if(null==i)throw h(new Error("could not create source"),"ERR_NO_SOURCE");if(null==o)throw h(new Error("could not create destination"),"ERR_NO_DESTINATION");if(!n.create&&!o.exists)throw h(new Error("file does not exist"),"ERR_NO_EXIST");if("file"!==o.entryType)throw h(new Error("not a file"),"ERR_NOT_A_FILE");return Bm(e,t,i,o,n)}return gt(t)}const Bm=async(e,t,r,s,n)=>{const i=await Um(e,r,s,n);await Jy().writeLock((async()=>{const r=rg(t),s=r.pop();if(null==s)throw h(new Error("source does not exist"),"ERR_NO_EXIST");let o=!1;try{await cg(e)(`/${r.join("/")}`,n),o=!0}catch(mu){if("ERR_NOT_FOUND"!==mu.code)throw mu}o||await $g(e)(`/${r.join("/")}`,n);const a=await ng(e,t,n),c=await hg(e,a.mfsDirectory),l=c[c.length-1];if(!l)throw h(new Error("directory does not exist"),"ERR_NO_EXIST");if(!l.type||!l.type.includes("directory"))throw h(new Error(`cannot write to ${l.name}: Not a directory`),"ERR_NOT_A_DIRECTORY");const u=await e.repo.blocks.get(l.cid),d=(0,R.decode)(u),p=await Ag(e,{parent:d,name:s,cid:i.cid,size:i.size,flush:n.flush,shardSplitThreshold:n.shardSplitThreshold,hashAlg:n.hashAlg,cidVersion:n.cidVersion});l.cid=p.cid;const f=await Mg(e,c,n);await Ug(e,f,n)}))()},Um=async(e,t,r,s)=>{r.exists?Lm(`Overwriting file ${r.cid} offset ${s.offset} length ${s.length}`):Lm(`Writing file offset ${s.offset} length ${s.length}`);const n=[];if(s.offset>0)if(r.unixfs){if(Lm(`Writing first ${s.offset} bytes of original file`),n.push((()=>r.content({offset:0,length:s.offset}))),r.unixfs.fileSize()<s.offset){const e=s.offset-r.unixfs.fileSize();Lm(`Writing zeros for extra ${e} bytes`),n.push(Vm(e))}}else Lm(`Writing zeros for first ${s.offset} bytes`),n.push(Vm(s.offset));n.push(jm(t,s.length));const i=Fm(zm(n),(e=>{if(r.unixfs&&!s.truncate){const t=r.unixfs.fileSize();if(t>e)return Lm(`Writing last ${t-e} of ${t} bytes from original file starting at offset ${e}`),r.content({offset:e});Lm("Not writing last bytes from original file")}return{[Symbol.asyncIterator]:async function*(){}}}));let o,a;void 0!==s.mode&&null!==s.mode?o=S(s.mode):r&&r.unixfs&&(o=r.unixfs.mode),null!=s.mtime?a=I(s.mtime):r&&r.unixfs&&(a=r.unixfs.mtime);const c=await e.hashers.getHasher(s.hashAlg),l=await Wt(vo([{content:i,mode:o,mtime:a}],e.repo.blocks,{progress:s.progress,hasher:c,cidVersion:s.cidVersion,strategy:s.strategy,rawLeaves:s.rawLeaves,reduceSingleLeafToSelf:s.reduceSingleLeafToSelf,leafType:s.leafType}));if(!l)throw h(new Error(`cannot write to ${parent.name}`),"ERR_COULD_NOT_WRITE");return Lm(`Wrote ${l.cid}`),{cid:l.cid,size:l.size}},jm=(e,t)=>async function*(){let r=0;for await(const s of e){if(r+=s.length,r>t)return void(yield s.slice(0,t-r));yield s}},Vm=(e,t=vt)=>{const r=new Uint8Array(t);async function*s(){while(1)yield r.slice()}return jm(s(),e)},zm=async function*(e){for(let t=0;t<e.length;t++)yield*e[t]()},Fm=async function*(e,t){let r=0;for await(const s of e)r+=s.length,yield s;for await(const s of t(r))r+=s.length,yield s},$m=e=>{const t={cid:e.cid,name:e.name,type:"directory"===e.type?"directory":"file",size:e.size};return"file"!==e.type&&"directory"!==e.type||(t.mode=e.unixfs.mode,t.mtime=e.unixfs.mtime),t};function Km(e){async function*t(t,r={}){const s=await ng(e,t,r),n=await ga(s.mfsPath,e.repo.blocks);"directory"!==n.type?yield $m(n):yield*As(n.content(r),$m)}return gt(t)}const Hm={stat:cg},qm={chmod:mm,cp:Wg,flush:_m,mkdir:$g,mv:Sm,rm:am,touch:Tm},Gm={write:Mm,read:Pm,ls:Km},Wm=({options:e,mfs:t,operations:r,lock:s})=>{Object.keys(r).forEach((n=>{t[n]=s(r[n](e))}))},Ym={repoOwner:!0,repo:null};function Qm(e){const{repoOwner:t}=Object.assign({},Ym||{},e),r=Jy(t),s=e=>r.readLock(e),n=e=>r.writeLock(e),i={};return Wm({options:e,mfs:i,operations:Hm,lock:s}),Wm({options:e,mfs:i,operations:qm,lock:n}),Object.keys(Gm).forEach((t=>{i[t]=Gm[t](e)})),i}function Zm({repo:e,preload:t,hashers:r,options:s}){const n=Qm({repo:e,repoOwner:!1!==s.repoOwner,hashers:r}),i=e=>{const r=(...r)=>{const s=r.filter((e=>at(e)||tt(e)));if(s.length){const e=r[r.length-1];e&&!1!==e.preload&&s.forEach((e=>t(e)))}return e(...r)};return r};return{...n,chmod:n.chmod,cp:i(n.cp),mkdir:n.mkdir,stat:i(n.stat),rm:n.rm,read:i(n.read),touch:n.touch,write:n.write,mv:i(n.mv),flush:n.flush,ls:i((async function*(...e){for await(const t of n.ls(...e))yield{...t,size:t.size||0}}))}}function Xm({keychain:e}){const t=(t,r)=>e.exportKey(t,r);return gt(t)}const Jm="Ed25519",ew=2048;function tw({keychain:e}){const t=(t,r={type:Jm,size:ew})=>e.createKey(t,r.type||Jm,r.size||ew);return gt(t)}function rw({keychain:e}){const t=(t,r,s)=>e.importKey(t,r,s);return gt(t)}function sw({keychain:e}){const t=t=>e.findKeyByName(t);return gt(t)}function nw({keychain:e}){const t=()=>e.listKeys();return gt(t)}function iw({keychain:e}){const t=async(t,r)=>{const s=await e.renameKey(t,r);return{was:t,now:s.name,id:s.id,overwrite:!1}};return gt(t)}function ow({keychain:e}){const t=t=>e.removeKey(t);return gt(t)}class aw{constructor({keychain:e}){this.gen=tw({keychain:e}),this.list=nw({keychain:e}),this.rm=ow({keychain:e}),this.rename=iw({keychain:e}),this.export=Xm({keychain:e}),this.import=rw({keychain:e}),this.info=sw({keychain:e})}}function cw({repo:e,preload:t}){async function r(r,s={}){!1!==s.preload&&t(r);const n=await e.blocks.get(r,s);return R.decode(n)}return gt(r)}function lw({repo:e,preload:t}){const r=cw({repo:e,preload:t});async function s(e,t={}){const s=await r(e,t);return s.Data||new Uint8Array(0)}return gt(s)}function uw(e,t=[]){for(const s in e){const n=e[s];if("/"===s&&1===Object.keys(e).length)try{t.push({Name:"",Tsize:0,Hash:A.CID.parse(n)});continue}catch(r){}const i=A.CID.asCID(n);i?t.push({Name:"",Tsize:0,Hash:i}):(Array.isArray(n)&&uw(n,t),n&&"object"===typeof n&&uw(n,t))}return t}function hw({repo:e,codecs:t}){async function r(r,s={}){const n=await t.getCodec(r.code),i=await e.blocks.get(r,s),o=n.decode(i);switch(r.code){case pi.code:return[];case R.code:return o.Links;case B:case ae:return uw(o);default:throw new Error(`Cannot resolve links from codec ${r.code}`)}}return gt(r)}function dw({repo:e,preload:t}){async function r(r={}){let s;if(r.template){if("unixfs-dir"!==r.template)throw new Error("unknown template");s=new k({type:"directory"}).marshal()}const n=R.encode({Data:s,Links:[]}),i=await ti.sha256.digest(n),o=A.CID.createV0(i);return await e.blocks.put(o,n,{signal:r.signal}),!1!==r.preload&&t(o),o}return gt(r)}function pw({repo:e,preload:t}){async function r(r,s={}){const n=await e.gcLock.readLock();try{const i=R.encode(r),o=await ti.sha256.digest(i),a=A.CID.createV1(R.code,o);return await e.blocks.put(a,i,{signal:s.signal}),!1!==s.preload&&t(a),s.pin&&await e.pins.pinRecursively(a,{signal:s.signal}),a}finally{n()}}return gt(r)}function fw({repo:e,preload:t}){const r=cw({repo:e,preload:t});async function s(e,t={}){const s=await r(e,t),n=R.encode(s),i=n.length,o=s.Links.reduce(((e,t)=>e+(t.Tsize||0)),0);return{Hash:e,NumLinks:s.Links.length,BlockSize:i,LinksSize:i-(s.Data||[]).length,DataSize:(s.Data||[]).length,CumulativeSize:i+o}}return gt(s)}function yw({repo:e,preload:t}){const r=cw({repo:e,preload:t}),s=pw({repo:e,preload:t});async function n(e,t,n={}){const i=await r(e,n);return s({...i,Links:i.Links.concat([t])},n)}return gt(n)}function gw({repo:e,preload:t}){const r=cw({repo:e,preload:t}),s=pw({repo:e,preload:t});async function n(e,t,n={}){const i=await r(e,n),o=(0,Ir.concat)([i.Data||[],t]);return s({...i,Data:o},n)}return gt(n)}function mw({repo:e,preload:t}){const r=cw({repo:e,preload:t}),s=pw({repo:e,preload:t});async function n(e,t,n={}){const i=await r(e,n),o=("string"===typeof t?t:t.Name)||"";return i.Links=i.Links.filter((e=>e.Name!==o)),s(i,n)}return gt(n)}function ww({repo:e,preload:t}){const r=cw({repo:e,preload:t}),s=pw({repo:e,preload:t});async function n(e,t,n={}){const i=await r(e,n);return s({...i,Data:t},n)}return gt(n)}class bw{constructor({repo:e,preload:t}){this.addLink=yw({repo:e,preload:t}),this.appendData=gw({repo:e,preload:t}),this.rmLink=mw({repo:e,preload:t}),this.setData=ww({repo:e,preload:t})}}class _w{constructor({repo:e,codecs:t,preload:r}){this.data=lw({repo:e,preload:r}),this.get=cw({repo:e,preload:r}),this.links=hw({repo:e,codecs:t}),this.new=dw({repo:e,preload:r}),this.put=pw({repo:e,preload:r}),this.stat=fw({repo:e,preload:r}),this.patch=new bw({repo:e,preload:r})}}const Ew=(0,u.kg)("ipfs:repo:gc");function vw({repo:e,hashers:t}){async function*r(r={}){const s=Date.now();let n;try{n=await tg({repo:e,hashers:t},r),await e.pins.pinRecursively(n),yield*e.gc()}finally{n&&await e.pins.unpin(n)}Ew(`Complete (${Date.now()-s}ms)`)}return gt(r)}function Sw({repo:e}){async function t(t={}){const r=await e.stat();return{numObjects:BigInt(r.numObjects.toString()),repoSize:BigInt(r.repoSize.toString()),repoPath:r.repoPath,version:`${r.version}`,storageMax:BigInt(r.storageMax.toString())}}return gt(t)}const Iw=12;function kw({repo:e}){async function t(t={}){try{await e._checkInitialized(t)}catch(mu){const t=[/Key not found in database \[\/version\]/,/ENOENT/,/repo is not initialized yet/].some((t=>t.test(mu.message)));if(t)return Iw;throw mu}return e.version.get()}return gt(t)}class Rw{constructor({repo:e,hashers:t}){this.gc=vw({repo:e,hashers:t}),this.stat=Sw({repo:e}),this.version=kw({repo:e}),this.setApiAddr=t=>e.apiAddr.set(t)}}function Tw(e,t){let r;if(r=e.metrics?t.peer?e.metrics.forPeer(t.peer):t.proto?e.metrics.forProtocol(t.proto):e.metrics.getGlobal():void 0,!r)return{totalIn:BigInt(0),totalOut:BigInt(0),rateIn:0,rateOut:0};const s=r.getMovingAverages(),n=r.getSnapshot();return{totalIn:n.dataReceived,totalOut:n.dataSent,rateIn:s.dataReceived[6e4].movingAverage/60,rateOut:s.dataSent[6e4].movingAverage/60}}function Aw({network:e}){const t=async function*(t={}){const{libp2p:r}=await e.use(t);if(!t.poll)return void(yield Tw(r,t));const s=t.interval||1e3;let n,i=-1;try{if(i="string"===typeof s?ft(s)||-1:s,!i||i<0)throw new Error("invalid duration")}catch(mu){throw h(mu,"ERR_INVALID_POLL_INTERVAL")}try{while(1)yield Tw(r,t),await new Promise((e=>{n=setTimeout(e,i)}))}finally{clearTimeout(n)}};return gt(t)}class Cw{constructor({repo:e,network:t}){this.repo=Sw({repo:e}),this.bw=Aw({network:t}),this.bitswap=vn({network:t})}}var Pw=Dw;function Dw(e,t,r){if(!e)return r;var s,n;if(Array.isArray(t)&&(s=t.slice(0)),"string"==typeof t&&(s=t.split(".")),"symbol"==typeof t&&(s=[t]),!Array.isArray(s))throw new Error("props arg must be an array, a string or a symbol");while(s.length){if(n=s.shift(),!e)return r;if(e=e[n],void 0===e)return r}return e}var Nw=r(11227),Ow=r(93975);const Lw=Nw("ipfs:repo:migrator:migration-8");function xw(e){return e.child?xw(e.child):e}function Mw(e){try{const t=Ke.base32.decode(`b${e.toString().toLowerCase().slice(1)}`),r=A.CID.decode(t).multihash.bytes,s=Ke.base32.encode(r).slice(1).toUpperCase();return new lt.s(`/${s}`,!1)}catch(mu){return e}}function Bw(e){try{const t=Ke.base32.decode(`b${e.toString().toLowerCase().slice(1)}`),r=He.Jx(t),s=Ke.base32.encode(A.CID.createV1(pi.code,r).bytes).slice(1);return new lt.s(`/${s.toUpperCase()}`,!1)}catch{return e}}async function Uw(e,t,r){const s=e.blocks;await s.open();const n=xw(s),i=await Ow(n.queryKeys({filters:[e=>{const t=r(e);return t.toString()!==e.toString()}]}));try{let e=0;for await(const s of n.query({})){const o=r(s.key);o.toString()!==s.key.toString()&&(e+=1,Lw(`Migrating Block from ${s.key} to ${o}`,await n.has(s.key)),await n.delete(s.key),await n.put(o,s.value),t(e/i*100,`Migrated Block from ${s.key} to ${o}`))}}finally{await s.close()}}const jw={version:8,description:"Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",migrate:(e,t=(()=>{}))=>Uw(e,t,Mw),revert:(e,t=(()=>{}))=>Uw(e,t,Bw)},Vw=d.Reader,zw=d.Writer,Fw=(d.util,d.roots["default"]||(d.roots["default"]={})),$w=Fw.ipfs=(()=>{const e={};return e.pin=function(){const e={};return e.Set=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.version=0,e.prototype.fanout=0,e.prototype.seed=0,e.encode=function(e,t){return t||(t=zw.create()),null!=e.version&&Object.hasOwnProperty.call(e,"version")&&t.uint32(8).uint32(e.version),null!=e.fanout&&Object.hasOwnProperty.call(e,"fanout")&&t.uint32(16).uint32(e.fanout),null!=e.seed&&Object.hasOwnProperty.call(e,"seed")&&t.uint32(29).fixed32(e.seed),t},e.decode=function(e,t){e instanceof Vw||(e=Vw.create(e));var r=void 0===t?e.len:e.pos+t,s=new Fw.ipfs.pin.Set;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.version=e.uint32();break;case 2:s.fanout=e.uint32();break;case 3:s.seed=e.fixed32();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof Fw.ipfs.pin.Set)return e;var t=new Fw.ipfs.pin.Set;return null!=e.version&&(t.version=e.version>>>0),null!=e.fanout&&(t.fanout=e.fanout>>>0),null!=e.seed&&(t.seed=e.seed>>>0),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.version=0,r.fanout=0,r.seed=0),null!=e.version&&e.hasOwnProperty("version")&&(r.version=e.version),null!=e.fanout&&e.hasOwnProperty("fanout")&&(r.fanout=e.fanout),null!=e.seed&&e.hasOwnProperty("seed")&&(r.seed=e.seed),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e}(),e}(),e})();var Kw=r(96132);const Hw=new lt.s("/local/pins"),qw=256,Gw=8192,Ww=A.CID.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"),Yw={direct:"direct",recursive:"recursive"};function Qw(e){return new lt.s(`/${Ke.base32.encode(e.multihash.bytes).toUpperCase().substring(1)}`)}var Zw=r(18764);const Xw=$w.pin.Set;function Jw(e){const t=e.Data;if(!t)throw new Error("No data present");const r=If.decode(t),s=If.decode.bytes;if(s<=0)throw new Error("Invalid Set header length");if(s+r>t.length)throw new Error("Impossibly large set header length");const n=t.slice(s,r+s),i=Xw.toObject(Xw.decode(n),{defaults:!1,arrays:!0,longs:Number,objects:!1});if(1!==i.version)throw new Error(`Unsupported Set version: ${i.version}`);if(i.fanout>e.Links.length)throw new Error("Impossibly large fanout");return{header:i,data:t.slice(r+s)}}function eb(e,t){const r=new Uint8Array(4),s=new DataView(r.buffer);s.setUint32(0,e,!0);const n=(0,ze.m)(t.toString()),i=(0,Ir.concat)([r,n],r.byteLength+n.byteLength);return Kw((0,Ye.B)(i))}async function*tb(e,t){const r=Jw(t);let s=0;for(const n of t.Links){if(s<r.header.fanout){const t=n.Hash;if(!Ww.equals(t)){const r=await e.get(t),s=R.decode(r);yield*tb(e,s)}}else yield n.Hash;s++}}async function*rb(e,t,r){const s=t.Links.find((e=>e.Name===r));if(!s)throw new Error("No link found with name "+r);const n=await e.get(s.Hash),i=R.decode(n);yield*tb(e,i)}function sb(e,t){return r(t,0);async function r(t,s){const n=Xw.encode({version:1,fanout:qw,seed:s}).finish(),i=If.encode(n.length),o=(0,Ir.concat)([i,n]),a=[];for(let e=0;e<qw;e++)a.push({Name:"",Tsize:1,Hash:Ww});if(t.length<=Gw){const e=t.map((e=>({link:{Name:"",Tsize:1,Hash:e.key},data:e.data||new Uint8Array}))).sort(((e,t)=>(0,Zw.q)(e.link.Hash.bytes,t.link.Hash.bytes))),r=a.concat(e.map((e=>e.link))),s=(0,Ir.concat)([o,...e.map((e=>e.data))]);return{Data:s,Links:r}}{const e=t.reduce(((e,t)=>{const r=eb(s,t.key)%qw;return e[r]=r in e?e[r].concat([t]):[t],e}),[]);let n=0;for(const t of e){const e=await r(t,s+1);await c(e,n),n++}return{Data:o,Links:a}}async function c(t,r){const s=R.encode(t),n=await ti.sha256.digest(s),i=A.CID.createV0(n);await e.put(i,s);const o=t.Links.reduce(((e,t)=>e+(t.Tsize||0)),0)+s.length;a[r]={Name:"",Tsize:o,Hash:i}}}}async function nb(e,t,r){const s=await sb(e,r.map((e=>({key:e})))),n=R.encode(s),i=await ti.sha256.digest(n),o=A.CID.createV0(i);await e.put(o,n);const a=s.Links.reduce(((e,t)=>e+t.Tsize),0)+n.length;return{Name:t,Tsize:a,Hash:o}}async function ib(e,t,r,s){if(!await t.has(Hw))return;const n=await t.get(Hw),i=A.CID.decode(n),o=await e.get(i),a=R.decode(o);let c=0;const l=await Ow(rb(e,a,Yw.recursive))+await Ow(rb(e,a,Yw.direct));for await(const u of rb(e,a,Yw.recursive)){c++;const e={depth:1/0};0!==u.version&&(e.version=u.version),u.code!==R.code&&(e.codec=u.code),await r.put(Qw(u),T.cv(e)),s(c/l*100,`Migrated recursive pin ${u}`)}for await(const u of rb(e,a,Yw.direct)){c++;const e={depth:0};0!==u.version&&(e.version=u.version),u.code!==R.code&&(e.codec=u.code),await r.put(Qw(u),T.cv(e)),s(c/l*100,`Migrated direct pin ${u}`)}await e.delete(i),await t.delete(Hw)}async function ob(e,t,r,s){const n=[],i=[];let o=0;const a=await Ow(r.queryKeys({}));for await(const{key:d,value:p}of r.query({})){o++;const e=T.Jx(p),t=A.CID.create(e.version||0,e.codec||R.code,He.Jx(Ke.base32.decode("b"+d.toString().toLowerCase().split("/").pop())));0===e.depth?(s(o/a*100,`Reverted direct pin ${t}`),i.push(t)):(s(o/a*100,`Reverted recursive pin ${t}`),n.push(t))}s(100,"Updating pin root");const c={Links:[await nb(e,Yw.direct,i),await nb(e,Yw.recursive,n)]},l=R.encode(c),u=await ti.sha256.digest(l),h=A.CID.createV0(u);await e.put(h,l),await t.put(Hw,h.bytes)}async function ab(e,t,r){const s=e.blocks,n=e.datastore,i=e.pins;await s.open(),await n.open(),await i.open();try{await r(s,n,i,t)}finally{await i.close(),await n.close(),await s.close()}}const cb={version:9,description:"Migrates pins to datastore",migrate:(e,t=(()=>{}))=>ab(e,t,ib),revert:(e,t=(()=>{}))=>ab(e,t,ob)},lb=new lt.s("/config"),ub=new lt.s("/version");function hb(e){let t=e;while(t.db||t.child)if(t=t.db||t.child,"level-js"===t.type||"Level"===t.constructor.name)return t}async function db(e,t,r){const s=await t(e);if(s)return s;const n=hb(r);return!!n&&new Promise(((t,r)=>{const s=n.store("readonly").get(e.toString());s.transaction.onabort=()=>{r(s.transaction.error)},s.transaction.oncomplete=()=>{t(Boolean(s.result))}}))}async function pb(e,t,r,s){if(await r(e))return t(e);const n=hb(s);if(!n)throw lr();return new Promise(((t,r)=>{const s=n.store("readonly").get(e.toString());s.transaction.onabort=()=>{r(s.transaction.error)},s.transaction.oncomplete=()=>{if(s.result)return t(s.result);r(lr())}}))}function fb(e){const t=e.get.bind(e),r=e.has.bind(e);return e.get=s=>pb(s,t,r,e),e.has=t=>db(t,r,e),e}function yb(e){return{...e,root:fb(e.root),datastore:fb(e.datastore),pins:fb(e.pins),keys:fb(e.keys)}}async function gb(e,t,r=(()=>{})){const s=hb(t);if(!s)return void r(`${e} did not need an upgrade`);r(`Upgrading ${e}`);const n=(e,t)=>[{type:"del",key:e},{type:"put",key:(0,ze.m)(e),value:t}];await Eb(s,n)}async function mb(e,t,r=(()=>{})){const s=hb(t);if(!s)return void r(`${e} did not need a downgrade`);r(`Downgrading ${e}`);const n=(e,t)=>[{type:"del",key:e},{type:"put",key:(0,Ye.B)(e),value:t}];await Eb(s,n)}function wb(e){return e.child?wb(e.child):e}async function bb(e,t,r){const s=Object.entries(e).map((([e,t])=>({key:e,backend:wb(t)}))).filter((({key:e,backend:t})=>"LevelDatastore"===t.constructor.name)).map((({key:e,backend:t})=>({name:e,store:t})));t(0,`Migrating ${s.length} dbs`);let n=0;const i=e=>{t(Math.round(n/s.length*100),e)};for(const{name:o,store:a}of s){await a.open();try{await r(o,a,i)}finally{n++,await a.close()}}t(100,`Migrated ${s.length} dbs`)}const _b={version:10,description:"Migrates datastore-level keys to binary",migrate:(e,t=(()=>{}))=>bb(e,t,gb),revert:(e,t=(()=>{}))=>bb(e,t,mb)};function Eb(e,t){function r(t,r){const s=e.store("readwrite"),n=s.transaction;let i,o=0;function a(){const e=t[o++],r=e.key;let c;try{c="del"===e.type?s.delete(r):s.put(e.value,r)}catch(mu){return i=mu,void n.abort()}o<t.length&&(c.onsuccess=a)}n.onabort=()=>r(i||n.error||new Error("aborted by user")),n.oncomplete=()=>r(),a()}return new Promise(((s,n)=>{const i=e.iterator(),o=e=>e;function a(){const e=(e,o,c)=>{if(e||void 0===o){const e=e=>{e?n(e):s()};i.end(e)}else r(t(o,c),a)};i.next(e)}i._deserializeKey=i._deserializeValue=o,a()}))}const vb=new lt.s("/local/filesroot");async function Sb(e,t=(()=>{})){if(t(100,"Migrating MFS root to repo datastore"),await e.root.open(),await e.datastore.open(),await e.root.has(vb)){const t=await e.root.get(vb);await e.datastore.put(vb,t),await e.root.delete(vb)}await e.datastore.close(),await e.root.close(),t(100,"Stored MFS root in repo datastore")}async function Ib(e,t=(()=>{})){if(t(100,"Migrating MFS root to repo root datastore"),await e.root.open(),await e.datastore.open(),await e.datastore.has(vb)){const t=await e.datastore.get(vb);await e.root.put(vb,t),await e.datastore.delete(vb)}await e.datastore.close(),await e.root.close(),t(100,"Stored MFS root in repo root datastore")}const kb={version:11,description:"Store mfs root in the datastore",migrate:Sb,revert:Ib},Rb=d.Reader,Tb=d.Writer,Ab=d.util,Cb=d.roots["default"]||(d.roots["default"]={}),Pb=Cb.Protocols=(()=>{function e(e){if(this.protocols=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.protocols=Ab.emptyArray,e.encode=function(e,t){if(t||(t=Tb.create()),null!=e.protocols&&e.protocols.length)for(var r=0;r<e.protocols.length;++r)t.uint32(10).string(e.protocols[r]);return t},e.decode=function(e,t){e instanceof Rb||(e=Rb.create(e));var r=void 0===t?e.len:e.pos+t,s=new Cb.Protocols;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.protocols&&s.protocols.length||(s.protocols=[]),s.protocols.push(e.string());break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof Cb.Protocols)return e;var t=new Cb.Protocols;if(e.protocols){if(!Array.isArray(e.protocols))throw TypeError(".Protocols.protocols: array expected");t.protocols=[];for(var r=0;r<e.protocols.length;++r)t.protocols[r]=String(e.protocols[r])}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.protocols=[]),e.protocols&&e.protocols.length){r.protocols=[];for(var s=0;s<e.protocols.length;++s)r.protocols[s]=e.protocols[s]}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e})(),Db=d.Reader,Nb=d.Writer,Ob=d.util,Lb=d.roots["default"]||(d.roots["default"]={}),xb=Lb.Addresses=(()=>{function e(e){if(this.addrs=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.addrs=Ob.emptyArray,e.prototype.certifiedRecord=null,e.encode=function(e,t){if(t||(t=Nb.create()),null!=e.addrs&&e.addrs.length)for(var r=0;r<e.addrs.length;++r)Lb.Addresses.Address.encode(e.addrs[r],t.uint32(10).fork()).ldelim();return null!=e.certifiedRecord&&Object.hasOwnProperty.call(e,"certifiedRecord")&&Lb.Addresses.CertifiedRecord.encode(e.certifiedRecord,t.uint32(18).fork()).ldelim(),t},e.decode=function(e,t){e instanceof Db||(e=Db.create(e));var r=void 0===t?e.len:e.pos+t,s=new Lb.Addresses;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.addrs&&s.addrs.length||(s.addrs=[]),s.addrs.push(Lb.Addresses.Address.decode(e,e.uint32()));break;case 2:s.certifiedRecord=Lb.Addresses.CertifiedRecord.decode(e,e.uint32());break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof Lb.Addresses)return e;var t=new Lb.Addresses;if(e.addrs){if(!Array.isArray(e.addrs))throw TypeError(".Addresses.addrs: array expected");t.addrs=[];for(var r=0;r<e.addrs.length;++r){if("object"!==typeof e.addrs[r])throw TypeError(".Addresses.addrs: object expected");t.addrs[r]=Lb.Addresses.Address.fromObject(e.addrs[r])}}if(null!=e.certifiedRecord){if("object"!==typeof e.certifiedRecord)throw TypeError(".Addresses.certifiedRecord: object expected");t.certifiedRecord=Lb.Addresses.CertifiedRecord.fromObject(e.certifiedRecord)}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.addrs=[]),t.defaults&&(r.certifiedRecord=null),e.addrs&&e.addrs.length){r.addrs=[];for(var s=0;s<e.addrs.length;++s)r.addrs[s]=Lb.Addresses.Address.toObject(e.addrs[s],t)}return null!=e.certifiedRecord&&e.hasOwnProperty("certifiedRecord")&&(r.certifiedRecord=Lb.Addresses.CertifiedRecord.toObject(e.certifiedRecord,t)),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.Address=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}let t;return e.prototype.multiaddr=Ob.newBuffer([]),e.prototype.isCertified=null,Object.defineProperty(e.prototype,"_isCertified",{get:Ob.oneOfGetter(t=["isCertified"]),set:Ob.oneOfSetter(t)}),e.encode=function(e,t){return t||(t=Nb.create()),null!=e.multiaddr&&Object.hasOwnProperty.call(e,"multiaddr")&&t.uint32(10).bytes(e.multiaddr),null!=e.isCertified&&Object.hasOwnProperty.call(e,"isCertified")&&t.uint32(16).bool(e.isCertified),t},e.decode=function(e,t){e instanceof Db||(e=Db.create(e));var r=void 0===t?e.len:e.pos+t,s=new Lb.Addresses.Address;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.multiaddr=e.bytes();break;case 2:s.isCertified=e.bool();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof Lb.Addresses.Address)return e;var t=new Lb.Addresses.Address;return null!=e.multiaddr&&("string"===typeof e.multiaddr?Ob.base64.decode(e.multiaddr,t.multiaddr=Ob.newBuffer(Ob.base64.length(e.multiaddr)),0):e.multiaddr.length&&(t.multiaddr=e.multiaddr)),null!=e.isCertified&&(t.isCertified=Boolean(e.isCertified)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(t.bytes===String?r.multiaddr="":(r.multiaddr=[],t.bytes!==Array&&(r.multiaddr=Ob.newBuffer(r.multiaddr)))),null!=e.multiaddr&&e.hasOwnProperty("multiaddr")&&(r.multiaddr=t.bytes===String?Ob.base64.encode(e.multiaddr,0,e.multiaddr.length):t.bytes===Array?Array.prototype.slice.call(e.multiaddr):e.multiaddr),null!=e.isCertified&&e.hasOwnProperty("isCertified")&&(r.isCertified=e.isCertified,t.oneofs&&(r._isCertified="isCertified")),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e}(),e.CertifiedRecord=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.seq=Ob.Long?Ob.Long.fromBits(0,0,!0):0,e.prototype.raw=Ob.newBuffer([]),e.encode=function(e,t){return t||(t=Nb.create()),null!=e.seq&&Object.hasOwnProperty.call(e,"seq")&&t.uint32(8).uint64(e.seq),null!=e.raw&&Object.hasOwnProperty.call(e,"raw")&&t.uint32(18).bytes(e.raw),t},e.decode=function(e,t){e instanceof Db||(e=Db.create(e));var r=void 0===t?e.len:e.pos+t,s=new Lb.Addresses.CertifiedRecord;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.seq=e.uint64();break;case 2:s.raw=e.bytes();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof Lb.Addresses.CertifiedRecord)return e;var t=new Lb.Addresses.CertifiedRecord;return null!=e.seq&&(Ob.Long?(t.seq=Ob.Long.fromValue(e.seq)).unsigned=!0:"string"===typeof e.seq?t.seq=parseInt(e.seq,10):"number"===typeof e.seq?t.seq=e.seq:"object"===typeof e.seq&&(t.seq=new Ob.LongBits(e.seq.low>>>0,e.seq.high>>>0).toNumber(!0))),null!=e.raw&&("string"===typeof e.raw?Ob.base64.decode(e.raw,t.raw=Ob.newBuffer(Ob.base64.length(e.raw)),0):e.raw.length&&(t.raw=e.raw)),t},e.toObject=function(e,t){t||(t={});var r={};if(t.defaults){if(Ob.Long){var s=new Ob.Long(0,0,!0);r.seq=t.longs===String?s.toString():t.longs===Number?s.toNumber():s}else r.seq=t.longs===String?"0":0;t.bytes===String?r.raw="":(r.raw=[],t.bytes!==Array&&(r.raw=Ob.newBuffer(r.raw)))}return null!=e.seq&&e.hasOwnProperty("seq")&&("number"===typeof e.seq?r.seq=t.longs===String?String(e.seq):e.seq:r.seq=t.longs===String?Ob.Long.prototype.toString.call(e.seq):t.longs===Number?new Ob.LongBits(e.seq.low>>>0,e.seq.high>>>0).toNumber(!0):e.seq),null!=e.raw&&e.hasOwnProperty("raw")&&(r.raw=t.bytes===String?Ob.base64.encode(e.raw,0,e.raw.length):t.bytes===Array?Array.prototype.slice.call(e.raw):e.raw),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e}(),e})(),Mb=d.Reader,Bb=d.Writer,Ub=d.util,jb=d.roots["default"]||(d.roots["default"]={}),Vb=jb.Peer=(()=>{function e(e){if(this.addresses=[],this.protocols=[],this.metadata=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}let t;return e.prototype.addresses=Ub.emptyArray,e.prototype.protocols=Ub.emptyArray,e.prototype.metadata=Ub.emptyArray,e.prototype.pubKey=null,e.prototype.peerRecordEnvelope=null,Object.defineProperty(e.prototype,"_pubKey",{get:Ub.oneOfGetter(t=["pubKey"]),set:Ub.oneOfSetter(t)}),Object.defineProperty(e.prototype,"_peerRecordEnvelope",{get:Ub.oneOfGetter(t=["peerRecordEnvelope"]),set:Ub.oneOfSetter(t)}),e.encode=function(e,t){if(t||(t=Bb.create()),null!=e.addresses&&e.addresses.length)for(var r=0;r<e.addresses.length;++r)jb.Address.encode(e.addresses[r],t.uint32(10).fork()).ldelim();if(null!=e.protocols&&e.protocols.length)for(r=0;r<e.protocols.length;++r)t.uint32(18).string(e.protocols[r]);if(null!=e.metadata&&e.metadata.length)for(r=0;r<e.metadata.length;++r)jb.Metadata.encode(e.metadata[r],t.uint32(26).fork()).ldelim();return null!=e.pubKey&&Object.hasOwnProperty.call(e,"pubKey")&&t.uint32(34).bytes(e.pubKey),null!=e.peerRecordEnvelope&&Object.hasOwnProperty.call(e,"peerRecordEnvelope")&&t.uint32(42).bytes(e.peerRecordEnvelope),t},e.decode=function(e,t){e instanceof Mb||(e=Mb.create(e));var r=void 0===t?e.len:e.pos+t,s=new jb.Peer;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.addresses&&s.addresses.length||(s.addresses=[]),s.addresses.push(jb.Address.decode(e,e.uint32()));break;case 2:s.protocols&&s.protocols.length||(s.protocols=[]),s.protocols.push(e.string());break;case 3:s.metadata&&s.metadata.length||(s.metadata=[]),s.metadata.push(jb.Metadata.decode(e,e.uint32()));break;case 4:s.pubKey=e.bytes();break;case 5:s.peerRecordEnvelope=e.bytes();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof jb.Peer)return e;var t=new jb.Peer;if(e.addresses){if(!Array.isArray(e.addresses))throw TypeError(".Peer.addresses: array expected");t.addresses=[];for(var r=0;r<e.addresses.length;++r){if("object"!==typeof e.addresses[r])throw TypeError(".Peer.addresses: object expected");t.addresses[r]=jb.Address.fromObject(e.addresses[r])}}if(e.protocols){if(!Array.isArray(e.protocols))throw TypeError(".Peer.protocols: array expected");t.protocols=[];for(r=0;r<e.protocols.length;++r)t.protocols[r]=String(e.protocols[r])}if(e.metadata){if(!Array.isArray(e.metadata))throw TypeError(".Peer.metadata: array expected");t.metadata=[];for(r=0;r<e.metadata.length;++r){if("object"!==typeof e.metadata[r])throw TypeError(".Peer.metadata: object expected");t.metadata[r]=jb.Metadata.fromObject(e.metadata[r])}}return null!=e.pubKey&&("string"===typeof e.pubKey?Ub.base64.decode(e.pubKey,t.pubKey=Ub.newBuffer(Ub.base64.length(e.pubKey)),0):e.pubKey.length&&(t.pubKey=e.pubKey)),null!=e.peerRecordEnvelope&&("string"===typeof e.peerRecordEnvelope?Ub.base64.decode(e.peerRecordEnvelope,t.peerRecordEnvelope=Ub.newBuffer(Ub.base64.length(e.peerRecordEnvelope)),0):e.peerRecordEnvelope.length&&(t.peerRecordEnvelope=e.peerRecordEnvelope)),t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.addresses=[],r.protocols=[],r.metadata=[]),e.addresses&&e.addresses.length){r.addresses=[];for(var s=0;s<e.addresses.length;++s)r.addresses[s]=jb.Address.toObject(e.addresses[s],t)}if(e.protocols&&e.protocols.length){r.protocols=[];for(s=0;s<e.protocols.length;++s)r.protocols[s]=e.protocols[s]}if(e.metadata&&e.metadata.length){r.metadata=[];for(s=0;s<e.metadata.length;++s)r.metadata[s]=jb.Metadata.toObject(e.metadata[s],t)}return null!=e.pubKey&&e.hasOwnProperty("pubKey")&&(r.pubKey=t.bytes===String?Ub.base64.encode(e.pubKey,0,e.pubKey.length):t.bytes===Array?Array.prototype.slice.call(e.pubKey):e.pubKey,t.oneofs&&(r._pubKey="pubKey")),null!=e.peerRecordEnvelope&&e.hasOwnProperty("peerRecordEnvelope")&&(r.peerRecordEnvelope=t.bytes===String?Ub.base64.encode(e.peerRecordEnvelope,0,e.peerRecordEnvelope.length):t.bytes===Array?Array.prototype.slice.call(e.peerRecordEnvelope):e.peerRecordEnvelope,t.oneofs&&(r._peerRecordEnvelope="peerRecordEnvelope")),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e})(),zb=(jb.Address=(()=>{function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}let t;return e.prototype.multiaddr=Ub.newBuffer([]),e.prototype.isCertified=null,Object.defineProperty(e.prototype,"_isCertified",{get:Ub.oneOfGetter(t=["isCertified"]),set:Ub.oneOfSetter(t)}),e.encode=function(e,t){return t||(t=Bb.create()),null!=e.multiaddr&&Object.hasOwnProperty.call(e,"multiaddr")&&t.uint32(10).bytes(e.multiaddr),null!=e.isCertified&&Object.hasOwnProperty.call(e,"isCertified")&&t.uint32(16).bool(e.isCertified),t},e.decode=function(e,t){e instanceof Mb||(e=Mb.create(e));var r=void 0===t?e.len:e.pos+t,s=new jb.Address;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.multiaddr=e.bytes();break;case 2:s.isCertified=e.bool();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof jb.Address)return e;var t=new jb.Address;return null!=e.multiaddr&&("string"===typeof e.multiaddr?Ub.base64.decode(e.multiaddr,t.multiaddr=Ub.newBuffer(Ub.base64.length(e.multiaddr)),0):e.multiaddr.length&&(t.multiaddr=e.multiaddr)),null!=e.isCertified&&(t.isCertified=Boolean(e.isCertified)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(t.bytes===String?r.multiaddr="":(r.multiaddr=[],t.bytes!==Array&&(r.multiaddr=Ub.newBuffer(r.multiaddr)))),null!=e.multiaddr&&e.hasOwnProperty("multiaddr")&&(r.multiaddr=t.bytes===String?Ub.base64.encode(e.multiaddr,0,e.multiaddr.length):t.bytes===Array?Array.prototype.slice.call(e.multiaddr):e.multiaddr),null!=e.isCertified&&e.hasOwnProperty("isCertified")&&(r.isCertified=e.isCertified,t.oneofs&&(r._isCertified="isCertified")),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e})(),jb.Metadata=(()=>{function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.key="",e.prototype.value=Ub.newBuffer([]),e.encode=function(e,t){return t||(t=Bb.create()),null!=e.key&&Object.hasOwnProperty.call(e,"key")&&t.uint32(10).string(e.key),null!=e.value&&Object.hasOwnProperty.call(e,"value")&&t.uint32(18).bytes(e.value),t},e.decode=function(e,t){e instanceof Mb||(e=Mb.create(e));var r=void 0===t?e.len:e.pos+t,s=new jb.Metadata;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.key=e.string();break;case 2:s.value=e.bytes();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof jb.Metadata)return e;var t=new jb.Metadata;return null!=e.key&&(t.key=String(e.key)),null!=e.value&&("string"===typeof e.value?Ub.base64.decode(e.value,t.value=Ub.newBuffer(Ub.base64.length(e.value)),0):e.value.length&&(t.value=e.value)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.key="",t.bytes===String?r.value="":(r.value=[],t.bytes!==Array&&(r.value=Ub.newBuffer(r.value)))),null!=e.key&&e.hasOwnProperty("key")&&(r.key=e.key),null!=e.value&&e.hasOwnProperty("value")&&(r.value=t.bytes===String?Ub.base64.encode(e.value,0,e.value.length):t.bytes===Array?Array.prototype.slice.call(e.value):e.value),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e})(),d.Reader),Fb=d.Writer,$b=d.util,Kb=d.roots["default"]||(d.roots["default"]={}),Hb=Kb.Envelope=(()=>{function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.publicKey=$b.newBuffer([]),e.prototype.payloadType=$b.newBuffer([]),e.prototype.payload=$b.newBuffer([]),e.prototype.signature=$b.newBuffer([]),e.encode=function(e,t){return t||(t=Fb.create()),null!=e.publicKey&&Object.hasOwnProperty.call(e,"publicKey")&&t.uint32(10).bytes(e.publicKey),null!=e.payloadType&&Object.hasOwnProperty.call(e,"payloadType")&&t.uint32(18).bytes(e.payloadType),null!=e.payload&&Object.hasOwnProperty.call(e,"payload")&&t.uint32(26).bytes(e.payload),null!=e.signature&&Object.hasOwnProperty.call(e,"signature")&&t.uint32(42).bytes(e.signature),t},e.decode=function(e,t){e instanceof zb||(e=zb.create(e));var r=void 0===t?e.len:e.pos+t,s=new Kb.Envelope;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.publicKey=e.bytes();break;case 2:s.payloadType=e.bytes();break;case 3:s.payload=e.bytes();break;case 5:s.signature=e.bytes();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof Kb.Envelope)return e;var t=new Kb.Envelope;return null!=e.publicKey&&("string"===typeof e.publicKey?$b.base64.decode(e.publicKey,t.publicKey=$b.newBuffer($b.base64.length(e.publicKey)),0):e.publicKey.length&&(t.publicKey=e.publicKey)),null!=e.payloadType&&("string"===typeof e.payloadType?$b.base64.decode(e.payloadType,t.payloadType=$b.newBuffer($b.base64.length(e.payloadType)),0):e.payloadType.length&&(t.payloadType=e.payloadType)),null!=e.payload&&("string"===typeof e.payload?$b.base64.decode(e.payload,t.payload=$b.newBuffer($b.base64.length(e.payload)),0):e.payload.length&&(t.payload=e.payload)),null!=e.signature&&("string"===typeof e.signature?$b.base64.decode(e.signature,t.signature=$b.newBuffer($b.base64.length(e.signature)),0):e.signature.length&&(t.signature=e.signature)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(t.bytes===String?r.publicKey="":(r.publicKey=[],t.bytes!==Array&&(r.publicKey=$b.newBuffer(r.publicKey))),t.bytes===String?r.payloadType="":(r.payloadType=[],t.bytes!==Array&&(r.payloadType=$b.newBuffer(r.payloadType))),t.bytes===String?r.payload="":(r.payload=[],t.bytes!==Array&&(r.payload=$b.newBuffer(r.payload))),t.bytes===String?r.signature="":(r.signature=[],t.bytes!==Array&&(r.signature=$b.newBuffer(r.signature)))),null!=e.publicKey&&e.hasOwnProperty("publicKey")&&(r.publicKey=t.bytes===String?$b.base64.encode(e.publicKey,0,e.publicKey.length):t.bytes===Array?Array.prototype.slice.call(e.publicKey):e.publicKey),null!=e.payloadType&&e.hasOwnProperty("payloadType")&&(r.payloadType=t.bytes===String?$b.base64.encode(e.payloadType,0,e.payloadType.length):t.bytes===Array?Array.prototype.slice.call(e.payloadType):e.payloadType),null!=e.payload&&e.hasOwnProperty("payload")&&(r.payload=t.bytes===String?$b.base64.encode(e.payload,0,e.payload.length):t.bytes===Array?Array.prototype.slice.call(e.payload):e.payload),null!=e.signature&&e.hasOwnProperty("signature")&&(r.signature=t.bytes===String?$b.base64.encode(e.signature,0,e.signature.length):t.bytes===Array?Array.prototype.slice.call(e.signature):e.signature),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e})(),qb=d.Reader,Gb=d.Writer,Wb=d.util,Yb=d.roots["default"]||(d.roots["default"]={}),Qb=Yb.PeerRecord=(()=>{function e(e){if(this.addresses=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.peerId=Wb.newBuffer([]),e.prototype.seq=Wb.Long?Wb.Long.fromBits(0,0,!0):0,e.prototype.addresses=Wb.emptyArray,e.encode=function(e,t){if(t||(t=Gb.create()),null!=e.peerId&&Object.hasOwnProperty.call(e,"peerId")&&t.uint32(10).bytes(e.peerId),null!=e.seq&&Object.hasOwnProperty.call(e,"seq")&&t.uint32(16).uint64(e.seq),null!=e.addresses&&e.addresses.length)for(var r=0;r<e.addresses.length;++r)Yb.PeerRecord.AddressInfo.encode(e.addresses[r],t.uint32(26).fork()).ldelim();return t},e.decode=function(e,t){e instanceof qb||(e=qb.create(e));var r=void 0===t?e.len:e.pos+t,s=new Yb.PeerRecord;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.peerId=e.bytes();break;case 2:s.seq=e.uint64();break;case 3:s.addresses&&s.addresses.length||(s.addresses=[]),s.addresses.push(Yb.PeerRecord.AddressInfo.decode(e,e.uint32()));break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof Yb.PeerRecord)return e;var t=new Yb.PeerRecord;if(null!=e.peerId&&("string"===typeof e.peerId?Wb.base64.decode(e.peerId,t.peerId=Wb.newBuffer(Wb.base64.length(e.peerId)),0):e.peerId.length&&(t.peerId=e.peerId)),null!=e.seq&&(Wb.Long?(t.seq=Wb.Long.fromValue(e.seq)).unsigned=!0:"string"===typeof e.seq?t.seq=parseInt(e.seq,10):"number"===typeof e.seq?t.seq=e.seq:"object"===typeof e.seq&&(t.seq=new Wb.LongBits(e.seq.low>>>0,e.seq.high>>>0).toNumber(!0))),e.addresses){if(!Array.isArray(e.addresses))throw TypeError(".PeerRecord.addresses: array expected");t.addresses=[];for(var r=0;r<e.addresses.length;++r){if("object"!==typeof e.addresses[r])throw TypeError(".PeerRecord.addresses: object expected");t.addresses[r]=Yb.PeerRecord.AddressInfo.fromObject(e.addresses[r])}}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.addresses=[]),t.defaults)if(t.bytes===String?r.peerId="":(r.peerId=[],t.bytes!==Array&&(r.peerId=Wb.newBuffer(r.peerId))),Wb.Long){var s=new Wb.Long(0,0,!0);r.seq=t.longs===String?s.toString():t.longs===Number?s.toNumber():s}else r.seq=t.longs===String?"0":0;if(null!=e.peerId&&e.hasOwnProperty("peerId")&&(r.peerId=t.bytes===String?Wb.base64.encode(e.peerId,0,e.peerId.length):t.bytes===Array?Array.prototype.slice.call(e.peerId):e.peerId),null!=e.seq&&e.hasOwnProperty("seq")&&("number"===typeof e.seq?r.seq=t.longs===String?String(e.seq):e.seq:r.seq=t.longs===String?Wb.Long.prototype.toString.call(e.seq):t.longs===Number?new Wb.LongBits(e.seq.low>>>0,e.seq.high>>>0).toNumber(!0):e.seq),e.addresses&&e.addresses.length){r.addresses=[];for(var n=0;n<e.addresses.length;++n)r.addresses[n]=Yb.PeerRecord.AddressInfo.toObject(e.addresses[n],t)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.AddressInfo=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.multiaddr=Wb.newBuffer([]),e.encode=function(e,t){return t||(t=Gb.create()),null!=e.multiaddr&&Object.hasOwnProperty.call(e,"multiaddr")&&t.uint32(10).bytes(e.multiaddr),t},e.decode=function(e,t){e instanceof qb||(e=qb.create(e));var r=void 0===t?e.len:e.pos+t,s=new Yb.PeerRecord.AddressInfo;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.multiaddr=e.bytes();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof Yb.PeerRecord.AddressInfo)return e;var t=new Yb.PeerRecord.AddressInfo;return null!=e.multiaddr&&("string"===typeof e.multiaddr?Wb.base64.decode(e.multiaddr,t.multiaddr=Wb.newBuffer(Wb.base64.length(e.multiaddr)),0):e.multiaddr.length&&(t.multiaddr=e.multiaddr)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(t.bytes===String?r.multiaddr="":(r.multiaddr=[],t.bytes!==Array&&(r.multiaddr=Wb.newBuffer(r.multiaddr)))),null!=e.multiaddr&&e.hasOwnProperty("multiaddr")&&(r.multiaddr=t.bytes===String?Wb.base64.encode(e.multiaddr,0,e.multiaddr.length):t.bytes===Array?Array.prototype.slice.call(e.multiaddr):e.multiaddr),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e}(),e})();async function Zb(e,t=(()=>{})){t(0,"Storing each peerstore key under a single datastore key"),await e.datastore.open();const r={},s=[];for await(const{key:n,value:i}of e.datastore.query({prefix:"/peers"})){s.push(n);const e=n.toString(),[t,o,a,c,l]=e.split("/");if("peers"===o&&(["protos","addrs","metadata","keys"].includes(a)&&c))if(r[c]=r[c]||{addresses:[],protocols:[],metadata:[]},"protos"===a){const e=Pb.decode(i);r[c].protocols=e.protocols.sort()}else if("addrs"===a){const e=xb.decode(i);r[c].addresses=e.addrs.sort(((e,t)=>(0,qe.HM)(e.multiaddr).toString().localeCompare((0,qe.HM)(t.multiaddr).toString()))),e.certifiedRecord&&e.certifiedRecord.raw&&(r[c].peerRecordEnvelope=e.certifiedRecord.raw)}else"metadata"===a?r[c].metadata.push({key:l,value:i}):"keys"===a&&(r[c].pubKey=i)}t(33,"Read peer data from store");for(const n of s)await e.datastore.delete(n);t(66,"Removed existing peer data from store");for(const n of Object.keys(r)){const t=r[n];t.metadata=t.metadata.sort(((e,t)=>e.key.localeCompare(t.key)));const s=Vb.encode(t).finish();await e.datastore.put(new lt.s(`/peers/${n}`),s)}await e.datastore.close(),t(100,"Stored each peerstore key under a single datastore key")}async function Xb(e,t=(()=>{})){t(0,"Storing each peerstore key under a multiple datastore keys"),await e.datastore.open();const r={},s=[];for await(const{key:n,value:i}of e.datastore.query({prefix:"/peers"})){s.push(n);const e=n.toString(),[t,o,a]=e.split("/");r[a]=Vb.decode(i)}t(33,"Read peer data from store");for(const n of s)await e.datastore.delete(n);t(66,"Removed existing peer data from store");for(const[n,i]of Object.entries(r)){if(i.protocols&&i.protocols.length>0&&await e.datastore.put(new lt.s(`/peers/protos/${n}`),Pb.encode({protocols:i.protocols}).finish()),i.addresses&&i.addresses.length>0){const t=i.peerRecordEnvelope;let r;if(t){const e=Hb.decode(t),s=Qb.decode(e.payload);r={raw:t,seq:s.seq}}await e.datastore.put(new lt.s(`/peers/addrs/${n}`),xb.encode({addrs:i.addresses,certifiedRecord:r}).finish())}if(i.metadata&&i.metadata.length>0)for(const{key:t,value:r}of i.metadata)await e.datastore.put(new lt.s(`/peers/metadata/${n}/${t}`),r);i.pubKey&&await e.datastore.put(new lt.s(`/peers/keys/${n}`),i.pubKey)}await e.datastore.close(),t(100,"Stored each peerstore key under multiple datastore keys")}d.util.Long=void 0,d.configure();const Jb={version:12,description:"Store each peerstore peer under a single datastore key",migrate:Zb,revert:Xb},e_={description:"Empty migration.",migrate:()=>{},revert:()=>{},empty:!0};var t_=[Object.assign({version:1},e_),Object.assign({version:2},e_),Object.assign({version:3},e_),Object.assign({version:4},e_),Object.assign({version:5},e_),Object.assign({version:6},e_),Object.assign({version:7},e_),jw,cb,_b,kb,Jb];class r_ extends Error{constructor(e){super(e),this.name="NonReversibleMigrationError",this.code=r_.code,this.message=e}}r_.code="ERR_NON_REVERSIBLE_MIGRATION";class s_ extends Error{constructor(e){super(e),this.name="NotInitializedRepoError",this.code=s_.code,this.message=e}}s_.code="ERR_NOT_INITIALIZED_REPO";class n_ extends Error{constructor(e){super(e),this.name="RequiredParameterError",this.code=n_.code,this.message=e}}n_.code="ERR_REQUIRED_PARAMETER";class i_ extends Error{constructor(e){super(e),this.name="InvalidValueError",this.code=i_.code,this.message=e}}i_.code="ERR_INVALID_VALUE";class o_ extends Error{constructor(e){super(e),this.name="MissingRepoOptionsError",this.code=o_.code,this.message=e}}o_.code="ERR_MISSING_REPO_OPTIONS";const a_=Nw("ipfs:repo:migrator:repo:init");async function c_(e){if(!e)throw new o_("Please pass repo options when trying to open a repo");const t=e.root;try{await t.open();const e=await t.has(ub),r=await t.has(lb);return!(!e||!r)||(a_(`Version entry present: ${e}`),a_(`Config entry present: ${r}`),!1)}catch(r){return a_("While checking if repo is initialized error was thrown: "+r.message),!1}finally{if(void 0!==t)try{await t.close()}catch{}}}async function l_(e){if(!await c_(e))throw new s_("Repo is not initialized!");const t=e.root;await t.open();try{return parseInt((0,Ye.B)(await t.get(ub)))}finally{await t.close()}}async function u_(e,t){if(!t)throw new o_("Please pass repo options when trying to open a repo");const r=t.root;await r.open(),await r.put(ub,(0,ze.m)(String(e))),await r.close()}const h_=Nw("ipfs:repo:migrator");function d_(e){return e=e||t_,Array.isArray(e)&&0!==e.length?e[e.length-1].version:0}async function p_(e,t,r,s,n={}){const i=n.ignoreLock??!1,o=n.onProgress,a=n.isDryRun??!1,c=n.migrations??t_;if(!e)throw new g_.RequiredParameterError("Path argument is required!");if(!r)throw new g_.RequiredParameterError("repoOptions argument is required!");if(!s)throw new g_.RequiredParameterError("toVersion argument is required!");if(!Number.isInteger(s)||s<=0)throw new g_.InvalidValueError("Version has to be positive integer!");t=yb(t);const l=await l_(t);if(l===s)return void h_("Nothing to migrate.");if(l>s)throw new g_.InvalidValueError(`Current repo's version (${l}) is higher then toVersion (${s}), you probably wanted to revert it?`);let u;y_(c,l,s),a||i||(u=await r.repoLock.lock(e));try{for(const e of c){if(void 0!==s&&e.version>s)break;if(!(e.version<=l)){h_(`Migrating version ${e.version}`);try{if(!a){let r=()=>{};o&&(r=(t,r)=>o(e.version,t.toFixed(2),r)),await e.migrate(t,r)}}catch(h){const r=e.version-1;throw h_(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${r}`),await u_(r,t),new Error(`During migration to version ${e.version} exception was raised: ${h.stack||h.message||h}`)}h_(`Migrating to version ${e.version} finished`)}}a||await u_(s||d_(c),t),h_("Repo successfully migrated",void 0!==s?`to version ${s}!`:"to latest version!")}finally{a||i||!u||await u.close()}}async function f_(e,t,r,s,n={}){const i=n.ignoreLock??!1,o=n.onProgress,a=n.isDryRun??!1,c=n.migrations??t_;if(!e)throw new g_.RequiredParameterError("Path argument is required!");if(!r)throw new g_.RequiredParameterError("repoOptions argument is required!");if(!s)throw new g_.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");if(!Number.isInteger(s)||s<=0)throw new g_.InvalidValueError("Version has to be positive integer!");t=yb(t);const l=await l_(t);if(l===s)return void h_("Nothing to revert.");if(l<s)throw new g_.InvalidValueError(`Current repo's version (${l}) is lower then toVersion (${s}), you probably wanted to migrate it?`);let u;y_(c,s,l,!0),a||i||(u=await r.repoLock.lock(e)),h_(`Reverting from version ${l} to ${s}`);try{const e=c.slice().reverse();for(const r of e){if(r.version<=s)break;if(!(r.version>l)){h_(`Reverting migration version ${r.version}`);try{if(!a){let e=()=>{};o&&(e=(e,t)=>o(r.version,e.toFixed(2),t)),await r.revert(t,e)}}catch(h){const e=r.version;throw h_(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${e}`),await u_(e,t),h.message=`During reversion to version ${r.version} exception was raised: ${h.message}`,h}h_(`Reverting to version ${r.version} finished`)}}a||await u_(s,t),h_(`All migrations successfully reverted to version ${s}!`)}finally{a||i||!u||await u.close()}}function y_(e,t,r,s=!1){let n=0;for(const i of e){if(i.version>r)break;if(i.version>t){if(s&&!i.revert)throw new g_.NonReversibleMigrationError(`It is not possible to revert to version ${t} because migration version ${i.version} is not reversible. Cancelling reversion.`);n++}}if(n!==r-t)throw new g_.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${t} to ${r}`)}const g_=o;var m_=r(79830);class w_ extends Error{constructor(e){super(e),this.name="LockExistsError",this.code=w_.code}}w_.code="ERR_LOCK_EXISTS";class b_ extends Error{constructor(e){super(e),this.name="NotFoundError",this.code=b_.code}}b_.code="ERR_NOT_FOUND";class __ extends Error{constructor(e){super(e),this.name="InvalidRepoVersionError",this.code=__.code}}__.code="ERR_INVALID_REPO_VERSION";const E_="ERR_REPO_NOT_INITIALIZED",v_="ERR_REPO_ALREADY_OPEN",S_="ERR_REPO_ALREADY_CLOSED";async function I_(e,t,r){const s=await t(e);if(s)return s;const n=R_(r);return!!n&&new Promise(((t,r)=>{const s=n.store("readonly").get(e.toString());s.transaction.onabort=()=>{r(s.transaction.error)},s.transaction.oncomplete=()=>{t(Boolean(s.result))}}))}async function k_(e,t,r,s){if(await r(e))return t(e);const n=R_(s);if(!n)throw new b_;return new Promise(((t,r)=>{const s=n.store("readonly").get(e.toString());s.transaction.onabort=()=>{r(s.transaction.error)},s.transaction.oncomplete=()=>{if(s.result)return t(s.result);r(new b_)}}))}function R_(e){let t=e;while(t.db||t.child)if(t=t.db||t.child,"level-js"===t.type||"Level"===t.constructor.name)return t}const T_=Nw("ipfs:repo:version"),A_=new lt.s("version");function C_(e){return{async exists(){return I_(A_,e.has.bind(e),e)},async get(){const t=await k_(A_,e.get.bind(e),e.has.bind(e),e);return parseInt((0,Ye.B)(t),10)},set(t){return e.put(A_,(0,ze.m)(String(t)))},async check(e){const t=await this.get();T_("comparing version: %s and %s",t,e);const r=6===t&&7===e||6===e&&7===t;return t===e||r}}}const P_=Lt.Z["default"]?Lt.Z["default"]:Lt.Z,D_=new lt.s("config");function N_(e){const t=new P_({concurrency:1}),r={async getAll(t={}){const r=await k_(D_,e.get.bind(e),e.has.bind(e),e);return JSON.parse((0,Ye.B)(r))},async get(e,t={}){if(null==e)throw new b_(`Key ${e} does not exist in config`);const r=await this.getAll(t),s=Pw(r,e);if(void 0===s)throw new b_(`Key ${e} does not exist in config`);return s},set(e,r,n={}){if("string"!==typeof e&&!(e instanceof String))throw h(new Error("Invalid key type: "+typeof e),"ERR_INVALID_KEY");if(void 0===r||r instanceof Uint8Array)throw h(new Error("Invalid value type: "+typeof r),"ERR_INVALID_VALUE");return t.add((()=>s({key:e,value:r},n.signal)))},replace(e,r={}){if(!e||e instanceof Uint8Array)throw h(new Error("Invalid value type: "+typeof e),"ERR_INVALID_VALUE");return t.add((()=>s({key:void 0,value:e},r.signal)))},async exists(){return I_(D_,e.has.bind(e),e)}};return r;async function s(e,t){if(t&&t.aborted)return;const s=e.key,i=e.value;if(s){const e=await r.getAll();return"object"===typeof e&&null!==e&&gf(e,s,i),n(e)}return n(i)}function n(t){const r=(0,ze.m)(JSON.stringify(t,null,2));return e.put(D_,r)}}function O_(e){if("object"!==typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)}function L_(e,t={}){if(!O_(e)&&!Array.isArray(e))throw new TypeError("Expected a plain object or array");const{deep:r,compare:s}=t,n=[],i=[],o=e=>{const t=n.indexOf(e);if(-1!==t)return i[t];const r=[];return n.push(e),i.push(r),r.push(...e.map((e=>Array.isArray(e)?o(e):O_(e)?a(e):e))),r},a=e=>{const t=n.indexOf(e);if(-1!==t)return i[t];const c={},l=Object.keys(e).sort(s);n.push(e),i.push(c);for(const s of l){const t=e[s];let n;n=r&&Array.isArray(t)?o(t):r&&O_(t)?a(t):t,Object.defineProperty(c,s,{...Object.getOwnPropertyDescriptor(e,s),value:n})}return c};return Array.isArray(e)?r?o(e):e.slice():a(e)}const x_=new lt.s("datastore_spec");function M_(e){return{exists(){return e.has(x_)},async get(){const t=await e.get(x_);return JSON.parse((0,Ye.B)(t))},async set(t){return e.put(x_,(0,ze.m)(JSON.stringify(L_(t,{deep:!0}))))}}}const B_=new lt.s("api");function U_(e){return{async get(){const t=await e.get(B_);return t&&t.toString()},set(t){return e.put(B_,(0,ze.m)(t.toString()))},delete(){return e.delete(B_)}}}function j_(e){return{open(){return e.open()},close(){return e.close()},query(t,r){return e.query(t,r)},queryKeys(t,r){return e.queryKeys(t,r)},async get(t,r){const s=V_(t);return s.isIdentity?Promise.resolve(s.digest):e.get(t,r)},async*getMany(e,t){for await(const r of e)yield this.get(r,t)},async put(t,r,s){const{isIdentity:n}=V_(t);n||await e.put(t,r,s)},async*putMany(t,r){const s=(0,_s.d)({objectMode:!0}),n=globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout;n((async()=>{try{await gs(e.putMany(async function*(){for await(const{key:e,value:r}of t)V_(e).isIdentity||(yield{key:e,value:r}),s.push({key:e,value:r})}())),s.end()}catch(mu){s.end(mu)}})),yield*s},has(t,r){const{isIdentity:s}=V_(t);return s?Promise.resolve(!0):e.has(t,r)},delete(t,r){const{isIdentity:s}=V_(t);return s?Promise.resolve():e.delete(t,r)},deleteMany(t,r){return e.deleteMany(ms(t,(e=>!V_(e).isIdentity)),r)},batch(){const t=e.batch();return{put(e,r){const{isIdentity:s}=V_(e);s||t.put(e,r)},delete(e){const{isIdentity:r}=V_(e);r||t.delete(e)},commit:e=>t.commit(e)}}}}function V_(e){const t=A.CID.asCID(e);if(null==t)throw h(new Error("Not a valid cid"),"ERR_INVALID_CID");return t.multihash.code!==De.identity.code?{isIdentity:!1}:{isIdentity:!0,digest:t.multihash.digest}}const z_=Nw("ipfs:repo:lock:memory"),F_="repo.lock",$_={};async function K_(e){const t=e+"/"+F_;if(z_("locking %s",t),!0===$_[t])throw new w_(`Lock already being held for file: ${t}`);$_[t]=!0;const r={async close(){$_[t]&&delete $_[t]}};return r}async function H_(e){const t=e+"/"+F_;return z_(`checking lock: ${t}`),Boolean($_[t])}const q_={lock:K_,locked:H_};var G_={autoMigrate:!0,onMigrationProgress:()=>{},repoOwner:!0,repoLock:q_},W_={Spec:{type:"mount",mounts:[{mountpoint:"/blocks",type:"measure",prefix:"flatfs.datastore",child:{type:"flatfs",path:"blocks",sync:!0,shardFunc:"/repo/flatfs/shard/v1/next-to-last/2"}},{mountpoint:"/",type:"measure",prefix:"leveldb.datastore",child:{type:"levelds",path:"datastore",compression:"none"}}]}};function Y_(e){const t=V.k0.asCID(e);if(null==t)throw h(new Error("Not a valid cid"),"ERR_INVALID_CID");const r=Ke.base32.encode(t.multihash.bytes);return new lt.s("/"+r.slice(1).toUpperCase(),!1)}function Q_(e){return He.Jx(Ke.base32.decode(`b${e.toString().toLowerCase().substring(1)}`))}const Z_=Nw("ipfs:repo:utils:walk-dag");async function*X_(e,t,r,s){try{const n=await t.get(e,s),i=await r(e.code),o=(0,Sf.createUnsafe)({bytes:n,cid:e,codec:i});for(const[,e]of o.links())yield e,yield*X_(e,t,r,s)}catch(mu){throw Z_("Could not walk DAG for CID",e.toString(),mu),mu}}class J_ extends Map{constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if("number"===typeof e.maxAge&&0===e.maxAge)throw new TypeError("`maxAge` must be a number greater than 0");this.maxSize=e.maxSize,this.maxAge=e.maxAge||Number.POSITIVE_INFINITY,this.onEviction=e.onEviction,this.cache=new Map,this.oldCache=new Map,this._size=0}_emitEvictions(e){if("function"===typeof this.onEviction)for(const[t,r]of e)this.onEviction(t,r.value)}_deleteIfExpired(e,t){return"number"===typeof t.expiry&&t.expiry<=Date.now()&&("function"===typeof this.onEviction&&this.onEviction(e,t.value),this.delete(e))}_getOrDeleteIfExpired(e,t){const r=this._deleteIfExpired(e,t);if(!1===r)return t.value}_getItemValue(e,t){return t.expiry?this._getOrDeleteIfExpired(e,t):t.value}_peek(e,t){const r=t.get(e);return this._getItemValue(e,r)}_set(e,t){this.cache.set(e,t),this._size++,this._size>=this.maxSize&&(this._size=0,this._emitEvictions(this.oldCache),this.oldCache=this.cache,this.cache=new Map)}_moveToRecent(e,t){this.oldCache.delete(e),this._set(e,t)}*_entriesAscending(){for(const e of this.oldCache){const[t,r]=e;if(!this.cache.has(t)){const s=this._deleteIfExpired(t,r);!1===s&&(yield e)}}for(const e of this.cache){const[t,r]=e,s=this._deleteIfExpired(t,r);!1===s&&(yield e)}}get(e){if(this.cache.has(e)){const t=this.cache.get(e);return this._getItemValue(e,t)}if(this.oldCache.has(e)){const t=this.oldCache.get(e);if(!1===this._deleteIfExpired(e,t))return this._moveToRecent(e,t),t.value}}set(e,t,{maxAge:r=this.maxAge}={}){const s="number"===typeof r&&r!==Number.POSITIVE_INFINITY?Date.now()+r:void 0;this.cache.has(e)?this.cache.set(e,{value:t,expiry:s}):this._set(e,{value:t,expiry:s})}has(e){return this.cache.has(e)?!this._deleteIfExpired(e,this.cache.get(e)):!!this.oldCache.has(e)&&!this._deleteIfExpired(e,this.oldCache.get(e))}peek(e){return this.cache.has(e)?this._peek(e,this.cache):this.oldCache.has(e)?this._peek(e,this.oldCache):void 0}delete(e){const t=this.cache.delete(e);return t&&this._size--,this.oldCache.delete(e)||t}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this._entriesAscending()],r=t.length-e;r<0?(this.cache=new Map(t),this.oldCache=new Map,this._size=t.length):(r>0&&this._emitEvictions(t.slice(0,r)),this.oldCache=new Map(t.slice(r)),this.cache=new Map,this._size=0),this.maxSize=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache){const[t,r]=e,s=this._deleteIfExpired(t,r);!1===s&&(yield[t,r.value])}for(const e of this.oldCache){const[t,r]=e;if(!this.cache.has(t)){const e=this._deleteIfExpired(t,r);!1===e&&(yield[t,r.value])}}}*entriesDescending(){let e=[...this.cache];for(let t=e.length-1;t>=0;--t){const r=e[t],[s,n]=r,i=this._deleteIfExpired(s,n);!1===i&&(yield[s,n.value])}e=[...this.oldCache];for(let t=e.length-1;t>=0;--t){const r=e[t],[s,n]=r;if(!this.cache.has(s)){const e=this._deleteIfExpired(s,n);!1===e&&(yield[s,n.value])}}}*entriesAscending(){for(const[e,t]of this._entriesAscending())yield[e,t.value]}get size(){if(!this._size)return this.oldCache.size;let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return Math.min(this._size+e,this.maxSize)}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[r,s]of this.entriesAscending())e.call(t,s,r,this)}get[Symbol.toStringTag](){return JSON.stringify([...this.entriesAscending()])}}const eE=2048;function tE(e){const t=`Invalid type '${e}', must be one of {direct, indirect, recursive, all}`;return h(new Error(t),"ERR_INVALID_PIN_TYPE")}class rE{constructor({pinstore:e,blockstore:t,loadCodec:r}){this.pinstore=e,this.blockstore=t,this.loadCodec=r,this.log=Nw("ipfs:repo:pin"),this.directPins=new Set,this.recursivePins=new Set}async pinDirectly(e,t={}){await this.blockstore.get(e,t);const r={depth:0};return 0!==e.version&&(r.version=e.version),e.code!==R.code&&(r.codec=e.code),t.metadata&&(r.metadata=t.metadata),this.pinstore.put(Y_(e),T.cv(r))}unpin(e,t){return this.pinstore.delete(Y_(e),t)}async pinRecursively(e,t={}){await this.fetchCompleteDag(e,t);const r={depth:1/0};0!==e.version&&(r.version=e.version),e.code!==R.code&&(r.codec=e.code),t.metadata&&(r.metadata=t.metadata),await this.pinstore.put(Y_(e),T.cv(r))}async*directKeys(e){for await(const t of this.pinstore.query({filters:[e=>{const t=T.Jx(e.value);return 0===t.depth}]})){const e=T.Jx(t.value),r=e.version||0,s=null!=e.codec?e.codec:R.code,n=Q_(t.key);yield{cid:A.CID.create(r,s,n),metadata:e.metadata}}}async*recursiveKeys(e){for await(const t of this.pinstore.query({filters:[e=>{const t=T.Jx(e.value);return t.depth===1/0}]})){const e=T.Jx(t.value),r=e.version||0,s=null!=e.codec?e.codec:R.code,n=Q_(t.key);yield{cid:A.CID.create(r,s,n),metadata:e.metadata}}}async*indirectKeys(e){for await(const{cid:t}of this.recursiveKeys())for await(const r of X_(t,this.blockstore,this.loadCodec,e)){const e=[Xt.recursive],t=await this.isPinnedWithType(r,e);t.pinned||(yield r)}}async isPinnedWithType(e,t,r){Array.isArray(t)||(t=[t]);const s=t.includes(Xt.all),n=t.includes(Xt.direct),i=t.includes(Xt.recursive),o=t.includes(Xt.indirect);if(i||n||s){const r=await sy(this.pinstore.query({prefix:Y_(e).toString(),filters:[e=>{if(s)return!0;const r=T.Jx(e.value);return t.includes(0===r.depth?Xt.direct:Xt.recursive)}],limit:1}));if(r){const t=T.Jx(r.value);return{cid:e,pinned:!0,reason:0===t.depth?Xt.direct:Xt.recursive,metadata:t.metadata}}}const a=this;async function*c(e,t){for await(const{cid:r}of t)for await(const t of X_(r,a.blockstore,a.loadCodec))if(t.equals(e))return void(yield r)}if(s||o){const t=await sy(c(e,this.recursiveKeys()));if(t)return{cid:e,pinned:!0,reason:Xt.indirect,parent:t}}return{cid:e,pinned:!1}}async fetchCompleteDag(e,t={}){const r=new J_({maxSize:t.cidCacheMaxSize??eE}),s=async(e,t)=>{if(r.has(e.toString()))return;r.set(e.toString(),!0);const n=await this.blockstore.get(e,t),i=await this.loadCodec(e.code),o=(0,Sf.createUnsafe)({bytes:n,cid:e,codec:i});await Promise.all([...o.links()].map((([,e])=>s(e,t))))};await s(e,t)}static checkPinType(e){if("string"!==typeof e||!Object.keys(Xt).includes(e))throw tE(e);return!0}}function sE(e,t){return{open(){return t.open()},close(){return t.close()},query(e,r){return t.query(e,r)},queryKeys(e,r){return t.queryKeys(e,r)},async get(e,r){return t.get(e,r)},async*getMany(e,r){yield*t.getMany(e,r)},async put(e,r,s){await t.put(e,r,s)},async*putMany(e,r){yield*t.putMany(e,r)},has(e,r){return t.has(e,r)},async delete(r,s){return await nE(r,e),t.delete(r,s)},deleteMany(r,s){return t.deleteMany(As(r,(async t=>(await nE(t,e),t))),s)},batch(){return t.batch()}}}async function nE(e,t){const{pinned:r,reason:s}=await t.isPinnedWithType(e,Xt.all);if(r)throw h(new Error(`pinned: ${s}`),"ERR_BLOCK_PINNED")}const iE=Nw("ipfs:repo:gc"),oE=lr().code,aE=256,cE=new lt.s("/local/filesroot");function lE({gcLock:e,pins:t,blockstore:r,root:s,loadCodec:n}){async function*i(){const i=Date.now();iE("Creating set of marked blocks");const o=await e.writeLock();try{const e=await uE({pins:t,blockstore:r,root:s,loadCodec:n}),a=r.queryKeys({});yield*hE({blockstore:r},e,a),iE(`Complete (${Date.now()-i}ms)`)}finally{o()}}return i}async function uE({pins:e,blockstore:t,loadCodec:r,root:s}){const n=async function*(){let e;try{e=await s.get(cE)}catch(mu){if(mu.code===oE)return void iE("No blocks in MFS");throw mu}const n=A.CID.decode(e);yield n,yield*X_(n,t,r)}(),i=Ps(As(e.recursiveKeys(),(({cid:e})=>e)),e.indirectKeys(),As(e.directKeys(),(({cid:e})=>e)),n),o=new Set;for await(const a of Ps(i,n))o.add(Ke.base32.encode(a.multihash.bytes));return o}async function*hE({blockstore:e},t,r){let s=0,n=0;const i=async r=>async function(){s++;try{const s=Ke.base32.encode(r.multihash.bytes);if(t.has(s))return null;try{await e.delete(r),n++}catch(mu){return{err:new Error(`Could not delete block with CID ${r}: ${mu.message}`)}}return{cid:r}}catch(mu){const t=`Could delete block with CID ${r}`;return iE(t,mu),{err:new Error(t+`: ${mu.message}`)}}};yield*(0,Cs.zG)(ei(As(r,i),aE),(e=>ms(e,Boolean))),iE(`Marked set has ${t.size} unique blocks. Blockstore has ${s} blocks. Deleted ${n} blocks.`)}const dE=Nw("ipfs:repo"),pE=Number.MAX_SAFE_INTEGER,fE="repoAutoMigrate";class yE{constructor(e,t,r,s){if("string"!==typeof e)throw new Error("missing repo path");if("function"!==typeof t)throw new Error("missing codec loader");this.options=(0,c.Z)(G_,s),this.closed=!0,this.path=e,this.root=r.root,this.datastore=r.datastore,this.keys=r.keys;const n=r.blocks,i=r.pins;this.pins=new rE({pinstore:i,blockstore:n,loadCodec:t});const o=sE(this.pins,n);this.blocks=j_(o),this.version=C_(this.root),this.config=N_(this.root),this.spec=M_(this.root),this.apiAddr=U_(this.root),this.gcLock=Zy({name:e,singleProcess:!1!==this.options.repoOwner}),this.gc=lE({gcLock:this.gcLock,pins:this.pins,blockstore:this.blocks,root:this.root,loadCodec:t})}async init(e){dE("initializing at: %s",this.path),await this._openRoot(),await this.config.replace(wE(e)),await this.spec.set(bE(e)),await this.version.set(Iw)}async isInitialized(){if(!this.closed)return!0;try{return await this._openRoot(),await this._checkInitialized(),await this.root.close(),!0}catch(mu){return!1}}async open(){if(!this.closed)throw h(new Error("repo is already open"),v_);dE("opening at: %s",this.path);try{await this._openRoot(),await this._checkInitialized(),this._lockfile=await this._openLock(),dE("acquired repo.lock");const e=await this.version.check(Iw);if(!e){if(!await this._isAutoMigrationEnabled())throw new __("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");await this._migrate(Iw,{root:this.root,datastore:this.datastore,pins:this.pins.pinstore,blocks:this.pins.blockstore,keys:this.keys})}dE("creating datastore"),await this.datastore.open(),dE("creating blocks"),await this.blocks.open(),dE("creating keystore"),await this.keys.open(),dE("creating pins"),await this.pins.pinstore.open(),this.closed=!1,dE("all opened")}catch(mu){if(this._lockfile)try{await this._closeLock(),this._lockfile=null}catch(e){dE("error removing lock",e)}throw mu}}async _openRoot(){try{await this.root.open()}catch(mu){if("Already open"!==mu.message)throw mu}}async _openLock(){const e=await this.options.repoLock.lock(this.path);if("function"!==typeof e.close)throw h(new Error("Locks must have a close method"),"ERR_NO_CLOSE_FUNCTION");return e}_closeLock(){return this._lockfile&&this._lockfile.close()}async _checkInitialized(){let e;dE("init check");try{[e]=await Promise.all([this.config.exists(),this.spec.exists(),this.version.exists()])}catch(mu){if("ERR_NOT_FOUND"===mu.code)throw h(new Error("repo is not initialized yet"),E_,{path:this.path});throw mu}if(!e)throw h(new Error("repo is not initialized yet"),E_,{path:this.path})}async close(){if(this.closed)throw h(new Error("repo is already closed"),S_);dE("closing at: %s",this.path);try{await this.apiAddr.delete()}catch(mu){if(mu.code!==E_&&!mu.message.startsWith("ENOENT"))throw mu}await Promise.all([this.root,this.blocks,this.keys,this.datastore,this.pins.pinstore].map((e=>e&&e.close()))),dE("unlocking"),this.closed=!0,await this._closeLock()}exists(){return this.version.exists()}async stat(){if(this.datastore&&this.keys){const[e,t,r,s,n]=await Promise.all([this._storageMaxStat(),this._blockStat(),this.version.get(),gE(this.datastore),gE(this.keys)]),i=t.size+s+n;return{repoPath:this.path,storageMax:e,version:r,numObjects:t.count,repoSize:i}}throw h(new Error("repo is not initialized yet"),E_,{path:this.path})}async _isAutoMigrationEnabled(){if(void 0!==this.options.autoMigrate)return this.options.autoMigrate;let e;try{e=await this.config.get(fE)}catch(t){if(t.code!==b_.code)throw t;e=!0}return e}async _migrate(e,t){const r=await this.version.get();return r>e?(dE(`reverting to version ${e}`),f_(this.path,t,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress})):(dE(`migrating to version ${e}`),p_(this.path,t,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress}))}async _storageMaxStat(){try{const e=await this.config.get("Datastore.StorageMax");return BigInt(m_(e))}catch(mu){return BigInt(pE)}}async _blockStat(){let e=BigInt(0),t=BigInt(0);if(this.blocks)for await(const{key:r,value:s}of this.blocks.query({}))e+=BigInt(1),t+=BigInt(s.byteLength),t+=BigInt(r.bytes.byteLength);return{count:e,size:t}}}async function gE(e){let t=BigInt(0);for await(const r of e.query({}))t+=BigInt(r.value.byteLength),t+=BigInt(r.key.uint8Array().byteLength);return t}function mE(e,t,r,s){return new yE(e,t,r,s)}function wE(e){return e.Datastore=Object.assign({},W_,Pw(e,"datastore")),e}function bE(e){const t={...W_.Spec,...Pw(e,"Datastore.Spec")};return{type:t.type,mounts:t.mounts.map((e=>({mountpoint:e.mountpoint,type:e.child.type,path:e.child.path,shardFunc:e.child.shardFunc})))}}var _E=r(97515),EE=r(69202);class vE extends bs{constructor(e,t={}){super(),this.db="string"===typeof e?new EE.Level(e,{...t,keyEncoding:"utf8",valueEncoding:"view"}):e,this.opts={createIfMissing:!0,compression:!1,...t}}async open(){try{await this.db.open(this.opts)}catch(mu){throw or(mu)}}async put(e,t){try{await this.db.put(e.toString(),t)}catch(mu){throw cr(mu)}}async get(e){let t;try{t=await this.db.get(e.toString())}catch(mu){if(mu.notFound)throw lr(mu);throw cr(mu)}return t}async has(e){try{await this.db.get(e.toString())}catch(mu){if(mu.notFound)return!1;throw mu}return!0}async delete(e){try{await this.db.del(e.toString())}catch(mu){throw ar(mu)}}close(){return this.db&&this.db.close()}batch(){const e=[];return{put:(t,r)=>{e.push({type:"put",key:t.toString(),value:r})},delete:t=>{e.push({type:"del",key:t.toString()})},commit:()=>this.db.batch(e)}}query(e){let t=this._query({values:!0,prefix:e.prefix});Array.isArray(e.filters)&&(t=e.filters.reduce(((e,t)=>ms(e,t)),t)),Array.isArray(e.orders)&&(t=e.orders.reduce(((e,t)=>_E(e,t)),t));const{offset:r,limit:s}=e;if(r){let e=0;t=ms(t,(()=>e++>=r))}return s&&(t=ws(t,s)),t}queryKeys(e){let t=As(this._query({values:!1,prefix:e.prefix}),(({key:e})=>e));Array.isArray(e.filters)&&(t=e.filters.reduce(((e,t)=>ms(e,t)),t)),Array.isArray(e.orders)&&(t=e.orders.reduce(((e,t)=>_E(e,t)),t));const{offset:r,limit:s}=e;if(r){let e=0;t=ms(t,(()=>e++>=r))}return s&&(t=ws(t,s)),t}_query(e){const t={keys:!0,keyEncoding:"buffer",values:e.values};if(null!=e.prefix){const r=e.prefix.toString();t.gte=r,t.lt=r+""}const r=this.db.iterator(t);if(r[Symbol.asyncIterator])return SE(r);if(null!=r.next&&null!=r.end)return IE(r);throw new Error("Level returned incompatible iterator")}}async function*SE(e){for await(const[t,r]of e)yield{key:new lt.s(t,!1),value:r};await e.close()}function IE(e){return{[Symbol.asyncIterator](){return{next:()=>new Promise(((t,r)=>{e.next(((s,n,i)=>s?r(s):null==n?e.end((e=>{if(e)return r(e);t({done:!0,value:void 0})})):void t({done:!1,value:{key:new lt.s(n,!1),value:i}})))})),return:()=>new Promise(((t,r)=>{e.end((e=>{if(e)return r(e);t({done:!0,value:void 0})}))}))}}}}const kE=(e,t)=>async function*(){const r=await fs(e);yield*r.sort(t)}();class RE{open(){return Promise.reject(new Error(".open is not implemented"))}close(){return Promise.reject(new Error(".close is not implemented"))}put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:s}of e)await this.put(r,s,t),yield{key:r,value:s}}async*getMany(e,t={}){for await(const r of e)yield this.get(r,t)}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(t,r){e.push({key:t,value:r})},delete(e){t.push(e)},commit:async r=>{await gs(this.putMany(e,r)),e=[],await gs(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(null!=e.prefix&&(r=ms(r,(t=>t.key.toString().startsWith(e.prefix||"")))),Array.isArray(e.filters)&&(r=e.filters.reduce(((e,t)=>ms(e,t)),r)),Array.isArray(e.orders)&&(r=e.orders.reduce(((e,t)=>kE(e,t)),r)),null!=e.offset){let t=0;r=ms(r,(()=>t++>=(e.offset||0)))}return null!=e.limit&&(r=ws(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(null!=e.prefix&&(r=ms(r,(t=>t.toString().startsWith(e.prefix||"")))),Array.isArray(e.filters)&&(r=e.filters.reduce(((e,t)=>ms(e,t)),r)),Array.isArray(e.orders)&&(r=e.orders.reduce(((e,t)=>kE(e,t)),r)),null!=e.offset){let t=0;r=ms(r,(()=>t++>=e.offset))}return null!=e.limit&&(r=ws(r,e.limit)),r}}function TE(e){const t=A.CID.asCID(e);if(!t)throw h(new Error("Not a valid cid"),"ERR_INVALID_CID");return new lt.s("/"+Ke.base32.encode(t.multihash.bytes).slice(1).toUpperCase(),!1)}function AE(e){return A.CID.createV1(pi.code,He.Jx(Ke.base32.decode("b"+e.toString().slice(1).toLowerCase())))}function CE(e){const t=e.substring(0,1);if("/"===t)return CE(e.substring(1));let r,s;r="b"===t.toLowerCase()?e=>Ke.base32.decode(e.toLowerCase()).subarray(2):"c"===t.toLowerCase()?e=>Ke.base32pad.decode(e.toLowerCase()).subarray(2):"z"===t?e=>$e.base58btc.decode(e).subarray(2):"Q"===t?e=>$e.base58btc.decode("z"+e):e=>Ke.base32.decode("b"+e.toLowerCase()).subarray(2);for(let i=1;i<e.length;i++)try{s=r(e.substring(0,i))}catch(mu){if("Unexpected end of data"!==mu.message)throw mu}let n="/C";return s&&(n=`/${Ke.base32.encode(s).slice(1,-1).toUpperCase()||"C"}`),n}function PE(e){return{...e,prefix:e.prefix?CE(e.prefix):void 0,filters:e.filters?e.filters.map((e=>t=>e({key:AE(t.key),value:t.value}))):void 0,orders:e.orders?e.orders.map((e=>(t,r)=>e({key:AE(t.key),value:t.value},{key:AE(r.key),value:r.value}))):void 0}}function DE(e){return{...e,prefix:e.prefix?CE(e.prefix):void 0,filters:e.filters?e.filters.map((e=>t=>e(AE(t)))):void 0,orders:e.orders?e.orders.map((e=>(t,r)=>e(AE(t),AE(r)))):void 0}}class NE extends RE{constructor(e){super(),this.child=e}open(){return this.child.open()}close(){return this.child.close()}async*query(e,t){for await(const{key:r,value:s}of this.child.query(PE(e),t))yield{key:AE(r),value:s}}async*queryKeys(e,t){for await(const r of this.child.queryKeys(DE(e),t))yield AE(r)}async get(e,t){return this.child.get(TE(e),t)}async*getMany(e,t){for await(const r of e)yield this.get(r,t)}async put(e,t,r){await this.child.put(TE(e),t,r)}async*putMany(e,t){const r=(0,_s.d)({objectMode:!0}),s=globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout;s((async()=>{try{const s=this.child;await gs(this.child.putMany(async function*(){for await(const n of e){const e=TE(n.key),i=await s.has(e,t);i||(yield{key:e,value:n.value}),r.push(n)}}())),r.end()}catch(mu){r.end(mu)}})),yield*r}has(e,t){return this.child.has(TE(e),t)}delete(e,t){return this.child.delete(TE(e),t)}deleteMany(e,t){const r=(0,_s.d)({objectMode:!0});return gs(this.child.deleteMany(async function*(){for await(const t of e)yield TE(t),r.push(t);r.end()}(),t)).catch((e=>{r.end(e)})),r}}function OE(e,t,r){const s=r.path||"ipfs";return mE(s,(e=>t.getCodec(e)),{root:new vE(s,{prefix:"",version:2}),blocks:new NE(new vE(`${s}/blocks`,{prefix:"",version:2})),datastore:new vE(`${s}/datastore`,{prefix:"",version:2}),keys:new vE(`${s}/keys`,{prefix:"",version:2}),pins:new vE(`${s}/pins`,{prefix:"",version:2})},{autoMigrate:r.autoMigrate,onMigrationProgress:r.onMigrationProgress||e,repoLock:q_})}const LE={ERR_SIGNATURE_NOT_VALID:"ERR_SIGNATURE_NOT_VALID"};var xE;(function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.publicKey)throw new Error('Protocol error: required field "publicKey" was not found in object');if(t.uint32(10),t.bytes(e.publicKey),null==e.payloadType)throw new Error('Protocol error: required field "payloadType" was not found in object');if(t.uint32(18),t.bytes(e.payloadType),null==e.payload)throw new Error('Protocol error: required field "payload" was not found in object');if(t.uint32(26),t.bytes(e.payload),null==e.signature)throw new Error('Protocol error: required field "signature" was not found in object');t.uint32(42),t.bytes(e.signature),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={publicKey:new Uint8Array(0),payloadType:new Uint8Array(0),payload:new Uint8Array(0),signature:new Uint8Array(0)},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.publicKey=e.bytes();break;case 2:r.payloadType=e.bytes();break;case 3:r.payload=e.bytes();break;case 5:r.signature=e.bytes();break;default:e.skipType(7&t);break}}if(null==r.publicKey)throw new Error('Protocol error: value for required field "publicKey" was not found in protobuf');if(null==r.payloadType)throw new Error('Protocol error: value for required field "payloadType" was not found in protobuf');if(null==r.payload)throw new Error('Protocol error: value for required field "payload" was not found in protobuf');if(null==r.signature)throw new Error('Protocol error: value for required field "signature" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(xE||(xE={}));var ME=r(56067);class BE{constructor(e){const{peerId:t,payloadType:r,payload:s,signature:n}=e;this.peerId=t,this.payloadType=r,this.payload=s,this.signature=n}marshal(){if(null==this.peerId.publicKey)throw new Error("Missing public key");return null==this.marshaled&&(this.marshaled=xE.encode({publicKey:this.peerId.publicKey,payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return(0,ur.f)(this.marshal(),e.marshal())}async validate(e){const t=UE(e,this.payloadType,this.payload);if(null==this.peerId.publicKey)throw new Error("Missing public key");const r=(0,dr.unmarshalPublicKey)(this.peerId.publicKey);return await r.verify(t.subarray(),this.signature)}}BE.createFromProtobuf=async e=>{const t=xE.decode(e),r=await(0,Ht.y5)(t.publicKey);return new BE({peerId:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})},BE.seal=async(e,t)=>{if(null==t.privateKey)throw new Error("Missing private key");const r=e.domain,s=e.codec,n=e.marshal(),i=UE(r,s,n),o=await(0,dr.unmarshalPrivateKey)(t.privateKey),a=await o.sign(i.subarray());return new BE({peerId:t,payloadType:s,payload:n,signature:a})},BE.openAndCertify=async(e,t)=>{const r=await BE.createFromProtobuf(e),s=await r.validate(t);if(!s)throw h(new Error("envelope signature is not valid for the given domain"),LE.ERR_SIGNATURE_NOT_VALID);return r};const UE=(e,t,r)=>{const s=(0,ze.m)(e),n=ME.hG.encode(s.byteLength),i=ME.hG.encode(t.length),o=ME.hG.encode(r.length);return new ba.H(n,s,i,t,o,r)};function jE(e,t){const r=(e,t)=>e.toString().localeCompare(t.toString());return e.length===t.length&&(t.sort(r),e.sort(r).every(((e,r)=>t[r].equals(e))))}var VE;(function(e){let t,r;(function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.multiaddr)throw new Error('Protocol error: required field "multiaddr" was not found in object');t.uint32(10),t.bytes(e.multiaddr),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={multiaddr:new Uint8Array(0)},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.multiaddr=e.bytes();break;default:e.skipType(7&t);break}}if(null==r.multiaddr)throw new Error('Protocol error: value for required field "multiaddr" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(t=e.AddressInfo||(e.AddressInfo={})),e.codec=()=>(null==r&&(r=(0,Sr.yw)(((t,r,s={})=>{if(!1!==s.lengthDelimited&&r.fork(),null==t.peerId)throw new Error('Protocol error: required field "peerId" was not found in object');if(r.uint32(10),r.bytes(t.peerId),null==t.seq)throw new Error('Protocol error: required field "seq" was not found in object');if(r.uint32(16),r.uint64(t.seq),null==t.addresses)throw new Error('Protocol error: required field "addresses" was not found in object');for(const n of t.addresses)r.uint32(26),e.AddressInfo.codec().encode(n,r);!1!==s.lengthDelimited&&r.ldelim()}),((t,r)=>{const s={peerId:new Uint8Array(0),seq:0n,addresses:[]},n=null==r?t.len:t.pos+r;while(t.pos<n){const r=t.uint32();switch(r>>>3){case 1:s.peerId=t.bytes();break;case 2:s.seq=t.uint64();break;case 3:s.addresses.push(e.AddressInfo.codec().decode(t,t.uint32()));break;default:t.skipType(7&r);break}}if(null==s.peerId)throw new Error('Protocol error: value for required field "peerId" was not found in protobuf');if(null==s.seq)throw new Error('Protocol error: value for required field "seq" was not found in protobuf');return s}))),r),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(VE||(VE={}));const zE="libp2p-peer-record",FE=Uint8Array.from([3,1]);class $E{constructor(e){this.domain=$E.DOMAIN,this.codec=$E.CODEC;const{peerId:t,multiaddrs:r,seqNumber:s}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return null==this.marshaled&&(this.marshaled=VE.encode({peerId:this.peerId.toBytes(),seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map((e=>({multiaddr:e.bytes})))})),this.marshaled}equals(e){return e instanceof $E&&(!!this.peerId.equals(e.peerId)&&(this.seqNumber===e.seqNumber&&!!jE(this.multiaddrs,e.multiaddrs)))}}$E.createFromProtobuf=e=>{const t=VE.decode(e),r=(0,Ht.cv)(t.peerId),s=(t.addresses??[]).map((e=>(0,qe.HM)(e.multiaddr))),n=t.seq;return new $E({peerId:r,multiaddrs:s,seqNumber:n})},$E.DOMAIN=zE,$E.CODEC=FE;var KE=r(55305),HE=r(46857);class qE{constructor(e,t,r){this.gossip=e,this.msgs=new Map,this.history=[],this.msgIdToStrFn=r;for(let s=0;s<t;s++)this.history[s]=[]}get size(){return this.msgs.size}put(e,t,r=!1){const{msgIdStr:s}=e;return!this.msgs.has(s)&&(this.msgs.set(s,{message:t,validated:r,originatingPeers:new Set,iwantCounts:new Map}),this.history[0].push({...e,topic:t.topic}),!0)}observeDuplicate(e,t){const r=this.msgs.get(e);r&&!r.validated&&r.originatingPeers.add(t)}get(e){return this.msgs.get(this.msgIdToStrFn(e))?.message}getWithIWantCount(e,t){const r=this.msgs.get(e);if(!r)return null;const s=(r.iwantCounts.get(t)??0)+1;return r.iwantCounts.set(t,s),{msg:r.message,count:s}}getGossipIDs(e){const t=new Map;for(let r=0;r<this.gossip;r++)this.history[r].forEach((r=>{const s=this.msgs.get(r.msgIdStr);if(s&&s.validated&&e.has(r.topic)){let e=t.get(r.topic);e||(e=[],t.set(r.topic,e)),e.push(r.msgId)}}));return t}validate(e){const t=this.msgs.get(e);if(!t)return null;const{message:r,originatingPeers:s}=t;return t.validated=!0,t.originatingPeers=new Set,{message:r,originatingPeers:s}}shift(){const e=this.history[this.history.length-1];e.forEach((e=>{this.msgs.delete(e.msgIdStr)})),this.history.pop(),this.history.unshift([])}remove(e){const t=this.msgs.get(e);return t?(this.msgs.delete(e),t):null}}var GE=r(64482);const{RPC:WE}=GE,YE=1e3,QE=60*YE,ZE="/floodsub/1.0.0",XE="/meshsub/1.0.0",JE="/meshsub/1.1.0",ev=6,tv=4,rv=12,sv=4,nv=2,iv=5,ov=3,av=6,cv=.25,lv=3,uv=100,hv=YE,dv=QE,pv=16,fv=QE,yv=15,gv=300,mv=YE,wv=60,bv=2,_v=10*YE,Ev=5e3,vv=10,Sv=3*YE,Iv=2*QE,kv=12e4,Rv="ERR_TOPIC_VALIDATOR_REJECT",Tv="ERR_TOPIC_VALIDATOR_IGNORE",Av=0,Cv=128,Pv=1e3,Dv=1e3;function Nv(e=[],t){return{subscriptions:[],messages:e,control:t?{graft:t.graft||[],prune:t.prune||[],ihave:t.ihave||[],iwant:t.iwant||[]}:void 0}}function Ov(e){if(e.length<=1)return e;const t=()=>Math.floor(Math.random()*Math.floor(e.length));for(let r=0;r<e.length;r++){const s=t(),n=e[r];e[r]=e[s],e[s]=n}return e}function Lv(e){return(0,Ye.B)(e,"base64")}const xv="StrictSign",Mv="StrictNoSign";var Bv,Uv,jv,Vv,zv,Fv;function $v(e){switch(e){case jv.Ignore:return Vv.Ignore;case jv.Reject:return Vv.Reject}}async function Kv(e,t){switch(e){case xv:{if(!t)throw Error("Must provide PeerId");if(null==t.privateKey)throw Error("Cannot sign message, no private key present");if(null==t.publicKey)throw Error("Cannot sign message, no public key present");const e=await(0,dr.unmarshalPrivateKey)(t.privateKey);return{type:Uv.Signing,author:t,key:t.publicKey,privateKey:e}}case Mv:return{type:Uv.Anonymous};default:throw new Error(`Unknown signature policy "${e}"`)}}(function(e){e["StrictSign"]="StrictSign",e["StrictNoSign"]="StrictNoSign"})(Bv||(Bv={})),function(e){e[e["Signing"]=0]="Signing",e[e["Anonymous"]=1]="Anonymous"}(Uv||(Uv={})),function(e){e["Accept"]="accept",e["Ignore"]="ignore",e["Reject"]="reject"}(jv||(jv={})),function(e){e["Error"]="error",e["Ignore"]="ignore",e["Reject"]="reject",e["Blacklisted"]="blacklisted"}(Vv||(Vv={})),function(e){e["InvalidSignature"]="invalid_signature",e["InvalidSeqno"]="invalid_seqno",e["InvalidPeerId"]="invalid_peerid",e["SignaturePresent"]="signature_present",e["SeqnoPresent"]="seqno_present",e["FromPresent"]="from_present",e["TransformFailed"]="transform_failed"}(zv||(zv={})),function(e){e["duplicate"]="duplicate",e["invalid"]="invalid",e["valid"]="valid"}(Fv||(Fv={}));const Hv="ERR_INVALID_PEER_SCORE_PARAMS",qv={topics:{},topicScoreCap:10,appSpecificScore:()=>0,appSpecificWeight:10,IPColocationFactorWeight:-5,IPColocationFactorThreshold:10,IPColocationFactorWhitelist:new Set,behaviourPenaltyWeight:-10,behaviourPenaltyThreshold:0,behaviourPenaltyDecay:.2,decayInterval:1e3,decayToZero:.1,retainScore:36e5},Gv={topicWeight:.5,timeInMeshWeight:1,timeInMeshQuantum:1,timeInMeshCap:3600,firstMessageDeliveriesWeight:1,firstMessageDeliveriesDecay:.5,firstMessageDeliveriesCap:2e3,meshMessageDeliveriesWeight:-1,meshMessageDeliveriesDecay:.5,meshMessageDeliveriesCap:100,meshMessageDeliveriesThreshold:20,meshMessageDeliveriesWindow:10,meshMessageDeliveriesActivation:5e3,meshFailurePenaltyWeight:-1,meshFailurePenaltyDecay:.5,invalidMessageDeliveriesWeight:-1,invalidMessageDeliveriesDecay:.3};function Wv(e={}){return{...qv,...e,topics:e.topics?Object.entries(e.topics).reduce(((e,[t,r])=>(e[t]=Yv(r),e)),{}):{}}}function Yv(e={}){return{...Gv,...e}}function Qv(e){for(const[r,s]of Object.entries(e.topics))try{Zv(s)}catch(t){throw h(new Error(`invalid score parameters for topic ${r}: ${t.message}`),Hv)}if(e.topicScoreCap<0)throw h(new Error("invalid topic score cap; must be positive (or 0 for no cap)"),Hv);if(null===e.appSpecificScore||void 0===e.appSpecificScore)throw h(new Error("missing application specific score function"),Hv);if(e.IPColocationFactorWeight>0)throw h(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"),Hv);if(0!==e.IPColocationFactorWeight&&e.IPColocationFactorThreshold<1)throw h(new Error("invalid IPColocationFactorThreshold; must be at least 1"),Hv);if(e.behaviourPenaltyWeight>0)throw h(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"),Hv);if(0!==e.behaviourPenaltyWeight&&(e.behaviourPenaltyDecay<=0||e.behaviourPenaltyDecay>=1))throw h(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"),Hv);if(e.decayInterval<1e3)throw h(new Error("invalid DecayInterval; must be at least 1s"),Hv);if(e.decayToZero<=0||e.decayToZero>=1)throw h(new Error("invalid DecayToZero; must be between 0 and 1"),Hv)}function Zv(e){if(e.topicWeight<0)throw h(new Error("invalid topic weight; must be >= 0"),Hv);if(0===e.timeInMeshQuantum)throw h(new Error("invalid TimeInMeshQuantum; must be non zero"),Hv);if(e.timeInMeshWeight<0)throw h(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"),Hv);if(0!==e.timeInMeshWeight&&e.timeInMeshQuantum<=0)throw h(new Error("invalid TimeInMeshQuantum; must be positive"),Hv);if(0!==e.timeInMeshWeight&&e.timeInMeshCap<=0)throw h(new Error("invalid TimeInMeshCap; must be positive"),Hv);if(e.firstMessageDeliveriesWeight<0)throw h(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"),Hv);if(0!==e.firstMessageDeliveriesWeight&&(e.firstMessageDeliveriesDecay<=0||e.firstMessageDeliveriesDecay>=1))throw h(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"),Hv);if(0!==e.firstMessageDeliveriesWeight&&e.firstMessageDeliveriesCap<=0)throw h(new Error("invalid FirstMessageDeliveriesCap; must be positive"),Hv);if(e.meshMessageDeliveriesWeight>0)throw h(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"),Hv);if(0!==e.meshMessageDeliveriesWeight&&(e.meshMessageDeliveriesDecay<=0||e.meshMessageDeliveriesDecay>=1))throw h(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"),Hv);if(0!==e.meshMessageDeliveriesWeight&&e.meshMessageDeliveriesCap<=0)throw h(new Error("invalid MeshMessageDeliveriesCap; must be positive"),Hv);if(0!==e.meshMessageDeliveriesWeight&&e.meshMessageDeliveriesThreshold<=0)throw h(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"),Hv);if(e.meshMessageDeliveriesWindow<0)throw h(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"),Hv);if(0!==e.meshMessageDeliveriesWeight&&e.meshMessageDeliveriesActivation<1e3)throw h(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"),Hv);if(e.meshFailurePenaltyWeight>0)throw h(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"),Hv);if(0!==e.meshFailurePenaltyWeight&&(e.meshFailurePenaltyDecay<=0||e.meshFailurePenaltyDecay>=1))throw h(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"),Hv);if(e.invalidMessageDeliveriesWeight>0)throw h(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"),Hv);if(e.invalidMessageDeliveriesDecay<=0||e.invalidMessageDeliveriesDecay>=1)throw h(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"),Hv)}const Xv={gossipThreshold:-10,publishThreshold:-50,graylistThreshold:-80,acceptPXThreshold:10,opportunisticGraftThreshold:20};function Jv(e={}){return{...Xv,...e}}function eS(e,t,r,s){let n=0;Object.entries(t.topics).forEach((([e,t])=>{const s=r.topics[e];if(void 0===s)return;let i=0;if(t.inMesh){let e=t.meshTime/s.timeInMeshQuantum;e>s.timeInMeshCap&&(e=s.timeInMeshCap),i+=e*s.timeInMeshWeight}let o=t.firstMessageDeliveries;if(o>s.firstMessageDeliveriesCap&&(o=s.firstMessageDeliveriesCap),i+=o*s.firstMessageDeliveriesWeight,t.meshMessageDeliveriesActive&&t.meshMessageDeliveries<s.meshMessageDeliveriesThreshold){const e=s.meshMessageDeliveriesThreshold-t.meshMessageDeliveries,r=e*e;i+=r*s.meshMessageDeliveriesWeight}const a=t.meshFailurePenalty;i+=a*s.meshFailurePenaltyWeight;const c=t.invalidMessageDeliveries*t.invalidMessageDeliveries;i+=c*s.invalidMessageDeliveriesWeight,n+=i*s.topicWeight})),r.topicScoreCap>0&&n>r.topicScoreCap&&(n=r.topicScoreCap);const i=r.appSpecificScore(e);if(n+=i*r.appSpecificWeight,t.ips.forEach((e=>{if(r.IPColocationFactorWhitelist.has(e))return;const t=s.get(e),i=t?t.size:0;if(i>r.IPColocationFactorThreshold){const e=i-r.IPColocationFactorThreshold,t=e*e;n+=t*r.IPColocationFactorWeight}})),t.behaviourPenalty>r.behaviourPenaltyThreshold){const e=t.behaviourPenalty-r.behaviourPenaltyThreshold,s=e*e;n+=s*r.behaviourPenaltyWeight}return n}var tS,rS=r(45001);(function(e){e[e["unknown"]=0]="unknown",e[e["valid"]=1]="valid",e[e["invalid"]=2]="invalid",e[e["ignored"]=3]="ignored"})(tS||(tS={}));class sS{constructor(){this.records=new Map,this.queue=new rS}ensureRecord(e){let t=this.records.get(e);if(t)return t;t={status:tS.unknown,firstSeen:Date.now(),validated:0,peers:new Set},this.records.set(e,t);const r={msgId:e,expire:Date.now()+kv};return this.queue.push(r),t}gc(){const e=Date.now();let t=this.queue.peekFront();while(t&&t.expire<e)this.records.delete(t.msgId),this.queue.shift(),t=this.queue.peekFront()}clear(){this.records.clear(),this.queue.clear()}}var nS=r(6949);const iS=(0,u.kg)("libp2p:gossipsub:score");class oS{constructor(e,t,r){this.params=e,this.metrics=t,this.peerStats=new Map,this.peerIPs=new Map,this.scoreCache=new Map,this.deliveryRecords=new sS,this.components=new nS.z,Qv(e),this.scoreCacheValidityMs=r.scoreCacheValidityMs,this.computeScore=r.computeScore??eS}init(e){this.components=e}get size(){return this.peerStats.size}start(){this._backgroundInterval?iS("Peer score already running"):(this._backgroundInterval=setInterval((()=>this.background()),this.params.decayInterval),iS("started"))}stop(){this._backgroundInterval?(clearInterval(this._backgroundInterval),delete this._backgroundInterval,this.peerIPs.clear(),this.peerStats.clear(),this.deliveryRecords.clear(),iS("stopped")):iS("Peer score already stopped")}background(){this.refreshScores(),this.updateIPs(),this.deliveryRecords.gc()}dumpPeerScoreStats(){return Object.fromEntries(Array.from(this.peerStats.entries()).map((([e,t])=>[e,t])))}refreshScores(){const e=Date.now(),t=this.params.decayToZero;this.peerStats.forEach(((r,s)=>{r.connected?(Object.entries(r.topics).forEach((([r,s])=>{const n=this.params.topics[r];void 0!==n&&(s.firstMessageDeliveries*=n.firstMessageDeliveriesDecay,s.firstMessageDeliveries<t&&(s.firstMessageDeliveries=0),s.meshMessageDeliveries*=n.meshMessageDeliveriesDecay,s.meshMessageDeliveries<t&&(s.meshMessageDeliveries=0),s.meshFailurePenalty*=n.meshFailurePenaltyDecay,s.meshFailurePenalty<t&&(s.meshFailurePenalty=0),s.invalidMessageDeliveries*=n.invalidMessageDeliveriesDecay,s.invalidMessageDeliveries<t&&(s.invalidMessageDeliveries=0),s.inMesh&&(s.meshTime=e-s.graftTime,s.meshTime>n.meshMessageDeliveriesActivation&&(s.meshMessageDeliveriesActive=!0)))})),r.behaviourPenalty*=this.params.behaviourPenaltyDecay,r.behaviourPenalty<t&&(r.behaviourPenalty=0)):e>r.expire&&(this.removeIPs(s,r.ips),this.peerStats.delete(s),this.scoreCache.delete(s))}))}score(e){this.metrics?.scoreFnCalls.inc();const t=this.peerStats.get(e);if(!t)return 0;const r=Date.now(),s=this.scoreCache.get(e);if(s&&s.cacheUntil>r)return s.score;this.metrics?.scoreFnRuns.inc();const n=this.computeScore(e,t,this.params,this.peerIPs),i=r+this.scoreCacheValidityMs;return s?(this.metrics?.scoreCachedDelta.observe(Math.abs(n-s.score)),s.score=n,s.cacheUntil=i):this.scoreCache.set(e,{score:n,cacheUntil:i}),n}addPenalty(e,t,r){const s=this.peerStats.get(e);s&&(s.behaviourPenalty+=t,this.metrics?.onScorePenalty(r))}addPeer(e){const t={connected:!0,expire:0,topics:{},ips:[],behaviourPenalty:0};this.peerStats.set(e,t);const r=this.getIPs(e);this.setIPs(e,r,t.ips),t.ips=r}removePeer(e){const t=this.peerStats.get(e);if(t){if(this.score(e)>0)return this.removeIPs(e,t.ips),void this.peerStats.delete(e);Object.entries(t.topics).forEach((([e,t])=>{t.firstMessageDeliveries=0;const r=this.params.topics[e].meshMessageDeliveriesThreshold;if(t.inMesh&&t.meshMessageDeliveriesActive&&t.meshMessageDeliveries<r){const e=r-t.meshMessageDeliveries;t.meshFailurePenalty+=e*e}t.inMesh=!1,t.meshMessageDeliveriesActive=!1})),t.connected=!1,t.expire=Date.now()+this.params.retainScore}}graft(e,t){const r=this.peerStats.get(e);if(r){const e=this.getPtopicStats(r,t);e&&(e.inMesh=!0,e.graftTime=Date.now(),e.meshTime=0,e.meshMessageDeliveriesActive=!1)}}prune(e,t){const r=this.peerStats.get(e);if(r){const e=this.getPtopicStats(r,t);if(e){const r=this.params.topics[t].meshMessageDeliveriesThreshold;if(e.meshMessageDeliveriesActive&&e.meshMessageDeliveries<r){const t=r-e.meshMessageDeliveries;e.meshFailurePenalty+=t*t}e.meshMessageDeliveriesActive=!1,e.inMesh=!1}}}validateMessage(e){this.deliveryRecords.ensureRecord(e)}deliverMessage(e,t,r){this.markFirstMessageDelivery(e,r);const s=this.deliveryRecords.ensureRecord(t),n=Date.now();s.status===tS.unknown?(s.status=tS.valid,s.validated=n,s.peers.forEach((t=>{t!==e.toString()&&this.markDuplicateMessageDelivery(t,r)}))):iS("unexpected delivery: message from %s was first seen %s ago and has delivery status %s",e,n-s.firstSeen,tS[s.status])}rejectInvalidMessage(e,t){this.markInvalidMessageDelivery(e,t)}rejectMessage(e,t,r,s){switch(s){case Vv.Error:return void this.markInvalidMessageDelivery(e,r);case Vv.Blacklisted:return}const n=this.deliveryRecords.ensureRecord(t);if(n.status===tS.unknown){if(s===Vv.Ignore)return n.status=tS.ignored,void n.peers.clear();n.status=tS.invalid,this.markInvalidMessageDelivery(e,r),n.peers.forEach((e=>{this.markInvalidMessageDelivery(e,r)})),n.peers.clear()}else iS("unexpected rejection: message from %s was first seen %s ago and has delivery status %d",e,Date.now()-n.firstSeen,tS[n.status])}duplicateMessage(e,t,r){const s=this.deliveryRecords.ensureRecord(t);if(!s.peers.has(e))switch(s.status){case tS.unknown:s.peers.add(e);break;case tS.valid:s.peers.add(e),this.markDuplicateMessageDelivery(e,r,s.validated);break;case tS.invalid:this.markInvalidMessageDelivery(e,r);break;case tS.ignored:break}}markInvalidMessageDelivery(e,t){const r=this.peerStats.get(e);if(r){const e=this.getPtopicStats(r,t);e&&(e.invalidMessageDeliveries+=1)}}markFirstMessageDelivery(e,t){const r=this.peerStats.get(e);if(r){const e=this.getPtopicStats(r,t);if(e){let r=this.params.topics[t].firstMessageDeliveriesCap;e.firstMessageDeliveries=Math.min(r,e.firstMessageDeliveries+1),e.inMesh&&(r=this.params.topics[t].meshMessageDeliveriesCap,e.meshMessageDeliveries=Math.min(r,e.meshMessageDeliveries+1))}}}markDuplicateMessageDelivery(e,t,r){const s=this.peerStats.get(e);if(s){const e=void 0!==r?Date.now():0,n=this.getPtopicStats(s,t);if(n&&n.inMesh){const s=this.params.topics[t];if(void 0!==r){const n=e-r,i=n>s.meshMessageDeliveriesWindow;if(this.metrics?.onDuplicateMsgDelivery(t,n,i),i)return}const i=s.meshMessageDeliveriesCap;n.meshMessageDeliveries=Math.min(i,n.meshMessageDeliveries+1)}}}getIPs(e){return this.components.getConnectionManager().getConnections((0,Ht.jE)(e)).map((e=>e.remoteAddr.toOptions().host))}setIPs(e,t,r){e:for(const s of t){for(const e of r)if(s===e)continue e;let t=this.peerIPs.get(s);t||(t=new Set,this.peerIPs.set(s,t)),t.add(e)}e:for(const s of r){for(const e of t)if(s===e)continue e;const r=this.peerIPs.get(s);r&&(r.delete(e),r.size||this.peerIPs.delete(s))}}removeIPs(e,t){t.forEach((t=>{const r=this.peerIPs.get(t);r&&(r.delete(e),r.size||this.peerIPs.delete(t))}))}updateIPs(){this.peerStats.forEach(((e,t)=>{const r=this.getIPs(t);this.setIPs(t,r,e.ips),e.ips=r}))}getPtopicStats(e,t){let r=e.topics[t];return void 0!==r?r:void 0!==this.params.topics[t]?(r={inMesh:!1,graftTime:0,meshTime:0,firstMessageDeliveries:0,meshMessageDeliveries:0,meshMessageDeliveriesActive:!1,meshFailurePenalty:0,invalidMessageDeliveries:0},e.topics[t]=r,r):null}}class aS{constructor(e,t,r){this.gossipsubIWantFollowupMs=e,this.msgIdToStrFn=t,this.metrics=r,this.promises=new Map,this.requestMsByMsg=new Map,this.requestMsByMsgExpire=10*e}get size(){return this.promises.size}get requestMsByMsgSize(){return this.requestMsByMsg.size}addPromise(e,t){const r=Math.floor(Math.random()*t.length),s=t[r],n=this.msgIdToStrFn(s);let i=this.promises.get(n);i||(i=new Map,this.promises.set(n,i));const o=Date.now();i.has(e)||(i.set(e,o+this.gossipsubIWantFollowupMs),this.metrics&&(this.metrics.iwantPromiseStarted.inc(1),this.requestMsByMsg.has(n)||this.requestMsByMsg.set(n,o)))}getBrokenPromises(){const e=Date.now(),t=new Map;let r=0;return this.promises.forEach(((s,n)=>{s.forEach(((n,i)=>{n<e&&(t.set(i,(t.get(i)??0)+1),s.delete(i),r++)})),s.size||this.promises.delete(n)})),this.metrics?.iwantPromiseBroken.inc(r),t}deliverMessage(e){this.trackMessage(e);const t=this.promises.get(e);t&&(this.promises.delete(e),this.metrics&&(this.metrics.iwantPromiseResolved.inc(1),this.metrics.iwantPromiseResolvedPeers.inc(t.size)))}rejectMessage(e,t){switch(this.trackMessage(e),t){case Vv.Error:return}this.promises.delete(e)}clear(){this.promises.clear()}prune(){const e=Date.now()-this.requestMsByMsgExpire;for(const[t,r]of this.requestMsByMsg.entries()){if(!(r<e))break;this.requestMsByMsg.delete(t)}}trackMessage(e){if(this.metrics){const t=this.requestMsByMsg.get(e);void 0!==t&&(this.metrics.iwantPromiseDeliveryTime.observe((Date.now()-t)/1e3),this.requestMsByMsg.delete(e))}}}class cS{constructor(e){this.entries=new Map,this.validityMs=e.validityMs}get size(){return this.entries.size}put(e,t){this.entries.set(e,{value:t,validUntilMs:Date.now()+this.validityMs})}prune(){const e=Date.now();for(const[t,r]of this.entries.entries()){if(!(r.validUntilMs<e))break;this.entries.delete(t)}}has(e){return this.entries.has(e)}get(e){const t=this.entries.get(e);return t&&t.validUntilMs>=Date.now()?t.value:void 0}clear(){this.entries.clear()}}var lS,uS,hS,dS,pS,fS;function yS(e,t,r){return{protocolsEnabled:e.gauge({name:"gossipsub_protocol",help:"Status of enabled protocols",labelNames:["protocol"]}),topicSubscriptionStatus:e.gauge({name:"gossipsub_topic_subscription_status",help:"Status of our subscription to this topic",labelNames:["topicStr"]}),topicPeersCount:e.gauge({name:"gossipsub_topic_peer_count",help:"Number of peers subscribed to each topic",labelNames:["topicStr"]}),meshPeerCounts:e.gauge({name:"gossipsub_mesh_peer_count",help:"Number of peers in our mesh",labelNames:["topicStr"]}),meshPeerInclusionEvents:e.gauge({name:"gossipsub_mesh_peer_inclusion_events_total",help:"Number of times we include peers in a topic mesh for different reasons",labelNames:["topic","reason"]}),meshPeerChurnEvents:e.gauge({name:"gossipsub_peer_churn_events_total",help:"Number of times we remove peers in a topic mesh for different reasons",labelNames:["topic","reason"]}),peersPerProtocol:e.gauge({name:"gossipsub_peers_per_protocol_count",help:"Peers connected for each topic",labelNames:["protocol"]}),heartbeatDuration:e.histogram({name:"gossipsub_heartbeat_duration_seconds",help:"The time it takes to complete one iteration of the heartbeat",buckets:[.01,.1,1]}),heartbeatSkipped:e.gauge({name:"gossipsub_heartbeat_skipped",help:"Heartbeat run took longer than heartbeat interval so next is skipped"}),asyncValidationResult:e.gauge({name:"gossipsub_async_validation_result_total",help:"Message validation result for each topic",labelNames:["topic","acceptance"]}),asyncValidationMcacheHit:e.gauge({name:"gossipsub_async_validation_mcache_hit_total",help:"Async validation result reported by the user layer",labelNames:["hit"]}),rpcRecvBytes:e.gauge({name:"gossipsub_rpc_recv_bytes_total",help:"RPC recv"}),rpcRecvCount:e.gauge({name:"gossipsub_rpc_recv_count_total",help:"RPC recv"}),rpcRecvSubscription:e.gauge({name:"gossipsub_rpc_recv_subscription_total",help:"RPC recv"}),rpcRecvMessage:e.gauge({name:"gossipsub_rpc_recv_message_total",help:"RPC recv"}),rpcRecvControl:e.gauge({name:"gossipsub_rpc_recv_control_total",help:"RPC recv"}),rpcRecvIHave:e.gauge({name:"gossipsub_rpc_recv_ihave_total",help:"RPC recv"}),rpcRecvIWant:e.gauge({name:"gossipsub_rpc_recv_iwant_total",help:"RPC recv"}),rpcRecvGraft:e.gauge({name:"gossipsub_rpc_recv_graft_total",help:"RPC recv"}),rpcRecvPrune:e.gauge({name:"gossipsub_rpc_recv_prune_total",help:"RPC recv"}),rpcRecvNotAccepted:e.gauge({name:"gossipsub_rpc_rcv_not_accepted_total",help:"Total count of RPC dropped because acceptFrom() == false"}),rpcSentBytes:e.gauge({name:"gossipsub_rpc_sent_bytes_total",help:"RPC sent"}),rpcSentCount:e.gauge({name:"gossipsub_rpc_sent_count_total",help:"RPC sent"}),rpcSentSubscription:e.gauge({name:"gossipsub_rpc_sent_subscription_total",help:"RPC sent"}),rpcSentMessage:e.gauge({name:"gossipsub_rpc_sent_message_total",help:"RPC sent"}),rpcSentControl:e.gauge({name:"gossipsub_rpc_sent_control_total",help:"RPC sent"}),rpcSentIHave:e.gauge({name:"gossipsub_rpc_sent_ihave_total",help:"RPC sent"}),rpcSentIWant:e.gauge({name:"gossipsub_rpc_sent_iwant_total",help:"RPC sent"}),rpcSentGraft:e.gauge({name:"gossipsub_rpc_sent_graft_total",help:"RPC sent"}),rpcSentPrune:e.gauge({name:"gossipsub_rpc_sent_prune_total",help:"RPC sent"}),msgPublishCount:e.gauge({name:"gossipsub_msg_publish_count_total",help:"Total count of msg published by topic",labelNames:["topic"]}),msgPublishPeers:e.gauge({name:"gossipsub_msg_publish_peers_total",help:"Total count of peers that we publish a msg to",labelNames:["topic"]}),msgPublishPeersByGroup:e.gauge({name:"gossipsub_msg_publish_peers_by_group",help:"Total count of peers (by group) that we publish a msg to",labelNames:["topic","peerGroup"]}),msgPublishBytes:e.gauge({name:"gossipsub_msg_publish_bytes_total",help:"Total count of msg publish data.length bytes",labelNames:["topic"]}),msgForwardCount:e.gauge({name:"gossipsub_msg_forward_count_total",help:"Total count of msg forwarded by topic",labelNames:["topic"]}),msgForwardPeers:e.gauge({name:"gossipsub_msg_forward_peers_total",help:"Total count of peers that we forward a msg to",labelNames:["topic"]}),msgReceivedPreValidation:e.gauge({name:"gossipsub_msg_received_prevalidation_total",help:"Total count of recv msgs before any validation",labelNames:["topic"]}),msgReceivedStatus:e.gauge({name:"gossipsub_msg_received_status_total",help:"Tracks distribution of recv msgs by duplicate, invalid, valid",labelNames:["topic","status"]}),msgReceivedInvalid:e.gauge({name:"gossipsub_msg_received_invalid_total",help:"Tracks specific reason of invalid",labelNames:["topic","error"]}),duplicateMsgDeliveryDelay:e.histogram({name:"gossisub_duplicate_msg_delivery_delay_seconds",help:"Time since the 1st duplicated message validated",labelNames:["topic"],buckets:[.25*r.maxMeshMessageDeliveriesWindowSec,.5*r.maxMeshMessageDeliveriesWindowSec,1*r.maxMeshMessageDeliveriesWindowSec,2*r.maxMeshMessageDeliveriesWindowSec,4*r.maxMeshMessageDeliveriesWindowSec]}),duplicateMsgLateDelivery:e.gauge({name:"gossisub_duplicate_msg_late_delivery_total",help:"Total count of late duplicate message delivery by topic, which triggers P3 penalty",labelNames:["topic"]}),scoreFnCalls:e.gauge({name:"gossipsub_score_fn_calls_total",help:"Total times score() is called"}),scoreFnRuns:e.gauge({name:"gossipsub_score_fn_runs_total",help:"Total times score() call actually computed computeScore(), no cache"}),scoreCachedDelta:e.histogram({name:"gossipsub_score_cache_delta",help:"Delta of score between cached values that expired",buckets:[10,100,1e3]}),peersByScoreThreshold:e.gauge({name:"gossipsub_peers_by_score_threshold_count",help:"Current count of peers by score threshold",labelNames:["threshold"]}),score:e.avgMinMax({name:"gossipsub_score",help:"Avg min max of gossip scores",labelNames:["topic","p"]}),scoreWeights:e.avgMinMax({name:"gossipsub_score_weights",help:"Separate score weights",labelNames:["topic","p"]}),scorePerMesh:e.avgMinMax({name:"gossipsub_score_per_mesh",help:"Histogram of the scores for each mesh topic",labelNames:["topic"]}),scoringPenalties:e.gauge({name:"gossipsub_scoring_penalties_total",help:"A counter of the kind of penalties being applied to peers",labelNames:["penalty"]}),behaviourPenalty:e.histogram({name:"gossipsub_peer_stat_behaviour_penalty",help:"Current peer stat behaviour_penalty at each scrape",buckets:[.25*r.behaviourPenaltyThreshold,.5*r.behaviourPenaltyThreshold,1*r.behaviourPenaltyThreshold,2*r.behaviourPenaltyThreshold,4*r.behaviourPenaltyThreshold]}),ihaveRcvIgnored:e.gauge({name:"gossipsub_ihave_rcv_ignored_total",help:"Total received IHAVE messages that we ignore for some reason",labelNames:["reason"]}),ihaveRcvMsgids:e.gauge({name:"gossipsub_ihave_rcv_msgids_total",help:"Total received IHAVE messages by topic",labelNames:["topic"]}),ihaveRcvNotSeenMsgids:e.gauge({name:"gossipsub_ihave_rcv_not_seen_msgids_total",help:"Total messages per topic we do not have, not actual requests",labelNames:["topic"]}),iwantRcvMsgids:e.gauge({name:"gossipsub_iwant_rcv_msgids_total",help:"Total received IWANT messages by topic",labelNames:["topic"]}),iwantRcvDonthaveMsgids:e.gauge({name:"gossipsub_iwant_rcv_dont_have_msgids_total",help:"Total requested messageIDs that we do not have"}),iwantPromiseStarted:e.gauge({name:"gossipsub_iwant_promise_sent_total",help:"Total count of started IWANT promises"}),iwantPromiseResolved:e.gauge({name:"gossipsub_iwant_promise_resolved_total",help:"Total count of resolved IWANT promises"}),iwantPromiseResolvedPeers:e.gauge({name:"gossipsub_iwant_promise_resolved_peers",help:"Total count of peers we have asked IWANT promises that are resolved"}),iwantPromiseBroken:e.gauge({name:"gossipsub_iwant_promise_broken",help:"Total count of broken IWANT promises"}),iwantPromiseDeliveryTime:e.histogram({name:"gossipsub_iwant_promise_delivery_seconds",help:"Histogram of delivery time of resolved IWANT promises",buckets:[.5*r.gossipPromiseExpireSec,1*r.gossipPromiseExpireSec,2*r.gossipPromiseExpireSec,4*r.gossipPromiseExpireSec]}),cacheSize:e.gauge({name:"gossipsub_cache_size",help:"Unbounded cache sizes",labelNames:["cache"]}),mcacheSize:e.gauge({name:"gossipsub_mcache_size",help:"Current mcache msg count"}),topicStrToLabel:t,toTopic(e){return this.topicStrToLabel.get(e)??e},onJoin(e){this.topicSubscriptionStatus.set({topicStr:e},1),this.meshPeerCounts.set({topicStr:e},0)},onLeave(e){this.topicSubscriptionStatus.set({topicStr:e},0),this.meshPeerCounts.set({topicStr:e},0)},onAddToMesh(e,t,r){const s=this.toTopic(e);this.meshPeerInclusionEvents.inc({topic:s,reason:t},r)},onRemoveFromMesh(e,t,r){const s=this.toTopic(e);this.meshPeerChurnEvents.inc({topic:s,reason:t},r)},onReportValidationMcacheHit(e){this.asyncValidationMcacheHit.inc({hit:e?"hit":"miss"})},onReportValidation(e,t){const r=this.toTopic(e);this.asyncValidationResult.inc({topic:r,acceptance:t})},onScorePenalty(e){this.scoringPenalties.inc({penalty:e},1)},onIhaveRcv(e,t,r){const s=this.toTopic(e);this.ihaveRcvMsgids.inc({topic:s},t),this.ihaveRcvNotSeenMsgids.inc({topic:s},r)},onIwantRcv(e,t){for(const[r,s]of e){const e=this.toTopic(r);this.iwantRcvMsgids.inc({topic:e},s)}this.iwantRcvDonthaveMsgids.inc(t)},onForwardMsg(e,t){const r=this.toTopic(e);this.msgForwardCount.inc({topic:r},1),this.msgForwardPeers.inc({topic:r},t)},onPublishMsg(e,t,r,s){const n=this.toTopic(e);this.msgPublishCount.inc({topic:n},1),this.msgPublishBytes.inc({topic:n},r*s),this.msgPublishPeers.inc({topic:n},r),this.msgPublishPeersByGroup.inc({topic:n,peerGroup:"direct"},t.direct),this.msgPublishPeersByGroup.inc({topic:n,peerGroup:"floodsub"},t.floodsub),this.msgPublishPeersByGroup.inc({topic:n,peerGroup:"mesh"},t.mesh),this.msgPublishPeersByGroup.inc({topic:n,peerGroup:"fanout"},t.fanout)},onMsgRecvPreValidation(e){const t=this.toTopic(e);this.msgReceivedPreValidation.inc({topic:t},1)},onMsgRecvResult(e,t){const r=this.toTopic(e);this.msgReceivedStatus.inc({topic:r,status:t})},onMsgRecvInvalid(e,t){const r=this.toTopic(e),s=t.reason===Vv.Error?t.error:t.reason;this.msgReceivedInvalid.inc({topic:r,error:s},1)},onDuplicateMsgDelivery(e,t,r){if(this.duplicateMsgDeliveryDelay.observe(t/1e3),r){const t=this.toTopic(e);this.duplicateMsgLateDelivery.inc({topic:t},1)}},onRpcRecv(e,t){this.rpcRecvBytes.inc(t),this.rpcRecvCount.inc(1),e.subscriptions&&this.rpcRecvSubscription.inc(e.subscriptions.length),e.messages&&this.rpcRecvMessage.inc(e.messages.length),e.control&&(this.rpcRecvControl.inc(1),e.control.ihave&&this.rpcRecvIHave.inc(e.control.ihave.length),e.control.iwant&&this.rpcRecvIWant.inc(e.control.iwant.length),e.control.graft&&this.rpcRecvGraft.inc(e.control.graft.length),e.control.prune&&this.rpcRecvPrune.inc(e.control.prune.length))},onRpcSent(e,t){if(this.rpcSentBytes.inc(t),this.rpcSentCount.inc(1),e.subscriptions&&this.rpcSentSubscription.inc(e.subscriptions.length),e.messages&&this.rpcSentMessage.inc(e.messages.length),e.control){const t=e.control.ihave?.length??0,r=e.control.iwant?.length??0,s=e.control.graft?.length??0,n=e.control.prune?.length??0;t>0&&this.rpcSentIHave.inc(t),r>0&&this.rpcSentIWant.inc(r),s>0&&this.rpcSentGraft.inc(s),n>0&&this.rpcSentPrune.inc(n),(t>0||r>0||s>0||n>0)&&this.rpcSentControl.inc(1)}},registerScores(e,t){let r=0,s=0,n=0,i=0;for(const o of e)o>=t.graylistThreshold&&r++,o>=t.publishThreshold&&s++,o>=t.gossipThreshold&&n++,o>=0&&i++;this.peersByScoreThreshold.set({threshold:fS.graylist},r),this.peersByScoreThreshold.set({threshold:fS.publish},s),this.peersByScoreThreshold.set({threshold:fS.gossip},n),this.peersByScoreThreshold.set({threshold:fS.mesh},i),this.score.set(e)},registerScoreWeights(e){for(const[t,r]of e.byTopic)this.scoreWeights.set({topic:t,p:"p1"},r.p1w),this.scoreWeights.set({topic:t,p:"p2"},r.p2w),this.scoreWeights.set({topic:t,p:"p3"},r.p3w),this.scoreWeights.set({topic:t,p:"p3b"},r.p3bw),this.scoreWeights.set({topic:t,p:"p4"},r.p4w);this.scoreWeights.set({p:"p5"},e.p5w),this.scoreWeights.set({p:"p6"},e.p6w),this.scoreWeights.set({p:"p7"},e.p7w)},registerScorePerMesh(e,t){const r=new Map;e.forEach(((e,t)=>{const s=this.topicStrToLabel.get(t)??"unknown";let n=r.get(s);n||(n=new Set,r.set(s,n)),e.forEach((e=>n?.add(e)))}));for(const[s,n]of r){const e=[];n.forEach((r=>{e.push(t.get(r)??0)})),this.scorePerMesh.set({topic:s},e)}}}}(function(e){e["forward"]="forward",e["publish"]="publish"})(lS||(lS={})),function(e){e["Fanout"]="fanout",e["Random"]="random",e["Subscribed"]="subscribed",e["Outbound"]="outbound",e["NotEnough"]="not_enough",e["Opportunistic"]="opportunistic"}(uS||(uS={})),function(e){e["Dc"]="disconnected",e["BadScore"]="bad_score",e["Prune"]="prune",e["Unsub"]="unsubscribed",e["Excess"]="excess"}(hS||(hS={})),function(e){e["GraftBackoff"]="graft_backoff",e["BrokenPromise"]="broken_promise",e["MessageDeficit"]="message_deficit",e["IPColocation"]="IP_colocation"}(dS||(dS={})),function(e){e["LowScore"]="low_score",e["MaxIhave"]="max_ihave",e["MaxIasked"]="max_iasked"}(pS||(pS={})),function(e){e["graylist"]="graylist",e["publish"]="publish",e["gossip"]="gossip",e["mesh"]="mesh"}(fS||(fS={}));var gS=r(23914);const mS=(0,ze.m)("libp2p-pubsub:");async function wS(e,t,r,s){switch(e.type){case Uv.Signing:{const n={from:e.author.toBytes(),data:s,seqno:(0,gS.O6)(8),topic:t,signature:void 0,key:void 0},i=(0,Ir.concat)([mS,WE.Message.encode(n).finish()]);n.signature=await e.privateKey.sign(i),n.key=e.key;const o={type:"signed",from:e.author,data:r,sequenceNumber:BigInt(`0x${(0,Ye.B)(n.seqno,"base16")}`),topic:t,signature:n.signature,key:n.key};return{raw:n,msg:o}}case Uv.Anonymous:return{raw:{from:void 0,data:s,seqno:void 0,topic:t,signature:void 0,key:void 0},msg:{type:"unsigned",data:r,topic:t}}}}async function bS(e,t){switch(e){case Mv:return null!=t.signature?{valid:!1,error:zv.SignaturePresent}:null!=t.seqno?{valid:!1,error:zv.SeqnoPresent}:null!=t.key?{valid:!1,error:zv.FromPresent}:{valid:!0,message:{type:"unsigned",topic:t.topic,data:t.data??new Uint8Array(0)}};case xv:{if(null==t.seqno)return{valid:!1,error:zv.InvalidSeqno};if(8!==t.seqno.length)return{valid:!1,error:zv.InvalidSeqno};if(null==t.signature)return{valid:!1,error:zv.InvalidSignature};if(null==t.from)return{valid:!1,error:zv.InvalidPeerId};let e,s;try{e=(0,Ht.cv)(t.from)}catch(r){return{valid:!1,error:zv.InvalidPeerId}}if(t.key){if(s=(0,dr.unmarshalPublicKey)(t.key),void 0!==e.publicKey&&!(0,ur.f)(s.bytes,e.publicKey))return{valid:!1,error:zv.InvalidPeerId}}else{if(null==e.publicKey)return{valid:!1,error:zv.InvalidPeerId};s=(0,dr.unmarshalPublicKey)(e.publicKey)}const n={from:t.from,data:t.data,seqno:t.seqno,topic:t.topic,signature:void 0,key:void 0},i=(0,Ir.concat)([mS,WE.Message.encode(n).finish()]);return await s.verify(i,t.signature)?{valid:!0,message:{type:"signed",from:e,data:t.data??new Uint8Array(0),sequenceNumber:BigInt(`0x${(0,Ye.B)(t.seqno,"base16")}`),topic:t.topic,signature:t.signature,key:t.key??(0,dr.marshalPublicKey)(s)}}:{valid:!1,error:zv.InvalidSignature}}}}const _S=(e,t)=>{const r=(0,ze.m)(t.toString(16).padStart(16,"0"),"base16"),s=new Uint8Array(e.length+r.length);return s.set(e,0),s.set(r,e.length),s};function ES(e){if("signed"!==e.type)throw new Error("expected signed message type");if(null==e.sequenceNumber)throw Error("missing seqno field");return _S(e.from.toBytes(),e.sequenceNumber)}async function vS(e){return await ti.sha256.encode(e.data)}function SS(e,t,r,s,n){let i=0;const o=new Map;if(Object.entries(t.topics).forEach((([e,t])=>{const s=n.get(e)??"unknown",a=r.topics[e];if(void 0===a)return;let c=o.get(s);c||(c={p1w:0,p2w:0,p3w:0,p3bw:0,p4w:0},o.set(s,c));let l=0,u=0,h=0,d=0,p=0;if(t.inMesh){const e=Math.max(t.meshTime/a.timeInMeshQuantum,a.timeInMeshCap);l+=e*a.timeInMeshWeight}let f=t.firstMessageDeliveries;if(f>a.firstMessageDeliveriesCap&&(f=a.firstMessageDeliveriesCap),u+=f*a.firstMessageDeliveriesWeight,t.meshMessageDeliveriesActive&&t.meshMessageDeliveries<a.meshMessageDeliveriesThreshold){const e=a.meshMessageDeliveriesThreshold-t.meshMessageDeliveries,r=e*e;h+=r*a.meshMessageDeliveriesWeight}const y=t.meshFailurePenalty;d+=y*a.meshFailurePenaltyWeight;const g=t.invalidMessageDeliveries*t.invalidMessageDeliveries;p+=g*a.invalidMessageDeliveriesWeight,i+=(l+u+h+d+p)*a.topicWeight,c.p1w+=l,c.p2w+=u,c.p3w+=h,c.p3bw+=d,c.p4w+=p})),r.topicScoreCap>0&&i>r.topicScoreCap){i=r.topicScoreCap;const e=r.topicScoreCap/i;for(const t of o.values())t.p1w*=e,t.p2w*=e,t.p3w*=e,t.p3bw*=e,t.p4w*=e}let a=0,c=0,l=0;const u=r.appSpecificScore(e);a+=u*r.appSpecificWeight,t.ips.forEach((e=>{if(r.IPColocationFactorWhitelist.has(e))return;const t=s.get(e),n=t?t.size:0;if(n>r.IPColocationFactorThreshold){const e=n-r.IPColocationFactorThreshold,t=e*e;c+=t*r.IPColocationFactorWeight}}));const h=t.behaviourPenalty*t.behaviourPenalty;return l+=h*r.behaviourPenaltyWeight,i+=a+c+l,{byTopic:o,p5w:a,p6w:c,p7w:l,score:i}}function IS(e,t,r,s,n){const i={byTopic:new Map,p5w:[],p6w:[],p7w:[],score:[]};for(const o of e){const e=t.get(o);if(e){const t=SS(o,e,r,s,n);for(const[e,r]of t.byTopic){let t=i.byTopic.get(e);t||(t={p1w:[],p2w:[],p3w:[],p3bw:[],p4w:[]},i.byTopic.set(e,t)),t.p1w.push(r.p1w),t.p2w.push(r.p2w),t.p3w.push(r.p3w),t.p3bw.push(r.p3bw),t.p4w.push(r.p4w)}i.p5w.push(t.p5w),i.p6w.push(t.p6w),i.p7w.push(t.p7w),i.score.push(t.score)}else i.p5w.push(0),i.p6w.push(0),i.p7w.push(0),i.score.push(0)}return i}function kS(e,t,r=(()=>!0)){const s=new Set;if(t<=0)return s;for(const n of e){if(s.size>=t)break;r(n)&&(s.add(n),e.delete(n))}return s}function RS(e,t){return kS(e,t,(()=>!0))}class TS extends Error{constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}}function AS(e){if(null!=e){if("function"===typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"===typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"===typeof e.next)return e}throw new Error("argument is not an iterator or iterable")}function CS(e,t,r){const s=r??{},n=AS(e);async function*i(){let r;const i=()=>{null!=r&&r()};t.addEventListener("abort",i);while(1){let o;try{if(t.aborted){const{abortMessage:e,abortCode:t}=s;throw new TS(e,t)}const e=new Promise(((e,t)=>{r=()=>{const{abortMessage:e,abortCode:r}=s;t(new TS(e,r))}}));o=await Promise.race([e,n.next()]),r=null}catch(mu){t.removeEventListener("abort",i);const o="aborted"===mu.type&&t.aborted;if(o&&null!=s.onAbort&&await s.onAbort(e),"function"===typeof n.return)try{const e=n.return();e instanceof Promise&&e.catch((e=>{null!=s.onReturnError&&s.onReturnError(e)}))}catch(mu){null!=s.onReturnError&&s.onReturnError(mu)}if(o&&!0===s.returnOnAbort)return;throw mu}if(!0===o.done)break;yield o.value}t.removeEventListener("abort",i)}return i()}var PS=r(83898);class DS{constructor(e,t,r){this.rawStream=e,this.pushable=(0,_s.d)({objectMode:!1}),this.closeController=new AbortController,this.maxBufferSize=r.maxBufferSize??1/0,(0,Cs.zG)(CS(this.pushable,this.closeController.signal,{returnOnAbort:!0}),(0,PS.c)(),this.rawStream).catch(t)}get protocol(){return this.rawStream.stat.protocol}push(e){if(this.pushable.readableLength>this.maxBufferSize)throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);this.pushable.push(e)}close(){this.closeController.abort(),this.pushable.return(),this.rawStream.close()}}class NS{constructor(e){this.rawStream=e,this.closeController=new AbortController,this.source=CS((0,Cs.zG)(this.rawStream,(0,PS.J)()),this.closeController.signal,{returnOnAbort:!0})}close(){this.closeController.abort(),this.rawStream.close()}}var OS;(function(e){e[e["started"]=0]="started",e[e["stopped"]=1]="stopped"})(OS||(OS={}));class LS extends HE.v{constructor(e={}){super(),this.multicodecs=[JE,XE],this.peers=new Set,this.streamsInbound=new Map,this.streamsOutbound=new Map,this.outboundInflightQueue=(0,_s.d)({objectMode:!0}),this.direct=new Set,this.floodsubPeers=new Set,this.acceptFromWhitelist=new Map,this.topics=new Map,this.subscriptions=new Set,this.mesh=new Map,this.fanout=new Map,this.fanoutLastpub=new Map,this.gossip=new Map,this.control=new Map,this.peerhave=new Map,this.iasked=new Map,this.backoff=new Map,this.outbound=new Map,this.topicValidators=new Map,this.heartbeatTicks=0,this.components=new nS.z,this.directPeerInitial=null,this.status={code:OS.stopped},this.heartbeatTimer=null,this.runHeartbeat=()=>{const e=this.metrics?.heartbeatDuration.startTimer();this.heartbeat().catch((e=>{this.log("Error running heartbeat",e)})).finally((()=>{if(null!=e&&e(),this.status.code===OS.started){clearTimeout(this.status.heartbeatTimeout);let e=this.opts.heartbeatInterval-(Date.now()-this.status.hearbeatStartMs)%this.opts.heartbeatInterval;e<.25*this.opts.heartbeatInterval&&(e+=this.opts.heartbeatInterval,this.metrics?.heartbeatSkipped.inc()),this.status.heartbeatTimeout=setTimeout(this.runHeartbeat,e)}}))};const t={fallbackToFloodsub:!0,floodPublish:!0,doPX:!1,directPeers:[],D:ev,Dlo:tv,Dhi:rv,Dscore:sv,Dout:nv,Dlazy:av,heartbeatInterval:hv,fanoutTTL:dv,mcacheLength:iv,mcacheGossip:ov,seenTTL:Iv,gossipsubIWantFollowupMs:Sv,prunePeers:pv,pruneBackoff:fv,graftFloodThreshold:_v,opportunisticGraftPeers:bv,opportunisticGraftTicks:wv,directConnectTicks:gv,...e,scoreParams:Wv(e.scoreParams),scoreThresholds:Jv(e.scoreThresholds)};if(this.globalSignaturePolicy=t.globalSignaturePolicy??xv,t.fallbackToFloodsub&&this.multicodecs.push(ZE),this.log=(0,u.kg)(t.debugName??"libp2p:gossipsub"),this.opts=t,this.direct=new Set(t.directPeers.map((e=>e.id.toString()))),this.seenCache=new cS({validityMs:t.seenTTL}),this.publishedMessageIds=new cS({validityMs:t.seenTTL}),e.msgIdFn)this.msgIdFn=e.msgIdFn;else switch(this.globalSignaturePolicy){case xv:this.msgIdFn=ES;break;case Mv:this.msgIdFn=vS;break}if(e.fastMsgIdFn&&(this.fastMsgIdFn=e.fastMsgIdFn,this.fastMsgIdCache=new cS({validityMs:t.seenTTL})),this.msgIdToStrFn=e.msgIdToStrFn??Lv,this.mcache=e.messageCache||new qE(t.mcacheGossip,t.mcacheLength,this.msgIdToStrFn),e.dataTransform&&(this.dataTransform=e.dataTransform),e.metricsRegister){if(!e.metricsTopicStrToLabel)throw Error("Must set metricsTopicStrToLabel with metrics");const r=Math.max(...Object.values(t.scoreParams.topics).map((e=>e.meshMessageDeliveriesWindow)),Dv),s=yS(e.metricsRegister,e.metricsTopicStrToLabel,{gossipPromiseExpireSec:this.opts.gossipsubIWantFollowupMs/1e3,behaviourPenaltyThreshold:t.scoreParams.behaviourPenaltyThreshold,maxMeshMessageDeliveriesWindowSec:r/1e3});s.mcacheSize.addCollect((()=>this.onScrapeMetrics(s)));for(const e of this.multicodecs)s.protocolsEnabled.set({protocol:e},1);this.metrics=s}else this.metrics=null;this.gossipTracer=new aS(this.opts.gossipsubIWantFollowupMs,this.msgIdToStrFn,this.metrics),this.score=new oS(this.opts.scoreParams,this.metrics,{scoreCacheValidityMs:t.heartbeatInterval}),this.maxInboundStreams=e.maxInboundStreams,this.maxOutboundStreams=e.maxOutboundStreams}getPeers(){return[...this.peers.keys()].map((e=>(0,Ht.jE)(e)))}isStarted(){return this.status.code===OS.started}async init(e){this.components=e,this.score.init(e)}async start(){if(this.isStarted())return;this.log("starting"),this.publishConfig=await Kv(this.globalSignaturePolicy,this.components.getPeerId()),this.outboundInflightQueue=(0,_s.d)({objectMode:!0}),(0,Cs.zG)(this.outboundInflightQueue,(async e=>{for await(const{peerId:t,connection:r}of e)await this.createOutboundStream(t,r)})).catch((e=>this.log.error("outbound inflight queue error",e))),await Promise.all(this.opts.directPeers.map((async e=>{await this.components.getPeerStore().addressBook.add(e.id,e.addrs)})));const e=this.components.getRegistrar();await Promise.all(this.multicodecs.map((t=>e.handle(t,this.onIncomingStream.bind(this),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}))));const t=(0,KE.a)({onConnect:this.onPeerConnected.bind(this),onDisconnect:this.onPeerDisconnected.bind(this)}),r=await Promise.all(this.multicodecs.map((r=>e.register(r,t)))),s=setTimeout(this.runHeartbeat,uv);this.status={code:OS.started,registrarTopologyIds:r,heartbeatTimeout:s,hearbeatStartMs:Date.now()+uv},this.score.start(),this.directPeerInitial=setTimeout((()=>{Promise.resolve().then((async()=>{await Promise.all(Array.from(this.direct).map((async e=>await this.connect(e))))})).catch((e=>{this.log(e)}))}),mv),this.log("started")}async stop(){if(this.log("stopping"),this.status.code!==OS.started)return;const{registrarTopologyIds:e}=this.status;this.status={code:OS.stopped};const t=this.components.getRegistrar();e.forEach((e=>t.unregister(e))),this.outboundInflightQueue.end();for(const r of this.streamsOutbound.values())r.close();this.streamsOutbound.clear();for(const r of this.streamsInbound.values())r.close();this.streamsInbound.clear(),this.peers.clear(),this.subscriptions.clear(),this.heartbeatTimer&&(this.heartbeatTimer.cancel(),this.heartbeatTimer=null),this.score.stop(),this.mesh.clear(),this.fanout.clear(),this.fanoutLastpub.clear(),this.gossip.clear(),this.control.clear(),this.peerhave.clear(),this.iasked.clear(),this.backoff.clear(),this.outbound.clear(),this.gossipTracer.clear(),this.seenCache.clear(),this.fastMsgIdCache&&this.fastMsgIdCache.clear(),this.directPeerInitial&&clearTimeout(this.directPeerInitial),this.log("stopped")}dumpPeerScoreStats(){return this.score.dumpPeerScoreStats()}onIncomingStream({stream:e,connection:t}){if(!this.isStarted())return;const r=t.remotePeer;this.addPeer(r,t.stat.direction),this.createInboundStream(r,e),this.outboundInflightQueue.push({peerId:r,connection:t})}onPeerConnected(e,t){this.isStarted()&&(this.addPeer(e,t.stat.direction),this.outboundInflightQueue.push({peerId:e,connection:t}))}onPeerDisconnected(e){this.log("connection ended %p",e),this.removePeer(e)}async createOutboundStream(e,t){if(!this.isStarted())return;const r=e.toString();if(this.peers.has(r)&&!this.streamsOutbound.has(r))try{const s=new DS(await t.newStream(this.multicodecs),(e=>this.log.error("outbound pipe error",e)),{maxBufferSize:this.opts.maxOutboundBufferSize});this.log("create outbound stream %p",e),this.streamsOutbound.set(r,s);const n=s.protocol;n===ZE&&this.floodsubPeers.add(r),this.metrics?.peersPerProtocol.inc({protocol:n},1),this.subscriptions.size>0&&(this.log("send subscriptions to",r),this.sendSubscriptions(r,Array.from(this.subscriptions),!0))}catch(s){this.log.error("createOutboundStream error",s)}}async createInboundStream(e,t){if(!this.isStarted())return;const r=e.toString();if(!this.peers.has(r))return;const s=this.streamsInbound.get(r);void 0!==s&&(this.log("replacing existing inbound steam %s",r),s.close()),this.log("create inbound stream %s",r);const n=new NS(t);this.streamsInbound.set(r,n),this.pipePeerReadStream(e,n.source).catch((e=>this.log(e)))}addPeer(e,t){const r=e.toString();this.peers.has(r)||(this.log("new peer %p",e),this.peers.add(r),this.score.addPeer(r),this.outbound.has(r)||this.outbound.set(r,"outbound"===t))}removePeer(e){const t=e.toString();if(!this.peers.has(t))return;this.log("delete peer %p",e),this.peers.delete(t);const r=this.streamsOutbound.get(t),s=this.streamsInbound.get(t);r&&this.metrics?.peersPerProtocol.inc({protocol:r.protocol},-1),r?.close(),s?.close(),this.streamsOutbound.delete(t),this.streamsInbound.delete(t);for(const n of this.topics.values())n.delete(t);for(const[n,i]of this.mesh)!0===i.delete(t)&&this.metrics?.onRemoveFromMesh(n,hS.Dc,1);for(const n of this.fanout.values())n.delete(t);this.floodsubPeers.delete(t),this.gossip.delete(t),this.control.delete(t),this.outbound.delete(t),this.score.removePeer(t),this.acceptFromWhitelist.delete(t)}get started(){return this.status.code===OS.started}getMeshPeers(e){const t=this.mesh.get(e);return t?Array.from(t):[]}getSubscribers(e){const t=this.topics.get(e);return(t?Array.from(t):[]).map((e=>(0,Ht.jE)(e)))}getTopics(){return Array.from(this.subscriptions)}async pipePeerReadStream(e,t){try{await(0,Cs.zG)(t,(async t=>{for await(const s of t)try{const t=s.subarray(),r=WE.decode(t);this.metrics?.onRpcRecv(r,t.length),this.opts.awaitRpcHandler?await this.handleReceivedRpc(e,r):this.handleReceivedRpc(e,r).catch((e=>this.log(e)))}catch(r){this.log(r)}}))}catch(mu){this.log.error(mu),this.onPeerDisconnected(e)}}async handleReceivedRpc(e,t){if(!this.acceptFrom(e.toString()))return this.log("received message from unacceptable peer %p",e),void this.metrics?.rpcRecvNotAccepted.inc();if(this.log("rpc from %p",e),t.subscriptions&&t.subscriptions.length>0&&(t.subscriptions.forEach((t=>{this.handleReceivedSubscription(e,t)})),this.dispatchEvent(new HE.A("subscription-change",{detail:{peerId:e,subscriptions:t.subscriptions.filter((e=>null!==e.topic)).map((e=>({topic:e.topic??"",subscribe:Boolean(e.subscribe)})))}}))),t.messages)for(const r of t.messages){const t=this.handleReceivedMessage(e,r).catch((e=>this.log(e)));this.opts.awaitRpcMessageHandler&&await t}t.control&&await this.handleControlMessage(e.toString(),t.control)}handleReceivedSubscription(e,t){if(null==t.topic)return;this.log("subscription update from %p topic %s",e,t.topic);let r=this.topics.get(t.topic);null==r&&(r=new Set,this.topics.set(t.topic,r)),t.subscribe?r.add(e.toString()):r.delete(e.toString())}async handleReceivedMessage(e,t){this.metrics?.onMsgRecvPreValidation(t.topic);const r=await this.validateReceivedMessage(e,t);switch(this.metrics?.onMsgRecvResult(t.topic,r.code),r.code){case Fv.duplicate:return this.score.duplicateMessage(e.toString(),r.msgIdStr,t.topic),void this.mcache.observeDuplicate(r.msgIdStr,e.toString());case Fv.invalid:if(r.msgIdStr){const s=r.msgIdStr;this.score.rejectMessage(e.toString(),s,t.topic,r.reason),this.gossipTracer.rejectMessage(s,r.reason)}else this.score.rejectInvalidMessage(e.toString(),t.topic);return void this.metrics?.onMsgRecvInvalid(t.topic,r);case Fv.valid:if(this.score.validateMessage(r.messageId.msgIdStr),this.gossipTracer.deliverMessage(r.messageId.msgIdStr),this.mcache.put(r.messageId,t,!this.opts.asyncValidation),this.subscriptions.has(t.topic)){const t=this.components.getPeerId().equals(e);t&&!this.opts.emitSelf||(super.dispatchEvent(new HE.A("gossipsub:message",{detail:{propagationSource:e,msgId:r.messageId.msgIdStr,msg:r.msg}})),super.dispatchEvent(new HE.A("message",{detail:r.msg})))}this.opts.asyncValidation||this.forwardMessage(r.messageId.msgIdStr,t,e.toString())}}async validateReceivedMessage(e,t){const r=this.fastMsgIdFn?.(t),s=r?this.fastMsgIdCache?.get(r):void 0;if(s)return{code:Fv.duplicate,msgIdStr:s};const n=await bS(this.globalSignaturePolicy,t);if(!n.valid)return{code:Fv.invalid,reason:Vv.Error,error:n.error};const i=n.message;try{this.dataTransform&&(i.data=this.dataTransform.inboundTransform(t.topic,i.data))}catch(u){return this.log("Invalid message, transform failed",u),{code:Fv.invalid,reason:Vv.Error,error:zv.TransformFailed}}const o=await this.msgIdFn(i),a=this.msgIdToStrFn(o),c={msgId:o,msgIdStr:a};if(r&&this.fastMsgIdCache?.put(r,a),this.seenCache.has(a))return{code:Fv.duplicate,msgIdStr:a};this.seenCache.put(a);const l=this.topicValidators.get(t.topic);if(null!=l){let t;try{t=await l(i.topic,i,e)}catch(u){const e=u.code;e===Tv&&(t=jv.Ignore),t=e===Rv?jv.Reject:jv.Ignore}if(t!==jv.Accept)return{code:Fv.invalid,reason:$v(t),msgIdStr:a}}return{code:Fv.valid,messageId:c,msg:i}}getScore(e){return this.score.score(e)}sendSubscriptions(e,t,r){this.sendRpc(e,{subscriptions:t.map((e=>({topic:e,subscribe:r}))),messages:[]})}async handleControlMessage(e,t){if(void 0===t)return;const r=t.ihave?this.handleIHave(e,t.ihave):[],s=t.iwant?this.handleIWant(e,t.iwant):[],n=t.graft?await this.handleGraft(e,t.graft):[];t.prune&&await this.handlePrune(e,t.prune),(r.length||s.length||n.length)&&this.sendRpc(e,Nv(s,{iwant:r,prune:n}))}acceptFrom(e){if(this.direct.has(e))return!0;const t=Date.now(),r=this.acceptFromWhitelist.get(e);if(r&&r.messagesAccepted<Cv&&r.acceptUntil>=t)return r.messagesAccepted+=1,!0;const s=this.score.score(e);return s>=Av?this.acceptFromWhitelist.set(e,{messagesAccepted:0,acceptUntil:t+Pv}):this.acceptFromWhitelist.delete(e),s>=this.opts.scoreThresholds.graylistThreshold}handleIHave(e,t){if(!t.length)return[];const r=this.score.score(e);if(r<this.opts.scoreThresholds.gossipThreshold)return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]",e,r),this.metrics?.ihaveRcvIgnored.inc({reason:pS.LowScore}),[];const s=(this.peerhave.get(e)??0)+1;if(this.peerhave.set(e,s),s>vv)return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring",e,s),this.metrics?.ihaveRcvIgnored.inc({reason:pS.MaxIhave}),[];const n=this.iasked.get(e)??0;if(n>=Ev)return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring",e,n),this.metrics?.ihaveRcvIgnored.inc({reason:pS.MaxIasked}),[];const i=new Map;if(t.forEach((({topicID:e,messageIDs:t})=>{if(!e||!t||!this.mesh.has(e))return;let r=0;t.forEach((e=>{const t=this.msgIdToStrFn(e);this.seenCache.has(t)||(i.set(t,e),r++)})),this.metrics?.onIhaveRcv(e,t.length,r)})),!i.size)return[];let o=i.size;o+n>Ev&&(o=Ev-n),this.log("IHAVE: Asking for %d out of %d messages from %s",o,i.size,e);let a=Array.from(i.values());return Ov(a),a=a.slice(0,o),this.iasked.set(e,n+o),this.gossipTracer.addPromise(e,a),[{messageIDs:a}]}handleIWant(e,t){if(!t.length)return[];const r=this.score.score(e);if(r<this.opts.scoreThresholds.gossipThreshold)return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]",e,r),[];const s=new Map,n=new Map;let i=0;return t.forEach((({messageIDs:t})=>{t&&t.forEach((t=>{const r=this.msgIdToStrFn(t),o=this.mcache.getWithIWantCount(r,e);null!=o?(n.set(o.msg.topic,1+(n.get(o.msg.topic)??0)),o.count>lv?this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request",e,t):s.set(r,o.msg)):i++}))})),this.metrics?.onIwantRcv(n,i),s.size?(this.log("IWANT: Sending %d messages to %s",s.size,e),Array.from(s.values())):(this.log("IWANT: Could not provide any wanted messages to %s",e),[])}async handleGraft(e,t){const r=[],s=this.score.score(e),n=Date.now();let i=this.opts.doPX;return t.forEach((({topicID:t})=>{if(!t)return;const o=this.mesh.get(t);if(!o)return void(i=!1);if(o.has(e))return;if(this.direct.has(e))return this.log("GRAFT: ignoring request from direct peer %s",e),r.push(t),void(i=!1);const a=this.backoff.get(t)?.get(e);if("number"===typeof a&&n<a){this.log("GRAFT: ignoring backed off peer %s",e),this.score.addPenalty(e,1,dS.GraftBackoff),i=!1;const s=a+this.opts.graftFloodThreshold-this.opts.pruneBackoff;return n<s&&this.score.addPenalty(e,1,dS.GraftBackoff),this.addBackoff(e,t),void r.push(t)}return s<0?(this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s",e,s,t),r.push(t),i=!1,void this.addBackoff(e,t)):o.size>=this.opts.Dhi&&!this.outbound.get(e)?(r.push(t),void this.addBackoff(e,t)):(this.log("GRAFT: Add mesh link from %s in %s",e,t),this.score.graft(e,t),o.add(e),void this.metrics?.onAddToMesh(t,uS.Subscribed,1))})),r.length?await Promise.all(r.map((t=>this.makePrune(e,t,i)))):[]}async handlePrune(e,t){const r=this.score.score(e);for(const{topicID:s,backoff:n,peers:i}of t){if(null==s)continue;const t=this.mesh.get(s);if(!t)return;if(this.log("PRUNE: Remove mesh link to %s in %s",e,s),this.score.prune(e,s),t.has(e)&&(t.delete(e),this.metrics?.onRemoveFromMesh(s,hS.Unsub,1)),"number"===typeof n&&n>0?this.doAddBackoff(e,s,1e3*n):this.addBackoff(e,s),i&&i.length){if(r<this.opts.scoreThresholds.acceptPXThreshold){this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]",e,r,s);continue}await this.pxConnect(i)}}}addBackoff(e,t){this.doAddBackoff(e,t,this.opts.pruneBackoff)}doAddBackoff(e,t,r){let s=this.backoff.get(t);s||(s=new Map,this.backoff.set(t,s));const n=Date.now()+r,i=s.get(e)??0;i<n&&s.set(e,n)}applyIwantPenalties(){this.gossipTracer.getBrokenPromises().forEach(((e,t)=>{this.log("peer %s didn't follow up in %d IWANT requests; adding penalty",t,e),this.score.addPenalty(t,e,dS.BrokenPromise)}))}clearBackoff(){if(this.heartbeatTicks%yv!==0)return;const e=Date.now();this.backoff.forEach(((t,r)=>{t.forEach(((r,s)=>{r<e&&t.delete(s)})),0===t.size&&this.backoff.delete(r)}))}async directConnect(){const e=[];this.direct.forEach((t=>{this.streamsOutbound.has(t)||e.push(t)})),await Promise.all(e.map((async e=>await this.connect(e))))}async pxConnect(e){e.length>this.opts.prunePeers&&(Ov(e),e=e.slice(0,this.opts.prunePeers));const t=[];await Promise.all(e.map((async e=>{if(!e.peerID)return;const r=(0,Ht.cv)(e.peerID).toString();if(!this.peers.has(r))if(e.signedPeerRecord)try{const s=await BE.openAndCertify(e.signedPeerRecord,"libp2p-peer-record"),n=s.peerId;if(!s.peerId.equals(r))return void this.log("bogus peer record obtained through px: peer ID %p doesn't match expected peer %p",n,r);if(!await this.components.getPeerStore().addressBook.consumePeerRecord(s))return void this.log("bogus peer record obtained through px: could not add peer record to address book");t.push(r)}catch(s){this.log("bogus peer record obtained through px: invalid signature or not a peer record")}else t.push(r)}))),t.length&&await Promise.all(t.map((async e=>await this.connect(e))))}async connect(e){this.log("Initiating connection with %s",e);const t=(0,Ht.jE)(e),r=await this.components.getConnectionManager().openConnection(t);for(const s of this.multicodecs)for(const e of this.components.getRegistrar().getTopologies(s))e.onConnect(t,r)}subscribe(e){if(this.status.code!==OS.started)throw new Error("Pubsub has not started");if(!this.subscriptions.has(e)){this.subscriptions.add(e);for(const t of this.peers.keys())this.sendSubscriptions(t,[e],!0)}this.join(e)}unsubscribe(e){if(this.status.code!==OS.started)throw new Error("Pubsub is not started");const t=this.subscriptions.delete(e);if(this.log("unsubscribe from %s - am subscribed %s",e,t),t)for(const r of this.peers.keys())this.sendSubscriptions(r,[e],!1);this.leave(e).catch((e=>{this.log(e)}))}join(e){if(this.status.code!==OS.started)throw new Error("Gossipsub has not started");if(this.mesh.has(e))return;this.log("JOIN %s",e),this.metrics?.onJoin(e);const t=new Set,r=this.fanout.get(e);if(r&&(this.fanout.delete(e),this.fanoutLastpub.delete(e),r.forEach((e=>{!this.direct.has(e)&&this.score.score(e)>=0&&t.add(e)})),this.metrics?.onAddToMesh(e,uS.Fanout,t.size)),t.size<this.opts.D){const r=t.size,s=this.getRandomGossipPeers(e,this.opts.D,(e=>!t.has(e)&&!this.direct.has(e)&&this.score.score(e)>=0));s.forEach((e=>{t.add(e)})),this.metrics?.onAddToMesh(e,uS.Random,t.size-r)}this.mesh.set(e,t),t.forEach((t=>{this.log("JOIN: Add mesh link to %s in %s",t,e),this.sendGraft(t,e)}))}async leave(e){if(this.status.code!==OS.started)throw new Error("Gossipsub has not started");this.log("LEAVE %s",e),this.metrics?.onLeave(e);const t=this.mesh.get(e);t&&(await Promise.all(Array.from(t).map((async t=>(this.log("LEAVE: Remove mesh link to %s in %s",t,e),await this.sendPrune(t,e))))),this.mesh.delete(e))}selectPeersToForward(e,t,r){const s=new Set,n=this.topics.get(e);n&&(this.direct.forEach((e=>{n.has(e)&&t!==e&&!r?.has(e)&&s.add(e)})),this.floodsubPeers.forEach((e=>{n.has(e)&&t!==e&&!r?.has(e)&&this.score.score(e)>=this.opts.scoreThresholds.publishThreshold&&s.add(e)})));const i=this.mesh.get(e);return i&&i.size>0&&i.forEach((e=>{t===e||r?.has(e)||s.add(e)})),s}selectPeersToPublish(e){const t=new Set,r={direct:0,floodsub:0,mesh:0,fanout:0},s=this.topics.get(e);if(s)if(this.opts.floodPublish)s.forEach((e=>{this.direct.has(e)?(t.add(e),r.direct++):this.score.score(e)>=this.opts.scoreThresholds.publishThreshold&&(t.add(e),r.floodsub++)}));else{this.direct.forEach((e=>{s.has(e)&&(t.add(e),r.direct++)})),this.floodsubPeers.forEach((e=>{s.has(e)&&this.score.score(e)>=this.opts.scoreThresholds.publishThreshold&&(t.add(e),r.floodsub++)}));const n=this.mesh.get(e);if(n&&n.size>0)n.forEach((e=>{t.add(e),r.mesh++}));else{const s=this.fanout.get(e);if(s&&s.size>0)s.forEach((e=>{t.add(e),r.fanout++}));else{const s=this.getRandomGossipPeers(e,this.opts.D,(e=>this.score.score(e)>=this.opts.scoreThresholds.publishThreshold));s.size>0&&(this.fanout.set(e,s),s.forEach((e=>{t.add(e),r.fanout++})))}this.fanoutLastpub.set(e,Date.now())}}return{tosend:t,tosendCount:r}}forwardMessage(e,t,r,s){r&&this.score.deliverMessage(r,e,t.topic);const n=this.selectPeersToForward(t.topic,r,s),i=Nv([t]);n.forEach((e=>{this.sendRpc(e,i)})),this.metrics?.onForwardMsg(t.topic,n.size)}async publish(e,t){const r=this.dataTransform?this.dataTransform.outboundTransform(e,t):t;if(null==this.publishConfig)throw Error("PublishError.Uninitialized");const{raw:s,msg:n}=await wS(this.publishConfig,e,t,r),i=await this.msgIdFn(n),o=this.msgIdToStrFn(i);if(this.seenCache.has(o))throw Error("PublishError.Duplicate");const{tosend:a,tosendCount:c}=this.selectPeersToPublish(e),l=!0===this.opts.emitSelf&&this.subscriptions.has(e);if(0===a.size&&!this.opts.allowPublishToZeroPeers&&!l)throw Error("PublishError.InsufficientPeers");this.seenCache.put(o),this.mcache.put({msgId:i,msgIdStr:o},s,!0),this.publishedMessageIds.put(o);const u=Nv([s]);for(const h of a){const e=this.sendRpc(h,u);e||a.delete(h)}return this.metrics?.onPublishMsg(e,c,a.size,null!=s.data?s.data.length:0),l&&(a.add(this.components.getPeerId().toString()),super.dispatchEvent(new HE.A("gossipsub:message",{detail:{propagationSource:this.components.getPeerId(),msgId:o,msg:n}})),super.dispatchEvent(new HE.A("message",{detail:n}))),{recipients:Array.from(a.values()).map((e=>(0,Ht.jE)(e)))}}reportMessageValidationResult(e,t,r){if(r===jv.Accept){const s=this.mcache.validate(e);if(this.metrics?.onReportValidationMcacheHit(null!==s),null!=s){const{message:n,originatingPeers:i}=s;this.score.deliverMessage(t.toString(),e,n.topic),this.forwardMessage(e,s.message,t.toString(),i),this.metrics?.onReportValidation(n.topic,r)}}else{const s=this.mcache.remove(e);if(this.metrics?.onReportValidationMcacheHit(null!==s),s){const n=$v(r),{message:i,originatingPeers:o}=s;this.score.rejectMessage(t.toString(),e,i.topic,n);for(const t of o)this.score.rejectMessage(t,e,i.topic,n);this.metrics?.onReportValidation(i.topic,r)}}}sendGraft(e,t){const r=[{topicID:t}],s=Nv([],{graft:r});this.sendRpc(e,s)}async sendPrune(e,t){const r=[await this.makePrune(e,t,this.opts.doPX)],s=Nv([],{prune:r});this.sendRpc(e,s)}sendRpc(e,t){const r=this.streamsOutbound.get(e);if(!r)return this.log(`Cannot send RPC to ${e} as there is no open stream to it available`),!1;const s=this.control.get(e);s&&(this.piggybackControl(e,t,s),this.control.delete(e));const n=this.gossip.get(e);n&&(this.piggybackGossip(e,t,n),this.gossip.delete(e));const i=WE.encode(t).finish();try{r.push(i)}catch(o){return this.log.error(`Cannot send rpc to ${e}`,o),s&&this.control.set(e,s),n&&this.gossip.set(e,n),!1}return this.metrics?.onRpcSent(t,i.length),!0}piggybackControl(e,t,r){const s=(r.graft||[]).filter((({topicID:t})=>(t&&this.mesh.get(t)||new Set).has(e))),n=(r.prune||[]).filter((({topicID:t})=>!(t&&this.mesh.get(t)||new Set).has(e)));(s.length||n.length)&&(t.control?(t.control.graft=t.control.graft&&t.control.graft.concat(s),t.control.prune=t.control.prune&&t.control.prune.concat(n)):t.control={graft:s,prune:n,ihave:[],iwant:[]})}piggybackGossip(e,t,r){t.control||(t.control={ihave:[],iwant:[],graft:[],prune:[]}),t.control.ihave=r}async sendGraftPrune(e,t,r){const s=this.opts.doPX;for(const[n,i]of e){const e=i.map((e=>({topicID:e})));let o=[];const a=t.get(n);a&&(o=await Promise.all(a.map((async e=>await this.makePrune(n,e,s&&!r.get(n))))),t.delete(n));const c=Nv([],{graft:e,prune:o});this.sendRpc(n,c)}for(const[n,i]of t){const e=await Promise.all(i.map((async e=>await this.makePrune(n,e,s&&!r.get(n))))),t=Nv([],{prune:e});this.sendRpc(n,t)}}emitGossip(e){const t=this.mcache.getGossipIDs(new Set(e.keys()));for(const[r,s]of e)this.doEmitGossip(r,s,t.get(r)??[])}doEmitGossip(e,t,r){if(!r.length)return;if(Ov(r),r.length>Ev&&this.log("too many messages for gossip; will truncate IHAVE list (%d messages)",r.length),!t.size)return;let s=this.opts.Dlazy;const n=cv*t.size;let i=t;n>s&&(s=n),s>i.size?s=i.size:i=Ov(Array.from(i)).slice(0,s),i.forEach((t=>{let s=r;r.length>Ev&&(s=Ov(s.slice()).slice(0,Ev)),this.pushGossip(t,{topicID:e,messageIDs:s})}))}flush(){for(const[e,t]of this.gossip.entries())this.gossip.delete(e),this.sendRpc(e,Nv([],{ihave:t}));for(const[e,t]of this.control.entries())this.control.delete(e),this.sendRpc(e,Nv([],{graft:t.graft,prune:t.prune}))}pushGossip(e,t){this.log("Add gossip to %s",e);const r=this.gossip.get(e)||[];this.gossip.set(e,r.concat(t))}async makePrune(e,t,r){if(this.score.prune(e,t),this.streamsOutbound.get(e).protocol===XE)return{topicID:t,peers:[]};const s=this.opts.pruneBackoff/1e3;if(!r)return{topicID:t,peers:[],backoff:s};const n=this.getRandomGossipPeers(t,this.opts.prunePeers,(t=>t!==e&&this.score.score(t)>=0)),i=await Promise.all(Array.from(n).map((async e=>{const t=(0,Ht.jE)(e);return{peerID:t.toBytes(),signedPeerRecord:await this.components.getPeerStore().addressBook.getRawEnvelope(t)}})));return{topicID:t,peers:i,backoff:s}}async heartbeat(){const{D:e,Dlo:t,Dhi:r,Dscore:s,Dout:n,fanoutTTL:i}=this.opts;this.heartbeatTicks++;const o=new Map,a=e=>{let t=o.get(e);return void 0===t&&(t=this.score.score(e),o.set(e,t)),t},c=new Map,l=new Map,u=new Map;this.clearBackoff(),this.peerhave.clear(),this.metrics?.cacheSize.set({cache:"iasked"},this.iasked.size),this.iasked.clear(),this.applyIwantPenalties(),this.heartbeatTicks%this.opts.directConnectTicks===0&&await this.directConnect(),this.fastMsgIdCache?.prune(),this.seenCache.prune(),this.gossipTracer.prune(),this.publishedMessageIds.prune();const h=new Map;this.mesh.forEach(((i,o)=>{const d=this.topics.get(o),p=new Set,f=new Set;if(h.set(o,f),d){const e=Ov(Array.from(d)),t=this.backoff.get(o);for(const r of e){const e=this.streamsOutbound.get(r);if(e&&this.multicodecs.includes(e.protocol)&&!i.has(r)&&!this.direct.has(r)){const e=a(r);t&&t.has(r)||!(e>=0)||p.add(r),e>=this.opts.scoreThresholds.gossipThreshold&&f.add(r)}}}const y=(e,t)=>{this.log("HEARTBEAT: Remove mesh link to %s in %s",e,o),this.addBackoff(e,o),i.delete(e),a(e)>=this.opts.scoreThresholds.gossipThreshold&&f.add(e),this.metrics?.onRemoveFromMesh(o,t,1);const r=l.get(e);r?r.push(o):l.set(e,[o])},g=(e,t)=>{this.log("HEARTBEAT: Add mesh link to %s in %s",e,o),this.score.graft(e,o),i.add(e),f.delete(e),this.metrics?.onAddToMesh(o,t,1);const r=c.get(e);r?r.push(o):c.set(e,[o])};if(i.forEach((e=>{const t=a(e);t<0&&(this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s",e,t,o),y(e,hS.BadScore),u.set(e,!0))})),i.size<t){const t=e-i.size,r=RS(p,t);r.forEach((e=>{g(e,uS.NotEnough)}))}if(i.size>r){let t=Array.from(i);t.sort(((e,t)=>a(t)-a(e))),t=t.slice(0,s).concat(Ov(t.slice(s)));let r=0;if(t.slice(0,e).forEach((e=>{this.outbound.get(e)&&r++})),r<n){const s=e=>{const r=t[e];for(let s=e;s>0;s--)t[s]=t[s-1];t[0]=r};if(r>0){let n=r;for(let r=1;r<e&&n>0;r++)this.outbound.get(t[r])&&(s(r),n--)}let n=e-r;for(let r=e;r<t.length&&n>0;r++)this.outbound.get(t[r])&&(s(r),n--)}t.slice(e).forEach((e=>{y(e,hS.Excess)}))}if(i.size>=t){let e=0;if(i.forEach((t=>{this.outbound.get(t)&&e++})),e<n){const t=n-e,r=kS(p,t,(e=>!0===this.outbound.get(e)));r.forEach((e=>{g(e,uS.Outbound)}))}}if(this.heartbeatTicks%this.opts.opportunisticGraftTicks===0&&i.size>1){const e=Array.from(i).sort(((e,t)=>a(e)-a(t))),t=Math.floor(i.size/2),r=a(e[t]);if(r<this.opts.scoreThresholds.opportunisticGraftThreshold){const e=this.opts.opportunisticGraftPeers,t=kS(p,e,(e=>a(e)>r));for(const r of t)this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s",r,o),g(r,uS.Opportunistic)}}}));const d=Date.now();this.fanoutLastpub.forEach(((e,t)=>{e+i<d&&(this.fanout.delete(t),this.fanoutLastpub.delete(t))})),this.fanout.forEach(((t,r)=>{const s=this.topics.get(r);t.forEach((e=>{(!s.has(e)||a(e)<this.opts.scoreThresholds.publishThreshold)&&t.delete(e)}));const n=this.topics.get(r),i=[],o=new Set;if(h.set(r,o),n){const e=Ov(Array.from(n));for(const r of e){const e=this.streamsOutbound.get(r);if(e&&this.multicodecs.includes(e.protocol)&&!t.has(r)&&!this.direct.has(r)){const e=a(r);e>=this.opts.scoreThresholds.publishThreshold&&i.push(r),e>=this.opts.scoreThresholds.gossipThreshold&&o.add(r)}}}if(t.size<e){const r=e-t.size;i.slice(0,r).forEach((e=>{t.add(e),o?.delete(e)}))}})),this.emitGossip(h),await this.sendGraftPrune(c,l,u),this.flush(),this.mcache.shift(),this.dispatchEvent(new HE.A("gossipsub:heartbeat"))}getRandomGossipPeers(e,t,r=(()=>!0)){const s=this.topics.get(e);if(!s)return new Set;let n=[];return s.forEach((e=>{const t=this.streamsOutbound.get(e);t&&this.multicodecs.includes(t.protocol)&&r(e)&&n.push(e)})),n=Ov(n),t>0&&n.length>t&&(n=n.slice(0,t)),new Set(n)}onScrapeMetrics(e){e.mcacheSize.set(this.mcache.size),e.cacheSize.set({cache:"direct"},this.direct.size),e.cacheSize.set({cache:"seenCache"},this.seenCache.size),e.cacheSize.set({cache:"fastMsgIdCache"},this.fastMsgIdCache?.size??0),e.cacheSize.set({cache:"publishedMessageIds"},this.publishedMessageIds.size),e.cacheSize.set({cache:"mcache"},this.mcache.size),e.cacheSize.set({cache:"score"},this.score.size),e.cacheSize.set({cache:"gossipTracer.promises"},this.gossipTracer.size),e.cacheSize.set({cache:"gossipTracer.requests"},this.gossipTracer.requestMsByMsgSize),e.cacheSize.set({cache:"topics"},this.topics.size),e.cacheSize.set({cache:"subscriptions"},this.subscriptions.size),e.cacheSize.set({cache:"mesh"},this.mesh.size),e.cacheSize.set({cache:"fanout"},this.fanout.size),e.cacheSize.set({cache:"peers"},this.peers.size),e.cacheSize.set({cache:"streamsOutbound"},this.streamsOutbound.size),e.cacheSize.set({cache:"streamsInbound"},this.streamsInbound.size),e.cacheSize.set({cache:"acceptFromWhitelist"},this.acceptFromWhitelist.size),e.cacheSize.set({cache:"gossip"},this.gossip.size),e.cacheSize.set({cache:"control"},this.control.size),e.cacheSize.set({cache:"peerhave"},this.peerhave.size),e.cacheSize.set({cache:"outbound"},this.outbound.size);let t=0;for(const i of this.backoff.values())t+=i.size;e.cacheSize.set({cache:"backoff"},t);for(const[i,o]of this.topics)e.topicPeersCount.set({topicStr:i},o.size);for(const[i,o]of this.mesh)e.meshPeerCounts.set({topicStr:i},o.size);const r=[],s=new Map;e.behaviourPenalty.reset();for(const i of this.peers.keys()){const t=this.score.score(i);r.push(t),s.set(i,t),e.behaviourPenalty.observe(this.score.peerStats.get(i)?.behaviourPenalty??0)}e.registerScores(r,this.opts.scoreThresholds),e.registerScorePerMesh(this.mesh,s);const n=IS(this.peers.keys(),this.score.peerStats,this.score.params,this.score.peerIPs,e.topicStrToLabel);e.registerScoreWeights(n)}}LS.multicodec=JE;const xS=()=>({gossipsub:new LS({allowPublishToZeroPeers:!0,fallbackToFloodsub:!0,emitSelf:!0,maxInboundStreams:64,maxOutboundStreams:128})});var MS=r(85275);const BS=(0,u.kg)("libp2p-delegated-peer-routing"),US=3e4,jS=4;class VS{constructor(e){if(null==e)throw new Error("missing ipfs http client");this.client=e,this.started=!1,this.abortController=new AbortController,this.httpQueue=new Lt.Z({concurrency:jS});const{protocol:t,host:r,port:s}=e.getEndpointConfig();BS(`enabled DelegatedPeerRouting via ${t}://${r}:${s}`)}isStarted(){return this.started}start(){this.started=!0}stop(){this.httpQueue.clear(),this.abortController.abort(),this.abortController=new AbortController,this.started=!1}async findPeer(e,t={}){BS("findPeer starts: %p",e),t.timeout=t.timeout??US,t.signal=ut([this.abortController.signal].concat(null!=t.signal?[t.signal]:[]));const r=(0,MS.Z)(),s=(0,MS.Z)();this.httpQueue.add((async()=>(r.resolve(),await s.promise)));try{await r.promise;for await(const r of this.client.dht.findPeer(e,t))if("FINAL_PEER"===r.name){const e={id:r.peer.id,multiaddrs:r.peer.multiaddrs,protocols:[]};return e}}catch(mu){throw BS.error("findPeer errored: %o",mu),mu}finally{s.resolve(),BS("findPeer finished: %p",e)}throw h(new Error("Not found"),"ERR_NOT_FOUND")}async*getClosestPeers(e,t={}){let r;const s=A.CID.asCID(e);r=null!=s?s:(0,Ht.cv)(e),BS("getClosestPeers starts: %s",r),t.timeout=t.timeout??US,t.signal=ut([this.abortController.signal].concat(null!=t.signal?[t.signal]:[]));const n=(0,MS.Z)(),i=(0,MS.Z)();this.httpQueue.add((async()=>(n.resolve(),await i.promise)));try{await n.promise;for await(const e of this.client.dht.query(r,t))"PEER_RESPONSE"===e.name&&(yield*e.closer.map((e=>({id:e.id,multiaddrs:e.multiaddrs,protocols:[]}))))}catch(mu){throw BS.error("getClosestPeers errored:",mu),mu}finally{i.resolve(),BS("getClosestPeers finished: %b",e)}}}const zS=(0,u.kg)("libp2p:delegated-content-routing"),FS=3e4,$S=4,KS=2;class HS{constructor(e){if(null==e)throw new Error("missing ipfs http client");this.client=e,this.started=!1,this.abortController=new AbortController,this.httpQueue=new Lt.Z({concurrency:$S}),this.httpQueueRefs=new Lt.Z({concurrency:KS});const{protocol:t,host:r,port:s}=e.getEndpointConfig();zS(`enabled DelegatedContentRouting via ${t}://${r}:${s}`)}isStarted(){return this.started}start(){this.started=!0}stop(){this.httpQueue.clear(),this.httpQueueRefs.clear(),this.abortController.abort(),this.abortController=new AbortController,this.started=!1}async*findProviders(e,t={}){zS("findProviders starts: %c",e),t.timeout=t.timeout??FS,t.signal=ut([this.abortController.signal].concat(null!=t.signal?[t.signal]:[]));const r=(0,MS.Z)(),s=(0,MS.Z)();this.httpQueue.add((async()=>(r.resolve(),await s.promise)));try{await r.promise;for await(const r of this.client.dht.findProvs(e,t))"PROVIDER"===r.name&&(yield*r.providers.map((e=>{const t={id:e.id,protocols:[],multiaddrs:e.multiaddrs};return t})))}catch(mu){throw zS.error("findProviders errored:",mu),mu}finally{s.resolve(),zS("findProviders finished: %c",e)}}async provide(e,t={}){zS("provide starts: %c",e),t.timeout=t.timeout??FS,t.signal=ut([this.abortController.signal].concat(null!=t.signal?[t.signal]:[])),await this.httpQueueRefs.add((async()=>{await this.client.block.stat(e,t),await gs(this.client.dht.provide(e,t))})),zS("provide finished: %c",e)}async put(e,t,r={}){zS("put value start: %b",e),r.timeout=r.timeout??FS,r.signal=ut([this.abortController.signal].concat(null!=r.signal?[r.signal]:[])),await this.httpQueue.add((async()=>{await gs(this.client.dht.put(e,t,r))})),zS("put value finished: %b",e)}async get(e,t={}){return zS("get value start: %b",e),t.timeout=t.timeout??FS,t.signal=ut([this.abortController.signal].concat(null!=t.signal?[t.signal]:[])),await this.httpQueue.add((async()=>{for await(const r of this.client.dht.get(e,t))if("VALUE"===r.name)return zS("get value finished: %b",e),r.value;throw h(new Error("Not found"),"ERR_NOT_FOUND")}))}}const qS=e=>Promise.reject(new Error(`No base found for "${e}"`));class GS{constructor(e){this._basesByName={},this._basesByPrefix={},this._loadBase=e.loadBase||qS;for(const t of e.bases)this.addBase(t)}addBase(e){if(this._basesByName[e.name]||this._basesByPrefix[e.prefix])throw new Error(`Codec already exists for codec "${e.name}"`);this._basesByName[e.name]=e,this._basesByPrefix[e.prefix]=e}removeBase(e){delete this._basesByName[e.name],delete this._basesByPrefix[e.prefix]}async getBase(e){if(this._basesByName[e])return this._basesByName[e];if(this._basesByPrefix[e])return this._basesByPrefix[e];const t=await this._loadBase(e);return null==this._basesByName[t.name]&&null==this._basesByPrefix[t.prefix]&&this.addBase(t),t}listBases(){return Object.values(this._basesByName)}}const WS=e=>Promise.reject(new Error(`No codec found for "${e}"`));class YS{constructor(e){this._codecsByName={},this._codecsByCode={},this._loadCodec=e.loadCodec||WS;for(const t of e.codecs)this.addCodec(t)}addCodec(e){if(this._codecsByName[e.name]||this._codecsByCode[e.code])throw new Error(`Resolver already exists for codec "${e.name}"`);this._codecsByName[e.name]=e,this._codecsByCode[e.code]=e}removeCodec(e){delete this._codecsByName[e.name],delete this._codecsByCode[e.code]}async getCodec(e){const t="string"===typeof e?this._codecsByName:this._codecsByCode;if(t[e])return t[e];const r=await this._loadCodec(e);return null==t[e]&&this.addCodec(r),r}listCodecs(){return Object.values(this._codecsByName)}}const QS=e=>Promise.reject(new Error(`No hasher found for "${e}"`));class ZS{constructor(e){this._hashersByName={},this._hashersByCode={},this._loadHasher=e.loadHasher||QS;for(const t of e.hashers)this.addHasher(t)}addHasher(e){if(this._hashersByName[e.name]||this._hashersByCode[e.code])throw new Error(`Resolver already exists for codec "${e.name}"`);this._hashersByName[e.name]=e,this._hashersByCode[e.code]=e}removeHasher(e){delete this._hashersByName[e.name],delete this._hashersByCode[e.code]}async getHasher(e){const t="string"===typeof e?this._hashersByName:this._hashersByCode;if(t[e])return t[e];const r=await this._loadHasher(e);return null==t[e]&&this.addHasher(r),r}listHashers(){return Object.values(this._hashersByName)}}function XS(e){try{e=(0,my.k)((0,qe.HM)(e))}catch(mu){}return e=e.toString(),e}var JS=()=>{};const eI=(0,u.kg)("ipfs-http-client:lib:error-handler"),tI=c.Z.bind({ignoreUndefined:!0}),rI=l.isBrowser||l.isWebWorker?location.protocol:"http",sI=l.isBrowser||l.isWebWorker?location.hostname:"localhost",nI=l.isBrowser||l.isWebWorker?location.port:"5001",iI=(e={})=>{let t,r,s={};if("string"===typeof e||(0,qe.h2)(e))t=new URL(XS(e));else if(e instanceof URL)t=e;else if("string"===typeof e.url||(0,qe.h2)(e.url))t=new URL(XS(e.url)),s=e;else if(e.url instanceof URL)t=e.url,s=e;else{s=e||{};const r=(s.protocol||rI).replace(":",""),n=(s.host||sI).split(":")[0],i=s.port||nI;t=new URL(`${r}://${n}:${i}`)}if(s.apiPath?t.pathname=s.apiPath:"/"!==t.pathname&&void 0!==t.pathname||(t.pathname="api/v0"),l.isNode){const e=JS(t);r=s.agent||new e({keepAlive:!0,maxSockets:6})}return{...s,host:t.host,protocol:t.protocol.replace(":",""),port:Number(t.port),apiPath:t.pathname,url:t,agent:r}},oI=async e=>{let t;try{if((e.headers.get("Content-Type")||"").startsWith("application/json")){const r=await e.json();eI(r),t=r.Message||r.message}else t=await e.text()}catch(mu){eI("Failed to parse error response",mu),t=mu.message}let r=new xt.HTTPError(e);throw t&&(t.includes("deadline has elapsed")&&(r=new xt.TimeoutError),t&&t.includes("context deadline exceeded")&&(r=new xt.TimeoutError)),t&&t.includes("request timed out")&&(r=new xt.TimeoutError),t&&(r.message=t),r},aI=/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g,cI=e=>e.replace(aI,(function(e){return"-"+e.toLowerCase()})),lI=e=>"string"===typeof e?ft(e):e;class uI extends xt{constructor(e={}){const t=iI(e);super({timeout:lI(t.timeout||0)||void 0,headers:t.headers,base:`${t.url}`,handleError:oI,transformSearchParams:e=>{const t=new URLSearchParams;for(const[r,s]of e)"undefined"!==s&&"null"!==s&&"signal"!==r&&t.append(cI(r),s),"timeout"!==r||isNaN(s)||t.append(cI(r),s);return t},agent:t.agent}),delete this.get,delete this.put,delete this.delete,delete this.options;const r=this.fetch;this.fetch=(e,s={})=>("string"!==typeof e||e.startsWith("/")||(e=`${t.url}/${e}`),r.call(this,e,tI(s,{method:"POST"})))}}xt.HTTPError;const hI=e=>t=>e(new uI(t),t);function dI(e){if(null!=e)return"string"===typeof e?e:e.toString(8).padStart(4,"0")}function pI(e){if(null==e)return;let t;if(null!=e.secs&&(t={secs:e.secs,nsecs:e.nsecs}),null!=e.Seconds&&(t={secs:e.Seconds,nsecs:e.FractionalNanoseconds}),Array.isArray(e)&&(t={secs:e[0],nsecs:e[1]}),e instanceof Date){const r=e.getTime(),s=Math.floor(r/1e3);t={secs:s,nsecs:1e3*(r-1e3*s)}}if(Object.prototype.hasOwnProperty.call(t,"secs")){if(null!=t&&null!=t.nsecs&&(t.nsecs<0||t.nsecs>999999999))throw h(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return t}}function fI({arg:e,searchParams:t,hashAlg:r,mtime:s,mode:n,...i}={}){t&&(i={...i,...t}),r&&(i.hash=r),null!=s&&(s=pI(s),i.mtime=s.secs,i.mtimeNsecs=s.nsecs),null!=n&&(i.mode=dI(n)),i.timeout&&!isNaN(i.timeout)&&(i.timeout=`${i.timeout}ms`),void 0===e||null===e?e=[]:Array.isArray(e)||(e=[e]);const o=new URLSearchParams(i);return e.forEach((e=>o.append("arg",e))),o}const yI=hI((e=>{async function t(t={}){const r=await(await e.post("bitswap/wantlist",{signal:t.signal,searchParams:fI(t),headers:t.headers})).json();return(r.Keys||[]).map((e=>A.CID.parse(e["/"])))}return t})),gI=hI((e=>{async function t(t,r={}){const s=await(await e.post("bitswap/wantlist",{signal:r.signal,searchParams:fI({...r,peer:t.toString()}),headers:r.headers})).json();return(s.Keys||[]).map((e=>A.CID.parse(e["/"])))}return t})),mI=hI((e=>{async function t(t={}){const r=await e.post("bitswap/stat",{searchParams:fI(t),signal:t.signal,headers:t.headers});return wI(await r.json())}return t}));function wI(e){return{provideBufLen:e.ProvideBufLen,wantlist:(e.Wantlist||[]).map((e=>A.CID.parse(e["/"]))),peers:(e.Peers||[]).map((e=>(0,Ht.jE)(e))),blocksReceived:BigInt(e.BlocksReceived),dataReceived:BigInt(e.DataReceived),blocksSent:BigInt(e.BlocksSent),dataSent:BigInt(e.DataSent),dupBlksReceived:BigInt(e.DupBlksReceived),dupDataReceived:BigInt(e.DupDataReceived)}}const bI=hI((e=>{async function t(t,r={}){const s=await e.post("bitswap/unwant",{signal:r.signal,searchParams:fI({arg:t.toString(),...r}),headers:r.headers});return s.json()}return t}));function _I(e){return{wantlist:yI(e),wantlistForPeer:gI(e),unwant:bI(e),stat:mI(e)}}const EI=hI((e=>{async function t(t,r={}){const s=await e.post("block/get",{signal:r.signal,searchParams:fI({arg:t.toString(),...r}),headers:r.headers});return new Uint8Array(await s.arrayBuffer())}return t}));async function vI(e){if($n(e))return new Blob([e]);if("string"===typeof e||e instanceof String)return new Blob([e.toString()]);if(Kn(e))return e;if(qn(e)&&(e=Vn(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const t=Fn(e),{value:r,done:s}=await t.peek();if(s)return SI(t);if(t.push(r),Number.isInteger(r))return new Blob([Uint8Array.from(await fs(t))]);if($n(r)||"string"===typeof r||r instanceof String)return SI(t)}throw h(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT")}async function SI(e){const t=[];for await(const r of e)t.push(r);return new Blob(t)}function II(e){return So(e,vI,!0)}function kI(e){if(null!=e)return"string"===typeof e?e:e.toString(8).padStart(4,"0")}async function RI(e,t,r={}){const s=[],n=new FormData;let i=0,o=0;for await(const{content:a,path:c,mode:l,mtime:u}of II(e)){let e="";const t=a?"file":"dir";i>0&&(e=`-${i}`);let r=t+e;const h=[];if(null!==l&&void 0!==l&&h.push(`mode=${kI(l)}`),null!=u){const{secs:e,nsecs:t}=u;h.push(`mtime=${e}`),null!=t&&h.push(`mtime-nsecs=${t}`)}if(h.length&&(r=`${r}?${h.join("&")}`),a){n.set(r,a,null!=c?encodeURIComponent(c):void 0);const e=o+a.size;s.push({name:c,start:o,end:e}),o=e}else{if(null==c)throw new Error("path or content or both must be set");n.set(r,new File([""],encodeURIComponent(c),{type:"application/x-directory"}))}i++}return{total:o,parts:s,headers:r,body:n}}function TI(e){return e.filter(Boolean)}function AI(...e){return(0,ut.anySignal)(TI(e))}const CI=hI((e=>{async function t(r,s={}){const n=new AbortController,i=AI(n.signal,s.signal);let o;try{const t=await e.post("block/put",{signal:i,searchParams:fI(s),...await RI([r],n,s.headers)});o=await t.json()}catch(mu){if("dag-pb"===s.format)return t(r,{...s,format:"protobuf"});if("dag-cbor"===s.format)return t(r,{...s,format:"cbor"});throw mu}return A.CID.parse(o.Key)}return t})),PI=hI((e=>{async function*t(t,r={}){Array.isArray(t)||(t=[t]);const s=await e.post("block/rm",{signal:r.signal,searchParams:fI({arg:t.map((e=>e.toString())),"stream-channels":!0,...r}),headers:r.headers});for await(const e of s.ndjson())yield DI(e)}return t}));function DI(e){const t={cid:A.CID.parse(e.Hash)};return e.Error&&(t.error=new Error(e.Error)),t}const NI=hI((e=>{async function t(t,r={}){const s=await e.post("block/stat",{signal:r.signal,searchParams:fI({arg:t.toString(),...r}),headers:r.headers}),n=await s.json();return{cid:A.CID.parse(n.Key),size:n.Size}}return t}));function OI(e){return{get:EI(e),put:CI(e),rm:PI(e),stat:NI(e)}}const LI=hI((e=>{async function t(t,r={}){const s=await e.post("bootstrap/add",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),{Peers:n}=await s.json();return{Peers:n.map((e=>(0,qe.HM)(e)))}}return t})),xI=hI((e=>{async function t(t={}){const r=await e.post("bootstrap/rm",{signal:t.signal,searchParams:fI({...t,all:!0}),headers:t.headers}),{Peers:s}=await r.json();return{Peers:s.map((e=>(0,qe.HM)(e)))}}return t})),MI=hI((e=>{async function t(t={}){const r=await e.post("bootstrap/list",{signal:t.signal,searchParams:fI(t),headers:t.headers}),{Peers:s}=await r.json();return{Peers:s.map((e=>(0,qe.HM)(e)))}}return t})),BI=hI((e=>{async function t(t={}){const r=await e.post("bootstrap/add",{signal:t.signal,searchParams:fI({...t,default:!0}),headers:t.headers}),{Peers:s}=await r.json();return{Peers:s.map((e=>(0,qe.HM)(e)))}}return t})),UI=hI((e=>{async function t(t,r={}){const s=await e.post("bootstrap/rm",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),{Peers:n}=await s.json();return{Peers:n.map((e=>(0,qe.HM)(e)))}}return t}));function jI(e){return{add:LI(e),clear:xI(e),list:MI(e),reset:BI(e),rm:UI(e)}}const VI=hI((e=>{async function t(t,r={}){const s=await e.post("config/profile/apply",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),n=await s.json();return{original:n.OldCfg,updated:n.NewCfg}}return t}));function zI(e){if(null==e)return e;const t=/^[A-Z]+$/,r={};return Object.keys(e).reduce(((r,s)=>(t.test(s)?r[s.toLowerCase()]=e[s]:t.test(s[0])?r[s[0].toLowerCase()+s.slice(1)]=e[s]:r[s]=e[s],r)),r)}const FI=hI((e=>{async function t(t={}){const r=await e.post("config/profile/list",{signal:t.signal,searchParams:fI(t),headers:t.headers}),s=await r.json();return s.map((e=>zI(e)))}return t}));function $I(e){return{apply:VI(e),list:FI(e)}}const KI=hI((e=>{const t=async(t,r={})=>{if(!t)throw new Error("key argument is required");const s=await e.post("config",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),n=await s.json();return n.Value};return t})),HI=hI((e=>{const t=async(t={})=>{const r=await e.post("config/show",{signal:t.signal,searchParams:fI({...t}),headers:t.headers}),s=await r.json();return s};return t})),qI=hI((e=>{const t=async(t,r={})=>{const s=new AbortController,n=AI(s.signal,r.signal),i=await e.post("config/replace",{signal:n,searchParams:fI(r),...await RI([(0,ze.m)(JSON.stringify(t))],s,r.headers)});await i.text()};return t})),GI=hI((e=>{const t=async(t,r,s={})=>{if("string"!==typeof t)throw new Error("Invalid key type");const n={...s,...WI(t,r)},i=await e.post("config",{signal:s.signal,searchParams:fI(n),headers:s.headers});await i.text()};return t})),WI=(e,t)=>{switch(typeof t){case"boolean":return{arg:[e,t.toString()],bool:!0};case"string":return{arg:[e,t]};default:return{arg:[e,JSON.stringify(t)],json:!0}}};function YI(e){return{getAll:HI(e),get:KI(e),set:GI(e),replace:qI(e),profiles:$I(e)}}const QI=hI((e=>{async function*t(t,r={}){const s=await e.post("dag/export",{signal:r.signal,searchParams:fI({arg:t.toString()}),headers:r.headers});yield*s.iterator()}return t}));async function*ZI(e,t,r,s,n){const i=async e=>{const t=await r.getCodec(e.code),i=await s(e,n);return t.decode(i)},o=t.split("/").filter(Boolean);let a=await i(e),c=e;while(o.length){const e=o.shift();if(!e)throw h(new Error(`Could not resolve path "${t}"`),"ERR_INVALID_PATH");if(!Object.prototype.hasOwnProperty.call(a,e))throw h(new Error(`no link named "${e}" under ${c}`),"ERR_NO_LINK");a=a[e],yield{value:a,remainderPath:o.join("/")};const r=A.CID.asCID(a);r&&(c=r,a=await i(a))}yield{value:a,remainderPath:""}}const XI=(e,t)=>{const r=hI(((t,r)=>{const s=EI(r),n=async(t,r={})=>{if(r.path){const n=r.localResolve?await sy(ZI(t,r.path,e,s,r)):await Wt(ZI(t,r.path,e,s,r)),i=n;if(!i)throw h(new Error("Not found"),"ERR_NOT_FOUND");return i}const n=await e.getCodec(t.code),i=await s(t,r),o=n.decode(i);return{value:o,remainderPath:""}};return n}));return r(t)},JI=hI((e=>{async function*t(t,r={}){const s=new AbortController,n=AI(s.signal,r.signal),{headers:i,body:o}=await RI(t,s,r.headers),a=await e.post("dag/import",{signal:n,headers:i,body:o,searchParams:fI({"pin-roots":r.pinRoots})});for await(const{Root:e}of a.ndjson())if(void 0!==e){const{Cid:{"/":t},PinErrorMsg:r}=e;yield{root:{cid:A.CID.parse(t),pinErrorMsg:r}}}}return t})),ek=(e,t)=>{const r=hI((t=>{const r=async(r,s={})=>{const n={storeCodec:"dag-cbor",hashAlg:"sha2-256",...s};let i;if(n.inputCodec){if(!(r instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");i=r}else{const t=await e.getCodec(n.storeCodec);i=t.encode(r),n.inputCodec=n.storeCodec}const o=new AbortController,a=AI(o.signal,n.signal),c=await t.post("dag/put",{timeout:n.timeout,signal:a,searchParams:fI(n),...await RI([i],o,n.headers)}),l=await c.json();return A.CID.parse(l.Cid["/"])};return r}));return r(t)},tk=hI((e=>{const t=async(t,r={})=>{const s=await e.post("dag/resolve",{signal:r.signal,searchParams:fI({arg:`${t}${r.path?`/${r.path}`.replace(/\/[/]+/g,"/"):""}`,...r}),headers:r.headers}),n=await s.json();return{cid:A.CID.parse(n.Cid["/"]),remainderPath:n.RemPath}};return t}));function rk(e,t){return{export:QI(t),get:XI(e,t),import:JI(t),put:ek(e,t),resolve:tk(t)}}const sk=0,nk=1,ik=2,ok=3,ak=4,ck=5,lk=6,uk=7,hk=e=>{if(e.Type===sk)return{name:"SENDING_QUERY",type:e.Type};if(e.Type===nk)return{from:(0,Ht.jE)(e.ID),name:"PEER_RESPONSE",type:e.Type,messageType:0,messageName:"PUT_VALUE",closer:(e.Responses||[]).map((({ID:e,Addrs:t})=>({id:(0,Ht.jE)(e),multiaddrs:t.map((e=>(0,qe.HM)(e))),protocols:[]}))),providers:(e.Responses||[]).map((({ID:e,Addrs:t})=>({id:(0,Ht.jE)(e),multiaddrs:t.map((e=>(0,qe.HM)(e))),protocols:[]})))};if(e.Type===ik){let t={id:e.ID??(0,Ht.jE)(e.ID),multiaddrs:[],protocols:[]};return e.Responses&&e.Responses.length&&(t={id:(0,Ht.jE)(e.Responses[0].ID),multiaddrs:e.Responses[0].Addrs.map((e=>(0,qe.HM)(e))),protocols:[]}),{name:"FINAL_PEER",type:e.Type,peer:t}}if(e.Type===ok)return{name:"QUERY_ERROR",type:e.Type,error:new Error(e.Extra)};if(e.Type===ak)return{name:"PROVIDER",type:e.Type,providers:e.Responses.map((({ID:e,Addrs:t})=>({id:(0,Ht.jE)(e),multiaddrs:t.map((e=>(0,qe.HM)(e))),protocols:[]})))};if(e.Type===ck)return{name:"VALUE",type:e.Type,value:(0,ze.m)(e.Extra,"base64pad")};if(e.Type===lk){const t=e.Responses.map((({ID:e})=>(0,Ht.jE)(e)));if(!t.length)throw new Error("No peer found");return{name:"ADDING_PEER",type:e.Type,peer:t[0]}}if(e.Type===uk)return{name:"DIALING_PEER",type:e.Type,peer:(0,Ht.jE)(e.ID)};throw new Error("Unknown DHT event type")},dk=hI((e=>{async function*t(t,r={}){const s=await e.post("dht/findpeer",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers});for await(const e of s.ndjson())yield hk(e)}return t})),pk=hI((e=>{async function*t(t,r={}){const s=await e.post("dht/findprovs",{signal:r.signal,searchParams:fI({arg:t.toString(),...r}),headers:r.headers});for await(const e of s.ndjson())yield hk(e)}return t})),fk=hI((e=>{async function*t(t,r={}){const s=await e.post("dht/get",{signal:r.signal,searchParams:fI({arg:t instanceof Uint8Array?(0,Ye.B)(t):t.toString(),...r}),headers:r.headers});for await(const e of s.ndjson())yield hk(e)}return t})),yk=hI((e=>{async function*t(t,r={recursive:!1}){const s=Array.isArray(t)?t:[t],n=await e.post("dht/provide",{signal:r.signal,searchParams:fI({arg:s.map((e=>e.toString())),...r}),headers:r.headers});for await(const e of n.ndjson())yield hk(e)}return t})),gk=hI((e=>{async function*t(t,r,s={}){const n=new AbortController,i=AI(n.signal,s.signal),o=await e.post("dht/put",{signal:i,searchParams:fI({arg:t instanceof Uint8Array?(0,Ye.B)(t):t.toString(),...s}),...await RI([r],n,s.headers)});for await(const e of o.ndjson())yield hk(e)}return t})),mk=hI((e=>{async function*t(t,r={}){const s=await e.post("dht/query",{signal:r.signal,searchParams:fI({arg:t.toString(),...r}),headers:r.headers});for await(const e of s.ndjson())yield hk(e)}return t}));function wk(e){return{findPeer:dk(e),findProvs:pk(e),get:fk(e),provide:yk(e),put:gk(e),query:mk(e)}}const bk=hI((e=>{async function t(t={}){const r=await e.post("diag/cmds",{signal:t.signal,searchParams:fI(t),headers:t.headers});return r.json()}return t})),_k=hI((e=>{async function t(t={}){const r=await e.post("diag/net",{signal:t.signal,searchParams:fI(t),headers:t.headers});return r.json()}return t})),Ek=hI((e=>{async function t(t={}){const r=await e.post("diag/sys",{signal:t.signal,searchParams:fI(t),headers:t.headers});return r.json()}return t}));function vk(e){return{cmds:bk(e),net:_k(e),sys:Ek(e)}}const Sk=hI((e=>{async function t(t,r,s={}){const n=await e.post("files/chmod",{signal:s.signal,searchParams:fI({arg:t,mode:r,...s}),headers:s.headers});await n.text()}return t})),Ik=hI((e=>{async function t(t,r,s={}){const n=Array.isArray(t)?t:[t],i=await e.post("files/cp",{signal:s.signal,searchParams:fI({arg:n.concat(r).map((e=>A.CID.asCID(e)?`/ipfs/${e}`:e)),...s}),headers:s.headers});await i.text()}return t})),kk=hI((e=>{async function t(t,r={}){if(!t||"string"!==typeof t)throw new Error("ipfs.files.flush requires a path");const s=await e.post("files/flush",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),n=await s.json();return A.CID.parse(n.Cid)}return t}));function Rk(e){const t=zI(e);return Object.prototype.hasOwnProperty.call(t,"mode")&&(t.mode=parseInt(t.mode,8)),Object.prototype.hasOwnProperty.call(t,"mtime")&&(t.mtime={secs:t.mtime,nsecs:t.mtimeNsecs||0},delete t.mtimeNsecs),t}const Tk=hI((e=>{async function*t(t,r={}){if(!t)throw new Error("ipfs.files.ls requires a path");const s=await e.post("files/ls",{signal:r.signal,searchParams:fI({arg:A.CID.asCID(t)?`/ipfs/${t}`:t,long:!0,...r,stream:!0}),headers:r.headers});for await(const e of s.ndjson())if("Entries"in e)for(const t of e.Entries||[])yield Ak(Rk(t));else yield Ak(Rk(e))}return t}));function Ak(e){return e.hash&&(e.cid=A.CID.parse(e.hash)),delete e.hash,e.type=1===e.type?"directory":"file",e}const Ck=hI((e=>{async function t(t,r={}){const s=await e.post("files/mkdir",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers});await s.text()}return t})),Pk=hI((e=>{async function t(t,r,s={}){Array.isArray(t)||(t=[t]);const n=await e.post("files/mv",{signal:s.signal,searchParams:fI({arg:t.concat(r),...s}),headers:s.headers});await n.text()}return t}));var Dk=r(50590);const Nk=hI((e=>{async function*t(t,r={}){const s=await e.post("files/read",{signal:r.signal,searchParams:fI({arg:t,count:r.length,...r}),headers:r.headers});yield*Dk(s.body)}return t})),Ok=hI((e=>{async function t(t,r={}){const s=await e.post("files/rm",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),n=await s.text();if(""!==n){const e=new xt.HTTPError(s);throw e.message=n,e}}return t})),Lk=hI((e=>{async function t(t,r={}){const s=await e.post("files/stat",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),n=await s.json();return n.WithLocality=n.WithLocality||!1,xk(Rk(n))}return t}));function xk(e){return e.cid=A.CID.parse(e.hash),delete e.hash,e}const Mk=hI((e=>{async function t(t,r={}){const s=await e.post("files/touch",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers});await s.text()}return t})),Bk=hI((e=>{async function t(t,r,s={}){const n=new AbortController,i=AI(n.signal,s.signal),o=await e.post("files/write",{signal:i,searchParams:fI({arg:t,streamChannels:!0,count:s.length,...s}),...await RI([{content:r,path:"arg",mode:dI(s.mode),mtime:pI(s.mtime)}],n,s.headers)});await o.text()}return t}));function Uk(e){return{chmod:Sk(e),cp:Ik(e),flush:kk(e),ls:Tk(e),mkdir:Ck(e),mv:Pk(e),read:Nk(e),rm:Ok(e),stat:Lk(e),touch:Mk(e),write:Bk(e)}}const jk=hI((e=>{const t=async(e,t,r={})=>{throw h(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")};return t})),Vk=hI((e=>{async function t(t,r={type:"Ed25519"}){const s=await e.post("key/gen",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),n=await s.json();return zI(n)}return t})),zk=hI((e=>{async function t(t,r,s,n={}){const i=await e.post("key/import",{signal:n.signal,searchParams:fI({arg:t,pem:r,password:s,...n}),headers:n.headers}),o=await i.json();return zI(o)}return t})),Fk=hI((e=>{const t=async(e,t={})=>{throw h(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")};return t})),$k=hI((e=>{async function t(t={}){const r=await e.post("key/list",{signal:t.signal,searchParams:fI(t),headers:t.headers}),s=await r.json();return(s.Keys||[]).map((e=>zI(e)))}return t})),Kk=hI((e=>{async function t(t,r,s={}){const n=await e.post("key/rename",{signal:s.signal,searchParams:fI({arg:[t,r],...s}),headers:s.headers});return zI(await n.json())}return t})),Hk=hI((e=>{async function t(t,r={}){const s=await e.post("key/rm",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),n=await s.json();return zI(n.Keys[0])}return t}));function qk(e){return{export:jk(e),gen:Vk(e),import:zk(e),info:Fk(e),list:$k(e),rename:Kk(e),rm:Hk(e)}}const Gk=hI((e=>{async function t(t,r,s={}){const n=await e.post("log/level",{signal:s.signal,searchParams:fI({arg:[t,r],...s}),headers:s.headers});return zI(await n.json())}return t})),Wk=hI((e=>{async function t(t={}){const r=await e.post("log/ls",{signal:t.signal,searchParams:fI(t),headers:t.headers}),s=await r.json();return s.Strings}return t})),Yk=hI((e=>{async function*t(t={}){const r=await e.post("log/tail",{signal:t.signal,searchParams:fI(t),headers:t.headers});yield*r.ndjson()}return t}));function Qk(e){return{level:Gk(e),ls:Wk(e),tail:Yk(e)}}const Zk=hI((e=>{async function t(t,r={}){const s=await e.post("name/publish",{signal:r.signal,searchParams:fI({arg:`${t}`,...r}),headers:r.headers});return zI(await s.json())}return t})),Xk=hI((e=>{async function*t(t,r={}){const s=await e.post("name/resolve",{signal:r.signal,searchParams:fI({arg:t,stream:!0,...r}),headers:r.headers});for await(const e of s.ndjson())yield e.Path}return t})),Jk=hI((e=>{async function t(t,r={}){const s=await e.post("name/pubsub/cancel",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers});return zI(await s.json())}return t})),eR=hI((e=>{async function t(t={}){const r=await e.post("name/pubsub/state",{signal:t.signal,searchParams:fI(t),headers:t.headers});return zI(await r.json())}return t})),tR=hI((e=>{async function t(t={}){const r=await e.post("name/pubsub/subs",{signal:t.signal,searchParams:fI(t),headers:t.headers}),s=await r.json();return s.Strings||[]}return t}));function rR(e){return{cancel:Jk(e),state:eR(e),subs:tR(e)}}function sR(e){return{publish:Zk(e),resolve:Xk(e),pubsub:rR(e)}}const nR=hI((e=>{async function t(t,r={}){const s=await e.post("object/data",{signal:r.signal,searchParams:fI({arg:`${t instanceof Uint8Array?A.CID.decode(t):t}`,...r}),headers:r.headers}),n=await s.arrayBuffer();return new Uint8Array(n,0,n.byteLength)}return t})),iR=hI((e=>{async function t(t,r={}){const s=await e.post("object/get",{signal:r.signal,searchParams:fI({arg:`${t instanceof Uint8Array?A.CID.decode(t):t}`,dataEncoding:"base64",...r}),headers:r.headers}),n=await s.json();return{Data:(0,ze.m)(n.Data,"base64pad"),Links:(n.Links||[]).map((e=>({Name:e.Name,Hash:A.CID.parse(e.Hash),Tsize:e.Size})))}}return t})),oR=hI((e=>{async function t(t,r={}){const s=await e.post("object/links",{signal:r.signal,searchParams:fI({arg:`${t instanceof Uint8Array?A.CID.decode(t):t}`,...r}),headers:r.headers}),n=await s.json();return(n.Links||[]).map((e=>({Name:e.Name,Tsize:e.Size,Hash:A.CID.parse(e.Hash)})))}return t})),aR=hI((e=>{async function t(t={}){const r=await e.post("object/new",{signal:t.signal,searchParams:fI({arg:t.template,...t}),headers:t.headers}),{Hash:s}=await r.json();return A.CID.parse(s)}return t})),cR=(e,t)=>{const r=hI((r=>{const s=ek(e,t);async function n(e,t={}){return s(e,{...t,storeCodec:"dag-pb",hashAlg:"sha2-256",version:1})}return n}));return r(t)},lR=hI((e=>{async function t(t,r={}){const s=await e.post("object/stat",{signal:r.signal,searchParams:fI({arg:`${t}`,...r}),headers:r.headers}),n=await s.json();return{...n,Hash:A.CID.parse(n.Hash)}}return t})),uR=hI((e=>{async function t(t,r,s={}){const n=await e.post("object/patch/add-link",{signal:s.signal,searchParams:fI({arg:[`${t}`,r.Name||r.name||"",(r.Hash||r.cid||"").toString()||null],...s}),headers:s.headers}),{Hash:i}=await n.json();return A.CID.parse(i)}return t})),hR=hI((e=>{async function t(t,r,s={}){const n=new AbortController,i=AI(n.signal,s.signal),o=await e.post("object/patch/append-data",{signal:i,searchParams:fI({arg:`${t}`,...s}),...await RI([r],n,s.headers)}),{Hash:a}=await o.json();return A.CID.parse(a)}return t})),dR=hI((e=>{async function t(t,r,s={}){const n=await e.post("object/patch/rm-link",{signal:s.signal,searchParams:fI({arg:[`${t}`,r.Name||r.name||null],...s}),headers:s.headers}),{Hash:i}=await n.json();return A.CID.parse(i)}return t})),pR=hI((e=>{async function t(t,r,s={}){const n=new AbortController,i=AI(n.signal,s.signal),o=await e.post("object/patch/set-data",{signal:i,searchParams:fI({arg:[`${t}`],...s}),...await RI([r],n,s.headers)}),{Hash:a}=await o.json();return A.CID.parse(a)}return t}));function fR(e){return{addLink:uR(e),appendData:hR(e),rmLink:dR(e),setData:pR(e)}}function yR(e,t){return{data:nR(t),get:iR(t),links:oR(t),new:aR(t),put:cR(e,t),stat:lR(t),patch:fR(t)}}const gR=hI((e=>{async function*t(t,r={}){for await(const{path:s,recursive:n,metadata:i}of Qt(t)){const t=await e.post("pin/add",{signal:r.signal,searchParams:fI({...r,arg:s,recursive:n,metadata:i?JSON.stringify(i):void 0,stream:!0}),headers:r.headers});for await(const e of t.ndjson())if(e.Pins)for(const t of e.Pins)yield A.CID.parse(t);else yield A.CID.parse(e)}}return t}));function mR(e){const t=gR(e);return hI((()=>{async function e(e,r={}){return Wt(t([{path:e,...r}],r))}return e}))(e)}function wR(e,t,r){const s={type:e,cid:A.CID.parse(t)};return r&&(s.metadata=r),s}const bR=hI((e=>{async function*t(t={}){let r=[];t.paths&&(r=Array.isArray(t.paths)?t.paths:[t.paths]);const s=await e.post("pin/ls",{signal:t.signal,searchParams:fI({...t,arg:r.map((e=>`${e}`)),stream:!0}),headers:t.headers});for await(const e of s.ndjson()){if(e.Keys){for(const t of Object.keys(e.Keys))yield wR(e.Keys[t].Type,t,e.Keys[t].Metadata);return}yield wR(e.Type,e.Cid,e.Metadata)}}return t})),_R=hI((e=>{async function*t(t,r={}){for await(const{path:s,recursive:n}of Qt(t)){const t=new URLSearchParams(r.searchParams);t.append("arg",`${s}`),null!=n&&t.set("recursive",String(n));const i=await e.post("pin/rm",{signal:r.signal,headers:r.headers,searchParams:fI({...r,arg:`${s}`,recursive:n})});for await(const e of i.ndjson())e.Pins?yield*e.Pins.map((e=>A.CID.parse(e))):yield A.CID.parse(e)}}return t})),ER=e=>{const t=_R(e);return hI((()=>{async function e(e,r={}){return Wt(t([{path:e,...r}],r))}return e}))(e)},vR=({Name:e,Status:t,Cid:r})=>({cid:A.CID.parse(r),name:e,status:t}),SR=e=>{if("string"===typeof e&&""!==e)return e;throw new TypeError("service name must be passed")},IR=e=>{if(A.CID.asCID(e))return e.toString();throw new TypeError("CID instance expected instead of "+typeof e)},kR=({service:e,cid:t,name:r,status:s,all:n})=>{const i=fI({service:SR(e),name:r,force:!!n||void 0});if(t)for(const o of t)i.append("cid",IR(o));if(s)for(const o of s)i.append("status",o);return i},RR=({cid:e,service:t,background:r,name:s,origins:n})=>{const i=fI({arg:IR(e),service:SR(t),name:s,background:!!r||void 0});if(n)for(const o of n)i.append("origin",o.toString());return i};function TR(e){async function t(t,{timeout:r,signal:s,headers:n,...i}){const o=await e.post("pin/remote/add",{timeout:r,signal:s,headers:n,searchParams:RR({cid:t,...i})});return vR(await o.json())}return t}function AR(e){async function*t({timeout:t,signal:r,headers:s,...n}){const i=await e.post("pin/remote/ls",{timeout:t,signal:r,headers:s,searchParams:kR(n)});for await(const e of i.ndjson())yield vR(e)}return t}function CR(e){async function t({timeout:t,signal:r,headers:s,...n}){await e.post("pin/remote/rm",{timeout:t,signal:r,headers:s,searchParams:kR({...n,all:!1})})}return t}function PR(e){async function t({timeout:t,signal:r,headers:s,...n}){await e.post("pin/remote/rm",{timeout:t,signal:r,headers:s,searchParams:kR({...n,all:!0})})}return t}function DR(e){const t=String(e);if("undefined"===t)throw Error("endpoint is required");return"/"===t[t.length-1]?t.slice(0,-1):t}function NR(e){return{service:e.Service,endpoint:new URL(e.ApiEndpoint),...e.Stat&&{stat:OR(e.Stat)}}}function OR(e){switch(e.Status){case"valid":{const{Pinning:t,Pinned:r,Queued:s,Failed:n}=e.PinCount;return{status:"valid",pinCount:{queued:s,pinning:t,pinned:r,failed:n}}}case"invalid":return{status:"invalid"};default:return{status:e.Status}}}function LR(e){async function t(t,r){const{endpoint:s,key:n,headers:i,timeout:o,signal:a}=r;await e.post("pin/remote/service/add",{timeout:o,signal:a,searchParams:fI({arg:[t,DR(s),n]}),headers:i})}return t}function xR(e){async function t(t={}){const{stat:r,headers:s,timeout:n,signal:i}=t,o=await e.post("pin/remote/service/ls",{timeout:n,signal:i,headers:s,searchParams:!0===r?fI({stat:r}):void 0}),{RemoteServices:a}=await o.json();return a.map(NR)}return t}function MR(e){async function t(t,r={}){await e.post("pin/remote/service/rm",{signal:r.signal,headers:r.headers,searchParams:fI({arg:t})})}return t}function BR(e){const t=new uI(e);return{add:LR(t),ls:xR(t),rm:MR(t)}}function UR(e){const t=new uI(e);return{add:TR(t),ls:AR(t),rm:CR(t),rmAll:PR(t),service:BR(e)}}function jR(e){return{addAll:gR(e),add:mR(e),ls:bR(e),rmAll:_R(e),rm:ER(e),remote:UR(e)}}const VR=e=>Array.isArray(e)?e.map(zR):e,zR=e=>(0,Ye.B)(FR(e)),FR=e=>z.base64url.decode(e),$R=e=>BigInt(`0x${(0,Ye.B)(z.base64url.decode(e),"base16")}`),KR=e=>z.base64url.encode((0,ze.m)(e)),HR=hI((e=>{async function t(t={}){const{Strings:r}=await(await e.post("pubsub/ls",{signal:t.signal,searchParams:fI(t),headers:t.headers})).json();return VR(r)||[]}return t})),qR=hI((e=>{async function t(t,r={}){const s=await e.post("pubsub/peers",{signal:r.signal,searchParams:fI({arg:KR(t),...r}),headers:r.headers}),{Strings:n}=await s.json();return n||[]}return t})),GR=hI((e=>{async function t(t,r,s={}){const n=fI({arg:KR(t),...s}),i=new AbortController,o=AI(i.signal,s.signal),a=await e.post("pubsub/pub",{signal:o,searchParams:n,...await RI([r],i,s.headers)});await a.text()}return t})),WR=(0,u.kg)("ipfs-http-client:pubsub:subscribe"),YR=(e,t)=>hI((e=>{async function r(r,s,n={}){let i,o;n.signal=t.subscribe(r,s,n.signal);const a=new Promise(((e,t)=>{i=e,o=t})),c=setTimeout((()=>i()),1e3);return e.post("pubsub/sub",{signal:n.signal,searchParams:fI({arg:KR(r),...n}),headers:n.headers}).catch((e=>{t.unsubscribe(r,s),o(e)})).then((e=>{clearTimeout(c),e&&(QR(e,{onMessage:e=>{s&&("function"!==typeof s?"function"===typeof s.handleEvent&&s.handleEvent(e):s(e))},onEnd:()=>t.unsubscribe(r,s),onError:n.onError}),i())})),a}return r}))(e);async function QR(e,{onMessage:t,onEnd:r,onError:s}){s=s||WR;try{for await(const r of e.ndjson())try{if(!r.from)continue;null!=r.from&&null!=r.seqno?t({type:"signed",from:(0,Ht.jE)(r.from),data:FR(r.data),sequenceNumber:$R(r.seqno),topic:zR(r.topicIDs[0]),key:FR(r.key??"u"),signature:FR(r.signature??"u")}):t({type:"unsigned",data:FR(r.data),topic:zR(r.topicIDs[0])})}catch(mu){mu.message=`Failed to parse pubsub message: ${mu.message}`,s(mu,!1,r)}}catch(mu){ZR(mu)||s(mu,!0)}finally{r()}}const ZR=e=>{switch(e.type){case"aborted":return!0;case"abort":return!0;default:return"AbortError"===e.name}},XR=(e,t)=>{async function r(e,r){t.unsubscribe(e,r)}return r};class JR{constructor(){this._subs=new Map}subscribe(e,t,r){const s=this._subs.get(e)||[];if(s.find((e=>e.handler===t)))throw new Error(`Already subscribed to ${e} with this handler`);const n=new AbortController;return this._subs.set(e,[{handler:t,controller:n}].concat(s)),r&&r.addEventListener("abort",(()=>this.unsubscribe(e,t))),n.signal}unsubscribe(e,t){const r=this._subs.get(e)||[];let s;t?(this._subs.set(e,r.filter((e=>e.handler!==t))),s=r.filter((e=>e.handler===t))):(this._subs.set(e,[]),s=r),(this._subs.get(e)||[]).length||this._subs.delete(e),s.forEach((e=>e.controller.abort()))}}function eT(e){const t=new JR;return{ls:HR(e),peers:qR(e),publish:GR(e),subscribe:YR(e,t),unsubscribe:XR(e,t)}}const tT=hI((e=>{async function*t(t={}){const r=await e.post("refs/local",{signal:t.signal,transform:zI,searchParams:fI(t),headers:t.headers});yield*r.ndjson()}return t})),rT=hI(((e,t)=>{const r=async function*(t,r={}){const s=Array.isArray(t)?t:[t],n=await e.post("refs",{signal:r.signal,searchParams:fI({arg:s.map((e=>`${e instanceof Uint8Array?A.CID.decode(e):e}`)),...r}),headers:r.headers,transform:zI});yield*n.ndjson()};return Object.assign(r,{local:tT(t)})})),sT=hI((e=>{async function*t(t={}){const r=await e.post("repo/gc",{signal:t.signal,searchParams:fI(t),headers:t.headers,transform:e=>({err:e.Error?new Error(e.Error):null,cid:(e.Key||{})["/"]?A.CID.parse(e.Key["/"]):null})});yield*r.ndjson()}return t})),nT=hI((e=>{async function t(t={}){const r=await e.post("repo/stat",{signal:t.signal,searchParams:fI(t),headers:t.headers}),s=await r.json();return{numObjects:BigInt(s.NumObjects),repoSize:BigInt(s.RepoSize),repoPath:s.RepoPath,version:s.Version,storageMax:BigInt(s.StorageMax)}}return t})),iT=hI((e=>{async function t(t={}){const r=await(await e.post("repo/version",{signal:t.signal,searchParams:fI(t),headers:t.headers})).json();return r.Version}return t}));function oT(e){return{gc:sT(e),stat:nT(e),version:iT(e)}}const aT=hI((e=>{async function*t(t={}){const r=await e.post("stats/bw",{signal:t.signal,searchParams:fI(t),headers:t.headers,transform:e=>({totalIn:BigInt(e.TotalIn),totalOut:BigInt(e.TotalOut),rateIn:parseFloat(e.RateIn),rateOut:parseFloat(e.RateOut)})});yield*r.ndjson()}return t}));function cT(e){return{bitswap:mI(e),repo:nT(e),bw:aT(e)}}const lT=hI((e=>{async function t(t={}){const r=await e.post("swarm/addrs",{signal:t.signal,searchParams:fI(t),headers:t.headers}),{Addrs:s}=await r.json();return Object.keys(s).map((e=>({id:(0,Ht.jE)(e),addrs:(s[e]||[]).map((e=>(0,qe.HM)(e)))})))}return t})),uT=hI((e=>{async function t(t,r={}){const s=await e.post("swarm/connect",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),{Strings:n}=await s.json();return n||[]}return t})),hT=hI((e=>{async function t(t,r={}){const s=await e.post("swarm/disconnect",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),{Strings:n}=await s.json();return n||[]}return t})),dT=hI((e=>{async function t(t={}){const r=await e.post("swarm/addrs/local",{signal:t.signal,searchParams:fI(t),headers:t.headers}),{Strings:s}=await r.json();return(s||[]).map((e=>(0,qe.HM)(e)))}return t})),pT=hI((e=>{async function t(t={}){const r=await e.post("swarm/peers",{signal:t.signal,searchParams:fI(t),headers:t.headers}),{Peers:s}=await r.json();return(s||[]).map((e=>({addr:(0,qe.HM)(e.Addr),peer:(0,Ht.jE)(e.Peer),muxer:e.Muxer,latency:e.Latency,streams:e.Streams,direction:null==e.Direction?void 0:0===e.Direction?"inbound":"outbound"})))}return t}));function fT(e){return{addrs:lT(e),connect:uT(e),disconnect:hT(e),localAddrs:dT(e),peers:pT(e)}}const yT=hI((e=>{async function*t(t,r={}){const s=new AbortController,n=AI(s.signal,r.signal),{headers:i,body:o,total:a,parts:c}=await RI(t,s,r.headers),[l,u]="function"===typeof r.progress?gT(a,c,r.progress):[void 0,void 0],h=await e.post("add",{searchParams:fI({"stream-channels":!0,...r,progress:Boolean(l)}),onUploadProgress:u,signal:n,headers:i,body:o});for await(let e of h.ndjson())e=zI(e),void 0!==e.hash?yield wT(e):l&&l(e.bytes||0,e.name)}return t})),gT=(e,t,r)=>t?[void 0,mT(e,t,r)]:[r,void 0],mT=(e,t,r)=>{let s=0;const n=t.length;return({loaded:i,total:o})=>{const a=Math.floor(i/o*e);while(s<n){const{start:e,end:n,name:i}=t[s];if(a<n){r(a-e,i);break}r(n-e,i),s+=1}}};function wT({name:e,hash:t,size:r,mode:s,mtime:n,mtimeNsecs:i}){const o={path:e,cid:A.CID.parse(t),size:parseInt(r)};return null!=s&&(o.mode=parseInt(s,8)),null!=n&&(o.mtime={secs:n,nsecs:i||0}),o}function bT(e){const t=yT(e);return hI((()=>{async function e(e,r={}){return await Wt(t(Xn(e),r))}return e}))(e)}const _T=hI((e=>{async function*t(t,r={}){const s=await e.post("cat",{signal:r.signal,searchParams:fI({arg:t.toString(),...r}),headers:r.headers});yield*s.iterator()}return t})),ET=hI((e=>{const t=async(t={})=>{const r=await e.post("commands",{signal:t.signal,searchParams:fI(t),headers:t.headers});return r.json()};return t})),vT=hI((e=>{const t=async(t,r={})=>{const s=await e.post("dns",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),n=await s.json();return n.Path};return t})),ST=hI((e=>()=>{const t=new URL(e.opts.base||"");return{host:t.hostname,port:t.port,protocol:t.protocol,pathname:t.pathname,"api-path":t.pathname}})),IT=hI((e=>{async function*t(t,r={}){const s={arg:`${t instanceof Uint8Array?A.CID.decode(t):t}`,...r};s.compressionLevel&&(s["compression-level"]=s.compressionLevel,delete s.compressionLevel);const n=await e.post("get",{signal:r.signal,searchParams:fI(s),headers:r.headers});yield*n.iterator()}return t})),kT=hI((e=>{async function t(t={}){const r=await e.post("id",{signal:t.signal,searchParams:fI({arg:t.peerId?t.peerId.toString():void 0,...t}),headers:t.headers}),s=await r.json(),n={...zI(s)};return n.id=(0,Ht.jE)(n.id),n.addresses&&(n.addresses=n.addresses.map((e=>(0,qe.HM)(e)))),n}return t})),RT=e=>{const t=kT(e);async function r(e={}){const r=await t(e);return Boolean(r&&r.addresses&&r.addresses.length)}return r},TT=hI(((e,t)=>{async function*r(r,s={}){const n=`${r instanceof Uint8Array?A.CID.decode(r):r}`;async function i(e){let r=e.Hash;if(r.includes("/")){const e=r.startsWith("/ipfs/")?r:`/ipfs/${r}`,s=await Lk(t)(e);r=s.cid}else r=A.CID.parse(r);const s={name:e.Name,path:n+(e.Name?`/${e.Name}`:""),size:e.Size,cid:r,type:AT(e)};return e.Mode&&(s.mode=parseInt(e.Mode,8)),void 0!==e.Mtime&&null!==e.Mtime&&(s.mtime={secs:e.Mtime},void 0!==e.MtimeNsecs&&null!==e.MtimeNsecs&&(s.mtime.nsecs=e.MtimeNsecs)),s}const o=await e.post("ls",{signal:s.signal,searchParams:fI({arg:n,...s}),headers:s.headers});for await(let e of o.ndjson()){if(e=e.Objects,!e)throw new Error("expected .Objects in results");if(e=e[0],!e)throw new Error("expected one array in results.Objects");const t=e.Links;if(!Array.isArray(t))throw new Error("expected one array in results.Objects[0].Links");if(!t.length)return void(yield i(e));yield*t.map(i)}}return r}));function AT(e){switch(e.Type){case 1:case 5:return"dir";case 2:return"file";default:return"file"}}const CT=hI((e=>{async function t(t={}){const r=await e.post("dns",{signal:t.signal,searchParams:fI(t),headers:t.headers});return zI(await r.json())}return t})),PT=hI((e=>{async function*t(t,r={}){const s=await e.post("ping",{signal:r.signal,searchParams:fI({arg:`${t}`,...r}),headers:r.headers,transform:zI});yield*s.ndjson()}return t})),DT=hI((e=>{async function t(t,r={}){const s=await e.post("resolve",{signal:r.signal,searchParams:fI({arg:t,...r}),headers:r.headers}),{Path:n}=await s.json();return n}return t})),NT=hI((e=>{const t=async(e={})=>{throw h(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")};return t})),OT=hI((e=>{async function t(t={}){const r=await e.post("shutdown",{signal:t.signal,searchParams:fI(t),headers:t.headers});await r.text()}return t})),LT=hI((e=>{async function t(t={}){const r=await e.post("version",{signal:t.signal,searchParams:fI(t),headers:t.headers});return{...zI(await r.json()),"ipfs-http-client":"1.0.0"}}return t}));r(63897);var xT=r(46953);function MT(e={}){const t={name:De.identity.name,code:De.identity.code,encode:e=>e,decode:e=>e},r=Object.values(Ne.gh);(e.ipld&&e.ipld.bases?e.ipld.bases:[]).forEach((e=>r.push(e)));const o=new GS({bases:r,loadBase:e.ipld&&e.ipld.loadBase}),a=Object.values(Ne.QB);[R,s,n,i,t].concat(e.ipld&&e.ipld.codecs||[]).forEach((e=>a.push(e)));const c=new YS({codecs:a,loadCodec:e.ipld&&e.ipld.loadCodec}),l=Object.values(Ne.kq);(e.ipld&&e.ipld.hashers?e.ipld.hashers:[]).forEach((e=>l.push(e)));const u=new ZS({hashers:l,loadHasher:e.ipld&&e.ipld.loadHasher}),h={add:bT(e),addAll:yT(e),bitswap:_I(e),block:OI(e),bootstrap:jI(e),cat:_T(e),commands:ET(e),config:YI(e),dag:rk(c,e),dht:wk(e),diag:vk(e),dns:vT(e),files:Uk(e),get:IT(e),getEndpointConfig:ST(e),id:kT(e),isOnline:RT(e),key:qk(e),log:Qk(e),ls:TT(e),mount:CT(e),name:sR(e),object:yR(c,e),pin:jR(e),ping:PT(e),pubsub:eT(e),refs:rT(e),repo:oT(e),resolve:DT(e),start:NT(e),stats:cT(e),stop:OT(e),swarm:fT(e),version:LT(e),bases:o,codecs:c,hashers:u};return h}var BT=r(75956);function UT(){const e=new BT.x,t={transports:[e],peerDiscovery:[e.discovery],connectionManager:{maxParallelDials:150,maxDialsPerPeer:4,dialTimeout:1e4,autoDial:!0},nat:{enabled:!1},metrics:{enabled:!0}};return t}var jT,VT,zT=r(57447);async function*FT(e,t){yield*As(e,(async e=>(await t.addressBook.add(e.id,e.multiaddrs),e)))}function $T(e){const t=new Set;return ms(e,(e=>!t.has(e.id.toString())&&(t.add(e.id.toString()),!0)))}async function*KT(e,t=1){let r=0;for await(const s of e)r++,yield s;if(r<t)throw h(new Error("not found"),"NOT_FOUND")}(function(e){e["NOT_STARTED_YET"]="The libp2p node is not started yet",e["DHT_DISABLED"]="DHT is not available",e["PUBSUB_DISABLED"]="PubSub is not available",e["CONN_ENCRYPTION_REQUIRED"]="At least one connection encryption module is required",e["ERR_TRANSPORTS_REQUIRED"]="At least one transport module is required",e["ERR_PROTECTOR_REQUIRED"]="Private network is enforced, but no protector was provided",e["NOT_FOUND"]="Not found"})(jT||(jT={})),function(e){e["DHT_DISABLED"]="ERR_DHT_DISABLED",e["ERR_PUBSUB_DISABLED"]="ERR_PUBSUB_DISABLED",e["PUBSUB_NOT_STARTED"]="ERR_PUBSUB_NOT_STARTED",e["DHT_NOT_STARTED"]="ERR_DHT_NOT_STARTED",e["CONN_ENCRYPTION_REQUIRED"]="ERR_CONN_ENCRYPTION_REQUIRED",e["ERR_TRANSPORTS_REQUIRED"]="ERR_TRANSPORTS_REQUIRED",e["ERR_PROTECTOR_REQUIRED"]="ERR_PROTECTOR_REQUIRED",e["ERR_PEER_DIAL_INTERCEPTED"]="ERR_PEER_DIAL_INTERCEPTED",e["ERR_CONNECTION_INTERCEPTED"]="ERR_CONNECTION_INTERCEPTED",e["ERR_INVALID_PROTOCOLS_FOR_STREAM"]="ERR_INVALID_PROTOCOLS_FOR_STREAM",e["ERR_CONNECTION_ENDED"]="ERR_CONNECTION_ENDED",e["ERR_CONNECTION_FAILED"]="ERR_CONNECTION_FAILED",e["ERR_NODE_NOT_STARTED"]="ERR_NODE_NOT_STARTED",e["ERR_ALREADY_ABORTED"]="ERR_ALREADY_ABORTED",e["ERR_TOO_MANY_ADDRESSES"]="ERR_TOO_MANY_ADDRESSES",e["ERR_NO_VALID_ADDRESSES"]="ERR_NO_VALID_ADDRESSES",e["ERR_RELAYED_DIAL"]="ERR_RELAYED_DIAL",e["ERR_DIALED_SELF"]="ERR_DIALED_SELF",e["ERR_DISCOVERED_SELF"]="ERR_DISCOVERED_SELF",e["ERR_DUPLICATE_TRANSPORT"]="ERR_DUPLICATE_TRANSPORT",e["ERR_ENCRYPTION_FAILED"]="ERR_ENCRYPTION_FAILED",e["ERR_HOP_REQUEST_FAILED"]="ERR_HOP_REQUEST_FAILED",e["ERR_INVALID_KEY"]="ERR_INVALID_KEY",e["ERR_INVALID_MESSAGE"]="ERR_INVALID_MESSAGE",e["ERR_INVALID_PARAMETERS"]="ERR_INVALID_PARAMETERS",e["ERR_INVALID_PEER"]="ERR_INVALID_PEER",e["ERR_MUXER_UNAVAILABLE"]="ERR_MUXER_UNAVAILABLE",e["ERR_NOT_FOUND"]="ERR_NOT_FOUND",e["ERR_TIMEOUT"]="ERR_TIMEOUT",e["ERR_TRANSPORT_UNAVAILABLE"]="ERR_TRANSPORT_UNAVAILABLE",e["ERR_TRANSPORT_DIAL_FAILED"]="ERR_TRANSPORT_DIAL_FAILED",e["ERR_UNSUPPORTED_PROTOCOL"]="ERR_UNSUPPORTED_PROTOCOL",e["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"]="ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED",e["ERR_INVALID_MULTIADDR"]="ERR_INVALID_MULTIADDR",e["ERR_SIGNATURE_NOT_VALID"]="ERR_SIGNATURE_NOT_VALID",e["ERR_FIND_SELF"]="ERR_FIND_SELF",e["ERR_NO_ROUTERS_AVAILABLE"]="ERR_NO_ROUTERS_AVAILABLE",e["ERR_CONNECTION_NOT_MULTIPLEXED"]="ERR_CONNECTION_NOT_MULTIPLEXED",e["ERR_NO_DIAL_TOKENS"]="ERR_NO_DIAL_TOKENS",e["ERR_KEYCHAIN_REQUIRED"]="ERR_KEYCHAIN_REQUIRED",e["ERR_INVALID_CMS"]="ERR_INVALID_CMS",e["ERR_MISSING_KEYS"]="ERR_MISSING_KEYS",e["ERR_NO_KEY"]="ERR_NO_KEY",e["ERR_INVALID_KEY_NAME"]="ERR_INVALID_KEY_NAME",e["ERR_INVALID_KEY_TYPE"]="ERR_INVALID_KEY_TYPE",e["ERR_KEY_ALREADY_EXISTS"]="ERR_KEY_ALREADY_EXISTS",e["ERR_INVALID_KEY_SIZE"]="ERR_INVALID_KEY_SIZE",e["ERR_KEY_NOT_FOUND"]="ERR_KEY_NOT_FOUND",e["ERR_OLD_KEY_NAME_INVALID"]="ERR_OLD_KEY_NAME_INVALID",e["ERR_NEW_KEY_NAME_INVALID"]="ERR_NEW_KEY_NAME_INVALID",e["ERR_PASSWORD_REQUIRED"]="ERR_PASSWORD_REQUIRED",e["ERR_PEM_REQUIRED"]="ERR_PEM_REQUIRED",e["ERR_CANNOT_READ_KEY"]="ERR_CANNOT_READ_KEY",e["ERR_MISSING_PRIVATE_KEY"]="ERR_MISSING_PRIVATE_KEY",e["ERR_MISSING_PUBLIC_KEY"]="ERR_MISSING_PUBLIC_KEY",e["ERR_INVALID_OLD_PASS_TYPE"]="ERR_INVALID_OLD_PASS_TYPE",e["ERR_INVALID_NEW_PASS_TYPE"]="ERR_INVALID_NEW_PASS_TYPE",e["ERR_INVALID_PASS_LENGTH"]="ERR_INVALID_PASS_LENGTH",e["ERR_NOT_IMPLEMENTED"]="ERR_NOT_IMPLEMENTED",e["ERR_WRONG_PING_ACK"]="ERR_WRONG_PING_ACK",e["ERR_INVALID_RECORD"]="ERR_INVALID_RECORD",e["ERR_ALREADY_SUCCEEDED"]="ERR_ALREADY_SUCCEEDED",e["ERR_NO_HANDLER_FOR_PROTOCOL"]="ERR_NO_HANDLER_FOR_PROTOCOL",e["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"]="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS",e["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"]="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"}(VT||(VT={}));var HT=r(27695),qT=r(17187);const GT=(0,u.kg)("libp2p:peer-routing");class WT{constructor(e,t){this.components=e,this.routers=t.routers,this.refreshManagerInit=t.refreshManager??{},this.started=!1,this._findClosestPeersTask=this._findClosestPeersTask.bind(this)}isStarted(){return this.started}async start(){this.started||0===this.routers.length||null!=this.timeoutId||!1===this.refreshManagerInit.enabled||(this.timeoutId=(0,HT.setDelayedInterval)(this._findClosestPeersTask,this.refreshManagerInit.interval,this.refreshManagerInit.bootDelay),this.started=!0)}async _findClosestPeersTask(){if(null==this.abortController)try{this.abortController=new Fe.TimeoutController(this.refreshManagerInit.timeout??1e4);try{(0,qT.setMaxListeners)?.(1/0,this.abortController.signal)}catch{}await gs(this.getClosestPeers(this.components.getPeerId().toBytes(),{signal:this.abortController.signal}))}catch(mu){GT.error(mu)}finally{this.abortController?.clear(),this.abortController=void 0}}async stop(){(0,HT.clearDelayedInterval)(this.timeoutId),this.abortController?.abort(),this.started=!1}async findPeer(e,t){if(0===this.routers.length)throw h(new Error("No peer routers available"),VT.ERR_NO_ROUTERS_AVAILABLE);if(e.toString()===this.components.getPeerId().toString())throw h(new Error("Should not try to find self"),VT.ERR_FIND_SELF);const r=await(0,Cs.zG)(Ps(...this.routers.map((r=>async function*(){try{yield await r.findPeer(e,t)}catch(mu){GT.error(mu)}}()))),(e=>ms(e,Boolean)),(e=>FT(e,this.components.getPeerStore())),(async e=>await sy(e)));if(null!=r)return r;throw h(new Error(jT.NOT_FOUND),VT.ERR_NOT_FOUND)}async*getClosestPeers(e,t){if(0===this.routers.length)throw h(new Error("No peer routers available"),VT.ERR_NO_ROUTERS_AVAILABLE);yield*(0,Cs.zG)(Ps(...this.routers.map((r=>r.getClosestPeers(e,t)))),(e=>FT(e,this.components.getPeerStore())),(e=>$T(e)),(e=>KT(e)))}}class YT{constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(0===this.routers.length)throw h(new Error("No content this.routers available"),VT.ERR_NO_ROUTERS_AVAILABLE);yield*(0,Cs.zG)(Ps(...this.routers.map((r=>r.findProviders(e,t)))),(e=>FT(e,this.components.getPeerStore())),(e=>$T(e)),(e=>KT(e)))}async provide(e,t={}){if(0===this.routers.length)throw h(new Error("No content routers available"),VT.ERR_NO_ROUTERS_AVAILABLE);await Promise.all(this.routers.map((async r=>await r.provide(e,t))))}async put(e,t,r){if(!this.isStarted())throw h(new Error(jT.NOT_STARTED_YET),VT.DHT_NOT_STARTED);const s=this.components.getDHT();null!=s&&await gs(s.put(e,t,r))}async get(e,t){if(!this.isStarted())throw h(new Error(jT.NOT_STARTED_YET),VT.DHT_NOT_STARTED);const r=this.components.getDHT();if(null!=r)for await(const s of r.get(e,t))if("VALUE"===s.name)return s.value;throw h(new Error(jT.NOT_FOUND),VT.ERR_NOT_FOUND)}async*getMany(e,t,r){if(!this.isStarted())throw h(new Error(jT.NOT_STARTED_YET),VT.DHT_NOT_STARTED);if(null==t||0===t)return;let s=0;const n=this.components.getDHT();if(null!=n)for await(const i of n.get(e,r))if("VALUE"===i.name&&(yield{from:i.from,val:i.value},s++,s===t))break;if(0===s)throw h(new Error(jT.NOT_FOUND),VT.ERR_NOT_FOUND)}}function QT(e){const t=e.getPeerId();if(null==t)throw h(new Error(`${e.toString()} does not have a valid peer type`),VT.ERR_INVALID_MULTIADDR);try{return(0,Ht.jE)(t)}catch(mu){throw h(new Error(`${e.toString()} is not a valid peer type`),VT.ERR_INVALID_MULTIADDR)}}function ZT(e){if((0,ir.I)(e))return{id:e,multiaddrs:[],protocols:[]};let t;return"string"===typeof e&&(e=(0,qe.HM)(e)),(0,qe.h2)(e)&&(t=e,e=QT(e)),{id:e,multiaddrs:null!=t?[t]:[],protocols:[]}}const XT=e=>e;class JT extends HE.v{constructor(e,t){super();const{listen:r=[],announce:s=[]}=t;this.components=e,this.listen=new Set(r.map((e=>e.toString()))),this.announce=new Set(s.map((e=>e.toString()))),this.observed=new Set,this.announceFilter=t.announceFilter??XT}getListenAddrs(){return Array.from(this.listen).map((e=>(0,qe.HM)(e)))}getAnnounceAddrs(){return Array.from(this.announce).map((e=>(0,qe.HM)(e)))}getObservedAddrs(){return Array.from(this.observed).map((e=>(0,qe.HM)(e)))}addObservedAddr(e){let t=(0,qe.HM)(e);const r=t.getPeerId();if(null!=r){const e=(0,Ht.jE)(r);e.equals(this.components.getPeerId())&&(t=t.decapsulate((0,qe.HM)(`/p2p/${this.components.getPeerId().toString()}`)))}const s=t.toString();this.observed.has(s)||(this.observed.add(s),this.dispatchEvent(new HE.A("change:addresses")))}getAddresses(){let e=this.getAnnounceAddrs().map((e=>e.toString()));0===e.length&&(e=this.components.getTransportManager().getAddrs().map((e=>e.toString()))),e=e.concat(this.getObservedAddrs().map((e=>e.toString())));const t=new Set(e);return this.announceFilter(Array.from(t).map((e=>(0,qe.HM)(e)))).map((e=>e.getPeerId()===this.components.getPeerId().toString()?e:e.encapsulate(`/p2p/${this.components.getPeerId().toString()}`)))}}const eA=(0,u.kg)("libp2p:connection-manager:latency-monitor:visibility-change-emitter");class tA extends HE.v{constructor(){super(),this.hidden="hidden",this.visibilityChange="visibilityChange",null!=globalThis.document&&(this._initializeVisibilityVarNames(),this._addVisibilityChangeListener())}_initializeVisibilityVarNames(){let e="hidden",t="visibilitychange";"undefined"!==typeof globalThis.document.hidden?(e="hidden",t="visibilitychange"):"undefined"!==typeof globalThis.document.mozHidden?(e="mozHidden",t="mozvisibilitychange"):"undefined"!==typeof globalThis.document.msHidden?(e="msHidden",t="msvisibilitychange"):"undefined"!==typeof globalThis.document.webkitHidden&&(e="webkitHidden",t="webkitvisibilitychange"),this.hidden=e,this.visibilityChange=t}_addVisibilityChangeListener(){"undefined"===typeof globalThis.document.addEventListener||"undefined"===typeof document[this.hidden]?eA("Checking page visibility requires a browser that supports the Page Visibility API."):globalThis.document.addEventListener(this.visibilityChange,this._handleVisibilityChange.bind(this),!1)}isVisible(){if(void 0!==this.hidden&&void 0!==document[this.hidden])return null==document[this.hidden]}_handleVisibilityChange(){const e=!1===globalThis.document[this.hidden];eA(e?"Page Visible":"Page Hidden"),this.dispatchEvent(new HE.A("visibilityChange",{detail:e}))}}const rA=(0,u.kg)("libp2p:connection-manager:latency-monitor");class sA extends HE.v{constructor(e={}){super();const{latencyCheckIntervalMs:t,dataEmitIntervalMs:r,asyncTestFn:s,latencyRandomPercentage:n}=e;this.latencyCheckIntervalMs=t??500,this.latencyRandomPercentage=n??10,this.latencyCheckMultiply=this.latencyRandomPercentage/100*2*this.latencyCheckIntervalMs,this.latencyCheckSubtract=this.latencyCheckMultiply/2,this.dataEmitIntervalMs=null===r||0===r?void 0:r??5e3,rA("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s",this.latencyCheckIntervalMs,this.dataEmitIntervalMs),null!=this.dataEmitIntervalMs?rA("Expecting ~%s events per summary",this.latencyCheckIntervalMs/this.dataEmitIntervalMs):rA("Not emitting summaries"),this.asyncTestFn=s,null!=globalThis.process?.hrtime?(rA("Using process.hrtime for timing"),this.now=globalThis.process.hrtime,this.getDeltaMS=e=>{const t=this.now(e);return 1e3*t[0]+t[1]/1e6}):"undefined"!==typeof window&&null!=window.performance?.now?(rA("Using performance.now for timing"),this.now=window.performance.now.bind(window.performance),this.getDeltaMS=e=>Math.round(this.now()-e)):(rA("Using Date.now for timing"),this.now=Date.now,this.getDeltaMS=e=>this.now()-e),this.latencyData=this.initLatencyData()}start(){nA()&&(this.visibilityChangeEmitter=new tA,this.visibilityChangeEmitter.addEventListener("visibilityChange",(e=>{const{detail:t}=e;t?this._startTimers():(this._emitSummary(),this._stopTimers())}))),!0===this.visibilityChangeEmitter?.isVisible()&&this._startTimers()}stop(){this._stopTimers()}_startTimers(){null==this.checkLatencyID&&(this.checkLatency(),null!=this.dataEmitIntervalMs&&(this.emitIntervalID=setInterval((()=>this._emitSummary()),this.dataEmitIntervalMs),"function"===typeof this.emitIntervalID.unref&&this.emitIntervalID.unref()))}_stopTimers(){null!=this.checkLatencyID&&(clearTimeout(this.checkLatencyID),this.checkLatencyID=void 0),null!=this.emitIntervalID&&(clearInterval(this.emitIntervalID),this.emitIntervalID=void 0)}_emitSummary(){const e=this.getSummary();e.events>0&&this.dispatchEvent(new HE.A("data",{detail:e}))}getSummary(){const e={events:this.latencyData.events,minMs:this.latencyData.minMs,maxMs:this.latencyData.maxMs,avgMs:this.latencyData.events>0?this.latencyData.totalMs/this.latencyData.events:Number.POSITIVE_INFINITY,lengthMs:this.getDeltaMS(this.latencyData.startTime)};return this.latencyData=this.initLatencyData(),rA.trace("Summary: %O",e),e}checkLatency(){const e=Math.random()*this.latencyCheckMultiply-this.latencyCheckSubtract,t={deltaOffset:Math.ceil(this.latencyCheckIntervalMs+e),startTime:this.now()},r=()=>{if(null==this.checkLatencyID)return;const e=this.getDeltaMS(t.startTime)-t.deltaOffset;this.checkLatency(),this.latencyData.events++,this.latencyData.minMs=Math.min(this.latencyData.minMs,e),this.latencyData.maxMs=Math.max(this.latencyData.maxMs,e),this.latencyData.totalMs+=e,rA.trace("MS: %s Data: %O",e,this.latencyData)};rA.trace("localData: %O",t),this.checkLatencyID=setTimeout((()=>{null!=this.asyncTestFn?(t.deltaOffset=0,t.startTime=this.now(),this.asyncTestFn(r)):(t.deltaOffset-=1,r())}),t.deltaOffset),"function"===typeof this.checkLatencyID.unref&&this.checkLatencyID.unref()}initLatencyData(){return{startTime:this.now(),minMs:Number.POSITIVE_INFINITY,maxMs:Number.NEGATIVE_INFINITY,events:0,totalMs:0}}}function nA(){return"undefined"!==typeof globalThis.window}var iA=r(82916);const oA="OPEN",aA="CLOSING",cA="CLOSED";function lA(e,t){const r={[Symbol.iterator]:()=>r,next:()=>{const r=e.next(),s=r.value;if(!0===r.done||null==s){const e={done:!0,value:void 0};return e}return{done:!1,value:t(s)}}};return r}class uA{constructor(e){if(this.map=new Map,null!=e)for(const[t,r]of e.entries())this.map.set(t.toString(),r)}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){this.map.delete(e.toString())}entries(){return lA(this.map.entries(),(e=>[(0,Ht.jE)(e[0]),e[1]]))}forEach(e){this.map.forEach(((t,r)=>{e(t,(0,Ht.jE)(r),this)}))}get(e){return this.map.get(e.toString())}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),t)}keys(){return lA(this.map.keys(),(e=>(0,Ht.jE)(e)))}values(){return this.map.values()}get size(){return this.map.size}}class hA{constructor(e){if(this.set=new Set,null!=e)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return lA(this.set.entries(),(e=>{const t=(0,Ht.jE)(e[0]);return[t,t]}))}forEach(e){this.set.forEach((t=>{const r=(0,Ht.jE)(t);e(r,r,this)}))}has(e){return this.set.has(e.toString())}values(){return lA(this.set.values(),(e=>(0,Ht.jE)(e)))}}class dA{constructor(e){if(this.list=[],null!=e)for(const t of e)this.list.push(t.toString())}[Symbol.iterator](){return mapIterable(this.list.entries(),(e=>peerIdFromString(e[1])))}concat(e){const t=new dA(this);for(const r of e)t.push(r);return t}entries(){return mapIterable(this.list.entries(),(e=>[e[0],peerIdFromString(e[1])]))}every(e){return this.list.every(((t,r)=>e(peerIdFromString(t),r,this)))}filter(e){const t=new dA;return this.list.forEach(((r,s)=>{const n=peerIdFromString(r);e(n,s,this)&&t.push(n)})),t}find(e){const t=this.list.find(((t,r)=>e(peerIdFromString(t),r,this)));if(null!=t)return peerIdFromString(t)}findIndex(e){return this.list.findIndex(((t,r)=>e(peerIdFromString(t),r,this)))}forEach(e){this.list.forEach(((t,r)=>{e(peerIdFromString(t),r,this)}))}includes(e){return this.list.includes(e.toString())}indexOf(e){return this.list.indexOf(e.toString())}pop(){const e=this.list.pop();if(null!=e)return peerIdFromString(e)}push(...e){for(const t of e)this.list.push(t.toString())}shift(){const e=this.list.shift();if(null!=e)return peerIdFromString(e)}unshift(...e){let t=this.list.length;for(let r=e.length-1;r>-1;r--)this.list.unshift(e[r].toString());return t}get length(){return this.list.length}}const pA="keep-alive",fA=(0,u.kg)("libp2p:connection-manager"),yA={maxConnections:1/0,minConnections:0,maxData:1/0,maxSentData:1/0,maxReceivedData:1/0,maxEventLoopDelay:1/0,pollInterval:2e3,autoDialInterval:1e4,movingAverageInterval:6e4},gA="libp2p",mA="connection-manager",wA=6e4;class bA extends HE.v{constructor(e){if(super(),this.components=new nS.z,this.opts=c.Z.call({ignoreUndefined:!0},yA,e),this.opts.maxConnections<this.opts.minConnections)throw h(new Error("Connection Manager maxConnections must be greater than minConnections"),VT.ERR_INVALID_PARAMETERS);fA("options: %o",this.opts),this.connections=new Map,this.started=!1,this._checkMetrics=this._checkMetrics.bind(this),this.latencyMonitor=new sA({latencyCheckIntervalMs:e.pollInterval,dataEmitIntervalMs:e.pollInterval});try{(0,qT.setMaxListeners)?.(1/0,this)}catch{}this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.startupReconnectTimeout=e.startupReconnectTimeout??wA,this.dialTimeout=e.dialTimeout??3e4}init(e){this.components=e,this.components.getMetrics()?.updateComponentMetric({system:gA,component:mA,metric:"connections",label:"direction",value:()=>{const e={inbound:0,outbound:0};for(const t of this.connections.values())for(const r of t)"inbound"===r.stat.direction?e.inbound++:e.outbound++;return e}}),this.components.getMetrics()?.updateComponentMetric({system:gA,component:mA,metric:"protocol-streams-total",label:"protocol",value:()=>{const e={};for(const t of this.connections.values())for(const r of t)for(const t of r.streams){const r=`${t.stat.direction} ${t.stat.protocol??"unnegotiated"}`;e[r]=(e[r]??0)+1}return e}}),this.components.getMetrics()?.updateComponentMetric({system:gA,component:mA,metric:"protocol-streams-per-connection-90th-percentile",label:"protocol",value:()=>{const e={};for(const r of this.connections.values())for(const t of r){const r={};for(const e of t.streams){const t=`${e.stat.direction} ${e.stat.protocol??"unnegotiated"}`;r[t]=(r[t]??0)+1}for(const[t,s]of Object.entries(r))e[t]=e[t]??[],e[t].push(s)}const t={};for(let[r,s]of Object.entries(e)){s=s.sort(((e,t)=>e-t));const e=Math.floor(.9*s.length);t[r]=s[e]}return t}})}isStarted(){return this.started}async start(){null!=this.components.getMetrics()&&(this.timer=this.timer??iA(this._checkMetrics,this.opts.pollInterval)),this.latencyMonitor.start(),this._onLatencyMeasure=this._onLatencyMeasure.bind(this),this.latencyMonitor.addEventListener("data",this._onLatencyMeasure),this.started=!0,fA("started")}async afterStart(){this.components.getUpgrader().addEventListener("connection",this.onConnect),this.components.getUpgrader().addEventListener("connectionEnd",this.onDisconnect),Promise.resolve().then((async()=>{const e=[];for(const t of await this.components.getPeerStore().all()){const r=await this.components.getPeerStore().getTags(t.id),s=r.filter((e=>e.name===pA)).length>0;s&&e.push(t.id)}this.connectOnStartupController?.clear(),this.connectOnStartupController=new Fe.TimeoutController(this.startupReconnectTimeout);try{(0,qT.setMaxListeners)?.(1/0,this.connectOnStartupController.signal)}catch{}await Promise.all(e.map((async e=>{await this.openConnection(e,{signal:this.connectOnStartupController?.signal}).catch((e=>{fA.error(e)}))})))})).catch((e=>{fA.error(e)})).finally((()=>{this.connectOnStartupController?.clear()}))}async beforeStop(){this.connectOnStartupController?.abort(),this.components.getUpgrader().removeEventListener("connection",this.onConnect),this.components.getUpgrader().removeEventListener("connectionEnd",this.onDisconnect)}async stop(){this.timer?.clear(),this.latencyMonitor.removeEventListener("data",this._onLatencyMeasure),this.latencyMonitor.stop(),this.started=!1,await this._close(),fA("stopped")}async _close(){const e=[];for(const t of this.connections.values())for(const r of t)e.push((async()=>{try{await r.close()}catch(mu){fA.error(mu)}})());fA("closing %d connections",e.length),await Promise.all(e),this.connections.clear()}async _checkMetrics(){const e=this.components.getMetrics();if(null!=e)try{const t=e.getGlobal().getMovingAverages(),r=t.dataReceived[this.opts.movingAverageInterval].movingAverage;await this._checkMaxLimit("maxReceivedData",r);const s=t.dataSent[this.opts.movingAverageInterval].movingAverage;await this._checkMaxLimit("maxSentData",s);const n=r+s;await this._checkMaxLimit("maxData",n),fA.trace("metrics update",n)}finally{this.timer=iA(this._checkMetrics,this.opts.pollInterval)}}onConnect(e){this._onConnect(e).catch((e=>{fA.error(e)}))}async _onConnect(e){const{detail:t}=e;if(!this.started)return void await t.close();const r=t.remotePeer,s=r.toString(),n=this.connections.get(s);null!=n?n.push(t):this.connections.set(s,[t]),null!=r.publicKey&&await this.components.getPeerStore().keyBook.set(r,r.publicKey);const i=this.getConnections().length,o=i-this.opts.maxConnections;await this._checkMaxLimit("maxConnections",i,o),this.dispatchEvent(new HE.A("peer:connect",{detail:t}))}onDisconnect(e){const{detail:t}=e;if(!this.started)return;const r=t.remotePeer.toString();let s=this.connections.get(r);null!=s&&s.length>1?(s=s.filter((e=>e.id!==t.id)),this.connections.set(r,s)):null!=s&&(this.connections.delete(r),this.dispatchEvent(new HE.A("peer:disconnect",{detail:t})),this.components.getMetrics()?.onPeerDisconnected(t.remotePeer))}getConnections(e){if(null!=e)return this.connections.get(e.toString())??[];let t=[];for(const r of this.connections.values())t=t.concat(r);return t}async openConnection(e,t={}){fA("dial to %p",e);const r=this.getConnections(e);if(r.length>0)return fA("had an existing connection to %p",e),r[0];let s;if(null==t?.signal){s=new Fe.TimeoutController(this.dialTimeout),t.signal=s.signal;try{(0,qT.setMaxListeners)?.(1/0,s.signal)}catch{}}try{const r=await this.components.getDialer().dial(e,t);let n=this.connections.get(e.toString());null==n&&(n=[],this.connections.set(e.toString(),n));let i=!1;for(const e of n)e.id===r.id&&(i=!0);return i||n.push(r),r}finally{null!=s&&s.clear()}}async closeConnections(e){const t=this.connections.get(e.toString())??[];await Promise.all(t.map((async e=>await e.close())))}getAll(e){if(!(0,ir.I)(e))throw h(new Error("peerId must be an instance of peer-id"),VT.ERR_INVALID_PARAMETERS);const t=e.toString(),r=this.connections.get(t);return null!=r?r.filter((e=>e.stat.status===oA)):[]}_onLatencyMeasure(e){const{detail:t}=e;this._checkMaxLimit("maxEventLoopDelay",t.avgMs,1).catch((e=>{fA.error(e)}))}async _checkMaxLimit(e,t,r=1){const s=this.opts[e];fA.trace("checking limit of %s. current value: %d of %d",e,t,s),t>s&&(fA("%s: limit exceeded: %p, %d/%d, pruning %d connection(s)",this.components.getPeerId(),e,t,s,r),await this._maybePruneConnections(r))}async _maybePruneConnections(e){const t=this.getConnections();if(t.length<=this.opts.minConnections||e<1)return;const r=new uA;for(const i of t){const e=i.remotePeer;if(r.has(e))continue;const t=await this.components.getPeerStore().getTags(e);r.set(e,t.reduce(((e,t)=>e+t.value),0))}const s=t.sort(((e,t)=>{const s=r.get(e.remotePeer)??0,n=r.get(t.remotePeer)??0;return s>n?1:s<n?-1:0})),n=[];for(const i of s)if(fA("too many connections open - closing a connection to %p",i.remotePeer),n.push(i),n.length===e)break;await Promise.all(n.map((async e=>{try{await e.close()}catch(mu){fA.error(mu)}this.onDisconnect(new HE.A("connectionEnd",{detail:e}))})))}}const _A=(0,u.kg)("libp2p:connection-manager:auto-dialler"),EA={enabled:!0,minConnections:0,autoDialInterval:1e4};class vA{constructor(e,t){this.components=e,this.options=c.Z.call({ignoreUndefined:!0},EA,t),this.running=!1,this._autoDial=this._autoDial.bind(this),_A("options: %j",this.options)}isStarted(){return this.running}async start(){this.options.enabled?(this.running=!0,this._autoDial().catch((e=>{_A.error("could start autodial",e)})),_A("started")):_A("not enabled")}async stop(){this.options.enabled?(this.running=!1,null!=this.autoDialTimeout&&this.autoDialTimeout.clear(),_A("stopped")):_A("not enabled")}async _autoDial(){null!=this.autoDialTimeout&&this.autoDialTimeout.clear();const e=this.options.minConnections;if(this.components.getConnectionManager().getConnections().length>=e)return void(this.autoDialTimeout=iA(this._autoDial,this.options.autoDialInterval));const t=await this.components.getPeerStore().all(),r=await(0,Cs.zG)(t.sort((()=>Math.random()>.5?1:-1)),(e=>ms(e,(e=>!e.id.equals(this.components.getPeerId())))),(e=>_E(e,((e,t)=>t.protocols.length>e.protocols.length||null!=t.id.publicKey&&null==e.id.publicKey?1:-1))),(async e=>await fs(e)));for(let s=0;this.running&&s<r.length&&this.components.getConnectionManager().getConnections().length<e;s++){if(!this.running)return;const e=r[s];if(0===this.components.getConnectionManager().getConnections(e.id).length){_A("connecting to a peerStore stored peer %p",e.id);try{await this.components.getConnectionManager().openConnection(e.id)}catch(mu){_A.error("could not connect to peerStore stored peer",mu)}}}this.running&&(this.autoDialTimeout=iA(this._autoDial,this.options.autoDialInterval))}}var SA;(function(e){let t,r,s,n,i,o;(function(e){e["SUCCESS"]="SUCCESS",e["HOP_SRC_ADDR_TOO_LONG"]="HOP_SRC_ADDR_TOO_LONG",e["HOP_DST_ADDR_TOO_LONG"]="HOP_DST_ADDR_TOO_LONG",e["HOP_SRC_MULTIADDR_INVALID"]="HOP_SRC_MULTIADDR_INVALID",e["HOP_DST_MULTIADDR_INVALID"]="HOP_DST_MULTIADDR_INVALID",e["HOP_NO_CONN_TO_DST"]="HOP_NO_CONN_TO_DST",e["HOP_CANT_DIAL_DST"]="HOP_CANT_DIAL_DST",e["HOP_CANT_OPEN_DST_STREAM"]="HOP_CANT_OPEN_DST_STREAM",e["HOP_CANT_SPEAK_RELAY"]="HOP_CANT_SPEAK_RELAY",e["HOP_CANT_RELAY_TO_SELF"]="HOP_CANT_RELAY_TO_SELF",e["STOP_SRC_ADDR_TOO_LONG"]="STOP_SRC_ADDR_TOO_LONG",e["STOP_DST_ADDR_TOO_LONG"]="STOP_DST_ADDR_TOO_LONG",e["STOP_SRC_MULTIADDR_INVALID"]="STOP_SRC_MULTIADDR_INVALID",e["STOP_DST_MULTIADDR_INVALID"]="STOP_DST_MULTIADDR_INVALID",e["STOP_RELAY_REFUSED"]="STOP_RELAY_REFUSED",e["MALFORMED_MESSAGE"]="MALFORMED_MESSAGE"})(t=e.Status||(e.Status={})),function(e){e[e["SUCCESS"]=100]="SUCCESS",e[e["HOP_SRC_ADDR_TOO_LONG"]=220]="HOP_SRC_ADDR_TOO_LONG",e[e["HOP_DST_ADDR_TOO_LONG"]=221]="HOP_DST_ADDR_TOO_LONG",e[e["HOP_SRC_MULTIADDR_INVALID"]=250]="HOP_SRC_MULTIADDR_INVALID",e[e["HOP_DST_MULTIADDR_INVALID"]=251]="HOP_DST_MULTIADDR_INVALID",e[e["HOP_NO_CONN_TO_DST"]=260]="HOP_NO_CONN_TO_DST",e[e["HOP_CANT_DIAL_DST"]=261]="HOP_CANT_DIAL_DST",e[e["HOP_CANT_OPEN_DST_STREAM"]=262]="HOP_CANT_OPEN_DST_STREAM",e[e["HOP_CANT_SPEAK_RELAY"]=270]="HOP_CANT_SPEAK_RELAY",e[e["HOP_CANT_RELAY_TO_SELF"]=280]="HOP_CANT_RELAY_TO_SELF",e[e["STOP_SRC_ADDR_TOO_LONG"]=320]="STOP_SRC_ADDR_TOO_LONG",e[e["STOP_DST_ADDR_TOO_LONG"]=321]="STOP_DST_ADDR_TOO_LONG",e[e["STOP_SRC_MULTIADDR_INVALID"]=350]="STOP_SRC_MULTIADDR_INVALID",e[e["STOP_DST_MULTIADDR_INVALID"]=351]="STOP_DST_MULTIADDR_INVALID",e[e["STOP_RELAY_REFUSED"]=390]="STOP_RELAY_REFUSED",e[e["MALFORMED_MESSAGE"]=400]="MALFORMED_MESSAGE"}(r||(r={})),function(e){e.codec=()=>(0,Sr.Ji)(r)}(t=e.Status||(e.Status={})),function(e){e["HOP"]="HOP",e["STOP"]="STOP",e["STATUS"]="STATUS",e["CAN_HOP"]="CAN_HOP"}(s=e.Type||(e.Type={})),function(e){e[e["HOP"]=1]="HOP",e[e["STOP"]=2]="STOP",e[e["STATUS"]=3]="STATUS",e[e["CAN_HOP"]=4]="CAN_HOP"}(n||(n={})),function(e){e.codec=()=>(0,Sr.Ji)(n)}(s=e.Type||(e.Type={})),function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.id)throw new Error('Protocol error: required field "id" was not found in object');if(t.uint32(10),t.bytes(e.id),null==e.addrs)throw new Error('Protocol error: required field "addrs" was not found in object');for(const s of e.addrs)t.uint32(18),t.bytes(s);!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.id=e.bytes();break;case 2:r.addrs=r.addrs??[],r.addrs.push(e.bytes());break;default:e.skipType(7&t);break}}if(r.addrs=r.addrs??[],null==r.id)throw new Error('Protocol error: value for required field "id" was not found in protobuf');if(null==r.addrs)throw new Error('Protocol error: value for required field "addrs" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())}(i=e.Peer||(e.Peer={})),e.codec=()=>(null==o&&(o=(0,Sr.yw)(((t,r,s={})=>{!1!==s.lengthDelimited&&r.fork(),null!=t.type&&(r.uint32(8),e.Type.codec().encode(t.type,r)),null!=t.srcPeer&&(r.uint32(18),e.Peer.codec().encode(t.srcPeer,r)),null!=t.dstPeer&&(r.uint32(26),e.Peer.codec().encode(t.dstPeer,r)),null!=t.code&&(r.uint32(32),e.Status.codec().encode(t.code,r)),!1!==s.lengthDelimited&&r.ldelim()}),((t,r)=>{const s={},n=null==r?t.len:t.pos+r;while(t.pos<n){const r=t.uint32();switch(r>>>3){case 1:s.type=e.Type.codec().decode(t);break;case 2:s.srcPeer=e.Peer.codec().decode(t,t.uint32());break;case 3:s.dstPeer=e.Peer.codec().decode(t,t.uint32());break;case 4:s.code=e.Status.codec().decode(t);break;default:t.skipType(7&r);break}}return s}))),o),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(SA||(SA={}));class IA extends Error{constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}}function kA(e){if(null!=e){if("function"===typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"===typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"===typeof e.next)return e}throw new Error("argument is not an iterator or iterable")}function RA(e,t,r){const s=r??{},n=kA(e);async function*i(){let r;const i=()=>{null!=r&&r()};t.addEventListener("abort",i);while(1){let o;try{if(t.aborted){const{abortMessage:e,abortCode:t}=s;throw new IA(e,t)}const e=new Promise(((e,t)=>{r=()=>{const{abortMessage:e,abortCode:r}=s;t(new IA(e,r))}}));o=await Promise.race([e,n.next()]),r=null}catch(mu){t.removeEventListener("abort",i);const o="aborted"===mu.type&&t.aborted;if(o&&null!=s.onAbort&&await s.onAbort(e),"function"===typeof n.return)try{const e=n.return();e instanceof Promise&&e.catch((e=>{null!=s.onReturnError&&s.onReturnError(e)}))}catch(mu){null!=s.onReturnError&&s.onReturnError(mu)}if(o&&!0===s.returnOnAbort)return;throw mu}if(!0===o.done)break;yield o.value}t.removeEventListener("abort",i)}return i()}const TA=(0,u.kg)("libp2p:stream:converter");function AA(e,t={}){const{stream:r,remoteAddr:s}=e,{sink:n,source:i}=r,o=async function*(){for await(const e of i)yield*e}(),a={async sink(e){null!=t.signal&&(e=RA(e,t.signal));try{await n(e),await c()}catch(mu){"aborted"!==mu.type&&TA(mu)}},source:null!=t.signal?RA(o,t.signal):o,remoteAddr:s,timeline:{open:Date.now(),close:void 0},async close(){await n(async function*(){yield new Uint8Array(0)}()),await c()}};async function c(){return null==a.timeline.close&&(a.timeline.close=Date.now()),await Promise.resolve()}return a}const CA="/libp2p/circuit/relay/0.1.0";function PA(e){const t=new Map;async function r(r){const s=r.toString().split("/p2p-circuit").find((e=>""!==e)),i=(0,qe.HM)(s),o=i.getPeerId();if(null==o)throw new Error("Could not determine relay peer from multiaddr");const a=(0,Ht.jE)(o);await e.peerStore.addressBook.add(a,[i]);const c=await e.connectionManager.openConnection(a),l=c.remoteAddr.encapsulate("/p2p-circuit");t.set(c.remotePeer.toString(),l),n.dispatchEvent(new HE.A("listening"))}function s(){const e=[];for(const r of t.values())e.push(r);return e}const n=Object.assign(new HE.v,{close:async()=>await Promise.resolve(),listen:r,getAddrs:s});return e.connectionManager.addEventListener("peer:disconnect",(e=>{const{detail:r}=e,s=t.delete(r.remotePeer.toString());s&&n.dispatchEvent(new HE.A("close"))})),n}function DA(e,t){e.write({type:SA.Type.STATUS,code:t})}function NA(e,t){try{null!=e.dstPeer?.addrs&&e.dstPeer.addrs.forEach((e=>(0,qe.HM)(e)))}catch(mu){throw DA(t,e.type===SA.Type.HOP?SA.Status.HOP_DST_MULTIADDR_INVALID:SA.Status.STOP_DST_MULTIADDR_INVALID),mu}try{null!=e.srcPeer?.addrs&&e.srcPeer.addrs.forEach((e=>(0,qe.HM)(e)))}catch(mu){throw DA(t,e.type===SA.Type.HOP?SA.Status.HOP_SRC_MULTIADDR_INVALID:SA.Status.STOP_SRC_MULTIADDR_INVALID),mu}}var OA=r(51816);const LA=(0,u.kg)("libp2p:circuit:stream-handler");class xA{constructor(e){const{stream:t,maxLength:r=4096}=e;this.stream=t,this.shake=(0,OA.Y)(this.stream),this.decoder=PS.J.fromReader(this.shake.reader,{maxDataLength:r})}async read(){const e=await this.decoder.next();if(null!=e.value){const t=SA.decode(e.value);return LA("read message type",t.type),t}LA("read received no value, closing stream"),this.close()}write(e){LA("write message type %s",e.type),this.shake.write(PS.c.single(SA.encode(e)))}rest(){return this.shake.rest(),this.shake.stream}end(e){this.write(e),this.close()}close(){LA("closing the stream"),this.rest().sink([]).catch((e=>{LA.error(e)}))}}const MA=(0,u.kg)("libp2p:circuit:stop");function BA(e){const{connection:t,request:r,streamHandler:s}=e;try{NA(r,s)}catch(mu){return void MA.error("invalid stop request via peer %p %o",t.remotePeer,mu)}return MA("stop request is valid"),s.write({type:SA.Type.STATUS,code:SA.Status.SUCCESS}),s.rest()}async function UA(e){const{connection:t,request:r,signal:s}=e,n=await t.newStream(CA,{signal:s});MA("starting stop request to %p",t.remotePeer);const i=new xA({stream:n});i.write(r);const o=await i.read();if(null!=o){if(o.code===SA.Status.SUCCESS)return MA("stop request to %p was successful",t.remotePeer),i.rest();MA("stop request failed with code %d",o.code),i.close()}else i.close()}const jA=(0,u.kg)("libp2p:circuit:hop");async function VA(e){const{connection:t,request:r,streamHandler:s,circuit:n,connectionManager:i}=e;if(!n.hopEnabled())return jA("HOP request received but we are not acting as a relay"),s.end({type:SA.Type.STATUS,code:SA.Status.HOP_CANT_SPEAK_RELAY});try{NA(r,s)}catch(mu){return void jA.error("invalid hop request via peer %p %o",t.remotePeer,mu)}if(null==r.dstPeer)return void jA("HOP request received but we do not receive a dstPeer");const o=(0,Ht.cv)(r.dstPeer.id),a=i.getConnections(o);if(0===a.length&&!n.hopActive())return jA("HOP request received but we are not connected to the destination peer"),s.end({type:SA.Type.STATUS,code:SA.Status.HOP_NO_CONN_TO_DST});if(0===a.length)return jA("did not have connection to remote peer"),s.end({type:SA.Type.STATUS,code:SA.Status.HOP_NO_CONN_TO_DST});const c={type:SA.Type.STOP,dstPeer:r.dstPeer,srcPeer:r.srcPeer};let l;try{jA("performing STOP request");const e=await UA({connection:a[0],request:c});if(null==e)throw new Error("Could not stop");l=e}catch(mu){return void jA.error(mu)}jA("hop request from %p is valid",t.remotePeer),s.write({type:SA.Type.STATUS,code:SA.Status.SUCCESS});const u=s.rest();return jA("creating related connections"),await(0,Cs.zG)(u,l,u)}async function zA(e){const{connection:t,request:r,signal:s}=e,n=await t.newStream(CA,{signal:s}),i=new xA({stream:n});i.write(r);const o=await i.read();if(null==o)throw h(new Error("HOP request had no response"),VT.ERR_HOP_REQUEST_FAILED);if(o.code===SA.Status.SUCCESS)return jA("hop request was successful"),i.rest();throw jA("hop request failed with code %d, closing stream",o.code),i.close(),h(new Error(`HOP request failed with code "${o.code??"unknown"}"`),VT.ERR_HOP_REQUEST_FAILED)}async function FA(e){const{connection:t,signal:r}=e,s=await t.newStream(CA,{signal:r}),n=new xA({stream:s});n.write({type:SA.Type.CAN_HOP});const i=await n.read();return await n.close(),null!=i&&i.code===SA.Status.SUCCESS}function $A(e){const{connection:t,streamHandler:r,circuit:s}=e,n=s.hopEnabled();jA("can hop (%s) request from %p",n,t.remotePeer),r.end({type:SA.Type.STATUS,code:n?SA.Status.SUCCESS:SA.Status.HOP_CANT_SPEAK_RELAY})}var KA=r(12348);class HA extends Error{constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}}function qA(e){if(null!=e){if("function"===typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"===typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"===typeof e.next)return e}throw new Error("argument is not an iterator or iterable")}function GA(e,t,r){const s=r??{},n=qA(e);async function*i(){let r;const i=()=>{null!=r&&r()};t.addEventListener("abort",i);while(1){let o;try{if(t.aborted){const{abortMessage:e,abortCode:t}=s;throw new HA(e,t)}const e=new Promise(((e,t)=>{r=()=>{const{abortMessage:e,abortCode:r}=s;t(new HA(e,r))}}));o=await Promise.race([e,n.next()]),r=null}catch(mu){t.removeEventListener("abort",i);const o="aborted"===mu.type&&t.aborted;if(o&&null!=s.onAbort&&await s.onAbort(e),"function"===typeof n.return)try{const e=n.return();e instanceof Promise&&e.catch((e=>{null!=s.onReturnError&&s.onReturnError(e)}))}catch(mu){null!=s.onReturnError&&s.onReturnError(mu)}if(o&&!0===s.returnOnAbort)return;throw mu}if(!0===o.done)break;yield o.value}t.removeEventListener("abort",i)}return i()}function WA(e,t,r){return s=>e(GA(s,t,r))}function YA(e,t,r){return{sink:WA(e.sink,t,{...r,onAbort:void 0}),source:GA(e.source,t,r)}}const QA=(0,u.kg)("libp2p:circuit");class ZA{constructor(e){this.components=new nS.z,this._init=e}init(e){this.components=e,this.components.getRegistrar().handle(CA,(e=>{this._onProtocol(e).catch((e=>{QA.error(e)}))})).catch((e=>{QA.error(e)}))}hopEnabled(){return!0}hopActive(){return!0}get[KA.N](){return!0}get[Symbol.toStringTag](){return"libp2p/circuit-relay-v1"}async _onProtocol(e){const{connection:t,stream:r}=e,s=new Fe.TimeoutController(this._init.hop.timeout);try{(0,qT.setMaxListeners)?.(1/0,s.signal)}catch{}try{const e=YA(r,s.signal),n=new xA({stream:{...r,...e}}),i=await n.read();if(null==i)return QA("request was invalid, could not read from stream"),n.write({type:SA.Type.STATUS,code:SA.Status.MALFORMED_MESSAGE}),void n.close();let o;switch(i.type){case SA.Type.CAN_HOP:QA("received CAN_HOP request from %p",t.remotePeer),await $A({circuit:this,connection:t,streamHandler:n});break;case SA.Type.HOP:QA("received HOP request from %p",t.remotePeer),await VA({connection:t,request:i,streamHandler:n,circuit:this,connectionManager:this.components.getConnectionManager()});break;case SA.Type.STOP:QA("received STOP request from %p",t.remotePeer),o=await BA({connection:t,request:i,streamHandler:n});break;default:return QA("Request of type %s not supported",i.type),n.write({type:SA.Type.STATUS,code:SA.Status.MALFORMED_MESSAGE}),void n.close()}if(null!=o){const e=t.remoteAddr.encapsulate("/p2p-circuit").encapsulate((0,qe.HM)(i.dstPeer?.addrs[0])),r=(0,qe.HM)(i.srcPeer?.addrs[0]),s=AA({stream:o,remoteAddr:e,localAddr:r}),n=i.type===SA.Type.HOP?"relay":"inbound";QA("new %s connection %s",n,s.remoteAddr);const a=await this.components.getUpgrader().upgradeInbound(s);QA("%s connection %s upgraded",n,s.remoteAddr),null!=this.handler&&this.handler(a)}}finally{s.clear()}}async dial(e,t={}){const r=e.toString().split("/p2p-circuit"),s=(0,qe.HM)(r[0]),n=(0,qe.HM)(r[r.length-1]),i=s.getPeerId(),o=n.getPeerId();if(null==i||null==o){const e="Circuit relay dial failed as addresses did not have peer id";throw QA.error(e),h(new Error(e),VT.ERR_RELAYED_DIAL)}const a=(0,Ht.jE)(i),c=(0,Ht.jE)(o);let l=!1;const u=this.components.getConnectionManager().getConnections(a);let d=u[0];null==d&&(await this.components.getPeerStore().addressBook.add(a,[s]),d=await this.components.getConnectionManager().openConnection(a,t),l=!0);try{const r=await zA({...t,connection:d,request:{type:SA.Type.HOP,srcPeer:{id:this.components.getPeerId().toBytes(),addrs:this.components.getAddressManager().getAddresses().map((e=>e.bytes))},dstPeer:{id:c.toBytes(),addrs:[(0,qe.HM)(n).bytes]}}}),i=s.encapsulate(`/p2p-circuit/p2p/${this.components.getPeerId().toString()}`),o=AA({stream:r,remoteAddr:e,localAddr:i});return QA("new outbound connection %s",o.remoteAddr),await this.components.getUpgrader().upgradeOutbound(o)}catch(mu){throw QA.error("Circuit relay dial failed",mu),l&&await d.close(),mu}}createListener(e){return this.handler=e.handler,PA({connectionManager:this.components.getConnectionManager(),peerStore:this.components.getPeerStore()})}filter(e){return e=Array.isArray(e)?e:[e],e.filter((e=>Ge.dx.matches(e)))}}async function XA(e){const t=(new TextEncoder).encode(e),r=await ti.sha256.digest(t);return A.CID.createV0(r)}const JA=6e4,eC=15*JA,tC=30*JA,rC=290,sC="hop_relay",nC="true",iC="/libp2p/relay";var oC=r(290);function aC(e){const{address:t}=e.nodeAddress();return Boolean(oC(t))}function cC(e,t){const r=aC(e.multiaddr),s=aC(t.multiaddr);return r&&!s?1:!r&&s||e.isCertified&&!t.isCertified?-1:!e.isCertified&&t.isCertified?1:0}const lC=(0,u.kg)("libp2p:auto-relay"),uC=()=>{};class hC{constructor(e,t){this.components=e,this.addressSorter=t.addressSorter??cC,this.maxListeners=t.maxListeners??1,this.listenRelays=new Set,this.onError=t.onError??uC,this._onProtocolChange=this._onProtocolChange.bind(this),this._onPeerDisconnected=this._onPeerDisconnected.bind(this),this.components.getPeerStore().addEventListener("change:protocols",(e=>{this._onProtocolChange(e).catch((e=>{lC.error(e)}))})),this.components.getConnectionManager().addEventListener("peer:disconnect",this._onPeerDisconnected)}async _onProtocolChange(e){const{peerId:t,protocols:r}=e.detail,s=t.toString(),n=r.find((e=>e===CA));if(null!=n){if(!this.listenRelays.has(s))try{const e=this.components.getConnectionManager().getConnections(t);if(0===e.length)return;const r=e[0];if(r.remoteAddr.protoCodes().includes(rC))return void lC(`relayed connection to ${s} will not be used to hop on`);const n=await FA({connection:r});n&&(await this.components.getPeerStore().metadataBook.setValue(t,sC,(0,ze.m)(nC)),await this._addListenRelay(r,s))}catch(mu){this.onError(mu)}}else this.listenRelays.has(s)&&await this._removeListenRelay(s)}_onPeerDisconnected(e){const t=e.detail,r=t.remotePeer,s=r.toString();this.listenRelays.has(s)&&this._removeListenRelay(s).catch((e=>{lC.error(e)}))}async _addListenRelay(e,t){try{if(this.listenRelays.size>=this.maxListeners)return;const r=await(0,Cs.zG)(await this.components.getPeerStore().addressBook.get(e.remotePeer),(e=>_E(e,this.addressSorter)),(async e=>await fs(e))),s=await Promise.all(r.map((async t=>{try{let r=t.multiaddr;return null==r.getPeerId()&&(r=r.encapsulate(`/p2p/${e.remotePeer.toString()}`)),r=r.encapsulate("/p2p-circuit"),await this.components.getTransportManager().listen([r]),!0}catch(mu){lC.error("error listening on circuit address",mu),this.onError(mu)}return!1})));s.includes(!0)&&this.listenRelays.add(t)}catch(mu){this.onError(mu),this.listenRelays.delete(t)}}async _removeListenRelay(e){this.listenRelays.delete(e)&&await this._listenOnAvailableHopRelays([e])}async _listenOnAvailableHopRelays(e=[]){if(this.listenRelays.size>=this.maxListeners)return;const t=[],r=await this.components.getPeerStore().all();for(const{id:s,metadata:n}of r){const r=s.toString();if(this.listenRelays.has(r))continue;if(e.includes(r))continue;const i=n.get(sC);if(null==i||(0,Ye.B)(i)!==nC)continue;const o=this.components.getConnectionManager().getConnections(s);if(0!==o.length){if(await this._addListenRelay(o[0],r),this.listenRelays.size>=this.maxListeners)return}else t.push(s)}for(const s of t)if(await this._tryToListenOnRelay(s),this.listenRelays.size>=this.maxListeners)return;try{const e=await XA(iC);for await(const t of this.components.getContentRouting().findProviders(e)){if(0===t.multiaddrs.length)continue;const e=t.id;if(!e.equals(this.components.getPeerId())&&(await this.components.getPeerStore().addressBook.add(e,t.multiaddrs),await this._tryToListenOnRelay(e),this.listenRelays.size>=this.maxListeners))return}}catch(mu){this.onError(mu)}}async _tryToListenOnRelay(e){try{const t=await this.components.getConnectionManager().openConnection(e);await this._addListenRelay(t,e.toString())}catch(mu){lC.error("Could not use %p as relay",e,mu),this.onError(mu,`could not connect and listen on known hop relay ${e.toString()}`)}}}const dC=(0,u.kg)("libp2p:relay");class pC{constructor(e,t){this.components=e,this.autoRelay=!1!==t.autoRelay?.enabled?new hC(e,{addressSorter:t.addressSorter,...t.autoRelay}):void 0,this.started=!1,this.init=t,this._advertiseService=this._advertiseService.bind(this)}isStarted(){return this.started}async start(){!1!==this.init.hop.enabled&&!1!==this.init.advertise.enabled&&(this.timeout=(0,HT.setDelayedInterval)(this._advertiseService,this.init.advertise.ttl,this.init.advertise.bootDelay)),this.started=!0}async stop(){null!=this.timeout&&(0,HT.clearDelayedInterval)(this.timeout),this.started=!1}async _advertiseService(){try{const e=await XA(iC);await this.components.getContentRouting().provide(e)}catch(mu){mu.code===VT.ERR_NO_ROUTERS_AVAILABLE?(dC.error("a content router, such as a DHT, must be provided in order to advertise the relay service",mu),await this.stop()):dC.error(mu)}}}var fC=r(50202),yC=(r(79437),r(97450),r(3832));r(25414);const gC=yC.pki,mC=(e,t)=>{const r=gC.rsa.setPublicKey(t.n,t.e),s=gC.createCertificate();s.publicKey=r,s.serialNumber="01",s.validity.notBefore=new Date,s.validity.notAfter=new Date,s.validity.notAfter.setFullYear(s.validity.notBefore.getFullYear()+10);const n=[{name:"organizationName",value:"ipfs"},{shortName:"OU",value:"keystore"},{name:"commonName",value:e.id}];return s.setSubject(n),s.setIssuer(n),s.setExtensions([{name:"basicConstraints",cA:!0},{name:"keyUsage",keyCertSign:!0,digitalSignature:!0,nonRepudiation:!0,keyEncipherment:!0,dataEncipherment:!0},{name:"extKeyUsage",serverAuth:!0,clientAuth:!0,codeSigning:!0,emailProtection:!0,timeStamping:!0},{name:"nsCertType",client:!0,server:!0,email:!0,objsign:!0,sslCA:!0,emailCA:!0,objCA:!0}]),s.sign(t),s};async function wC(e,t){const r=e.map(t),s=await Promise.all(r),n=s.findIndex((e=>e));return e[n]}const bC=(0,u.kg)("libp2p:keychain:cms"),_C=new WeakMap;class EC{constructor(e,t){if(null==e)throw h(new Error("keychain is required"),VT.ERR_KEYCHAIN_REQUIRED);this.keychain=e,_C.set(this,{dek:t})}async encrypt(e,t){if(!(t instanceof Uint8Array))throw h(new Error("Plain data must be a Uint8Array"),VT.ERR_INVALID_PARAMETERS);const r=await this.keychain.findKeyByName(e),s=await this.keychain.getPrivateKey(e),n=_C.get(this);if(null==n)throw h(new Error("dek missing"),VT.ERR_INVALID_PARAMETERS);const i=n.dek,o=yC.pki.decryptRsaPrivateKey(s,i),a=await mC(r,o),c=yC.pkcs7.createEnvelopedData();c.addRecipient(a),c.content=yC.util.createBuffer(t),c.encrypt();const l=yC.asn1.toDer(c.toAsn1()).getBytes();return(0,ze.m)(l,"ascii")}async decrypt(e){if(!(e instanceof Uint8Array))throw h(new Error("CMS data is required"),VT.ERR_INVALID_PARAMETERS);let t;try{const r=yC.util.createBuffer((0,Ye.B)(e,"ascii")),s=yC.asn1.fromDer(r);t=yC.pkcs7.messageFromAsn1(s)}catch(mu){throw bC.error(mu),h(new Error("Invalid CMS"),VT.ERR_INVALID_CMS)}const r=t.recipients.filter((e=>e.issuer.find((e=>"O"===e.shortName&&"ipfs"===e.value)))).filter((e=>e.issuer.find((e=>"CN"===e.shortName)))).map((e=>({recipient:e,keyId:e.issuer.find((e=>"CN"===e.shortName)).value}))),s=await wC(r,(async e=>{try{const t=await this.keychain.findKeyById(e.keyId);if(null!=t)return!0}catch(mu){return!1}return!1}));if(null==s){const e=r.map((e=>e.keyId));throw h(new Error(`Decryption needs one of the key(s): ${e.join(", ")}`),VT.ERR_MISSING_KEYS,{missingKeys:e})}const n=await this.keychain.findKeyById(s.keyId);if(null==n)throw h(new Error("No key available to decrypto"),VT.ERR_NO_KEY);const i=await this.keychain.getPrivateKey(n.name),o=_C.get(this);if(null==o)throw h(new Error("dek missing"),VT.ERR_INVALID_PARAMETERS);const a=o.dek,c=yC.pki.decryptRsaPrivateKey(i,a);return t.decrypt(s.recipient,c),(0,ze.m)(t.content.getBytes(),"ascii")}}const vC=(0,u.kg)("libp2p:keychain"),SC="/pkcs8/",IC="/info/",kC=new WeakMap,RC={minKeyLength:14,minSaltLength:16,minIterationCount:1e3},TC={dek:{keyLength:64,iterationCount:1e4,salt:"you should override this value with a crypto secure random number",hash:"sha2-512"}};function AC(e){return null!=e&&("string"===typeof e&&(e===fC(e.trim())&&e.length>0))}async function CC(){const e=200,t=1e3,r=Math.random()*(t-e)+e;await new Promise((e=>setTimeout(e,r)))}function PC(e){return new lt.s(SC+e)}function DC(e){return new lt.s(IC+e)}class NC{constructor(e,t){if(this.components=e,this.init=(0,c.Z)(TC,t),null!=this.init.pass&&this.init.pass?.length<20)throw new Error("pass must be least 20 characters");if(null!=this.init.dek?.keyLength&&this.init.dek.keyLength<RC.minKeyLength)throw new Error(`dek.keyLength must be least ${RC.minKeyLength} bytes`);if(null!=this.init.dek?.salt?.length&&this.init.dek.salt.length<RC.minSaltLength)throw new Error(`dek.saltLength must be least ${RC.minSaltLength} bytes`);if(null!=this.init.dek?.iterationCount&&this.init.dek.iterationCount<RC.minIterationCount)throw new Error(`dek.iterationCount must be least ${RC.minIterationCount}`);const r=null!=this.init.pass&&null!=this.init.dek?.salt?(0,gS.nk)(this.init.pass,this.init.dek?.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";kC.set(this,{dek:r}),this.started=!1}isStarted(){return this.started}async start(){const e=DC("self");await this.components.getDatastore().has(e)||await this.importPeer("self",this.components.getPeerId()),this.started=!0}stop(){this.started=!1}get cms(){const e=kC.get(this);if(null==e)throw h(new Error("dek missing"),VT.ERR_INVALID_PARAMETERS);const t=e.dek;return new EC(this,t)}static generateOptions(){const e=Object.assign({},TC),t=3*Math.ceil(RC.minSaltLength/3);return e.dek.salt=(0,Ye.B)((0,gS.O6)(t),"base64"),e}static get options(){return TC}async createKey(e,t,r=2048){if(!AC(e)||"self"===e)throw await CC(),h(new Error("Invalid key name"),VT.ERR_INVALID_KEY_NAME);if("string"!==typeof t)throw await CC(),h(new Error("Invalid key type"),VT.ERR_INVALID_KEY_TYPE);const s=PC(e),n=await this.components.getDatastore().has(s);if(n)throw await CC(),h(new Error("Key name already exists"),VT.ERR_KEY_ALREADY_EXISTS);switch(t.toLowerCase()){case"rsa":if(!Number.isSafeInteger(r)||r<2048)throw await CC(),h(new Error("Invalid RSA key size"),VT.ERR_INVALID_KEY_SIZE);break;default:break}let i;try{const n=await(0,dr.generateKeyPair)(t,r),o=await n.id(),a=kC.get(this);if(null==a)throw h(new Error("dek missing"),VT.ERR_INVALID_PARAMETERS);const c=a.dek,l=await n.export(c);i={name:e,id:o};const u=this.components.getDatastore().batch();u.put(s,(0,ze.m)(l)),u.put(DC(e),(0,ze.m)(JSON.stringify(i))),await u.commit()}catch(mu){throw await CC(),mu}return i}async listKeys(){const e={prefix:IC},t=[];for await(const r of this.components.getDatastore().query(e))t.push(JSON.parse((0,Ye.B)(r.value)));return t}async findKeyById(e){try{const t=await this.listKeys();return t.find((t=>t.id===e))}catch(mu){throw await CC(),mu}}async findKeyByName(e){if(!AC(e))throw await CC(),h(new Error(`Invalid key name '${e}'`),VT.ERR_INVALID_KEY_NAME);const t=DC(e);try{const e=await this.components.getDatastore().get(t);return JSON.parse((0,Ye.B)(e))}catch(mu){throw await CC(),vC.error(mu),h(new Error(`Key '${e}' does not exist.`),VT.ERR_KEY_NOT_FOUND)}}async removeKey(e){if(!AC(e)||"self"===e)throw await CC(),h(new Error(`Invalid key name '${e}'`),VT.ERR_INVALID_KEY_NAME);const t=PC(e),r=await this.findKeyByName(e),s=this.components.getDatastore().batch();return s.delete(t),s.delete(DC(e)),await s.commit(),r}async renameKey(e,t){if(!AC(e)||"self"===e)throw await CC(),h(new Error(`Invalid old key name '${e}'`),VT.ERR_OLD_KEY_NAME_INVALID);if(!AC(t)||"self"===t)throw await CC(),h(new Error(`Invalid new key name '${t}'`),VT.ERR_NEW_KEY_NAME_INVALID);const r=PC(e),s=PC(t),n=DC(e),i=DC(t),o=await this.components.getDatastore().has(s);if(o)throw await CC(),h(new Error(`Key '${t}' already exists`),VT.ERR_KEY_ALREADY_EXISTS);try{const e=await this.components.getDatastore().get(r),o=await this.components.getDatastore().get(n),a=JSON.parse((0,Ye.B)(o));a.name=t;const c=this.components.getDatastore().batch();return c.put(s,e),c.put(i,(0,ze.m)(JSON.stringify(a))),c.delete(r),c.delete(n),await c.commit(),a}catch(mu){throw await CC(),mu}}async exportKey(e,t){if(!AC(e))throw await CC(),h(new Error(`Invalid key name '${e}'`),VT.ERR_INVALID_KEY_NAME);if(null==t)throw await CC(),h(new Error("Password is required"),VT.ERR_PASSWORD_REQUIRED);const r=PC(e);try{const e=await this.components.getDatastore().get(r),s=(0,Ye.B)(e),n=kC.get(this);if(null==n)throw h(new Error("dek missing"),VT.ERR_INVALID_PARAMETERS);const i=n.dek,o=await(0,dr.importKey)(s,i);return await o.export(t)}catch(mu){throw await CC(),mu}}async importKey(e,t,r){if(!AC(e)||"self"===e)throw await CC(),h(new Error(`Invalid key name '${e}'`),VT.ERR_INVALID_KEY_NAME);if(null==t)throw await CC(),h(new Error("PEM encoded key is required"),VT.ERR_PEM_REQUIRED);const s=PC(e),n=await this.components.getDatastore().has(s);if(n)throw await CC(),h(new Error(`Key '${e}' already exists`),VT.ERR_KEY_ALREADY_EXISTS);let i,o;try{i=await(0,dr.importKey)(t,r)}catch(mu){throw await CC(),h(new Error("Cannot read the key, most likely the password is wrong"),VT.ERR_CANNOT_READ_KEY)}try{o=await i.id();const e=kC.get(this);if(null==e)throw h(new Error("dek missing"),VT.ERR_INVALID_PARAMETERS);const r=e.dek;t=await i.export(r)}catch(mu){throw await CC(),mu}const a={name:e,id:o},c=this.components.getDatastore().batch();return c.put(s,(0,ze.m)(t)),c.put(DC(e),(0,ze.m)(JSON.stringify(a))),await c.commit(),a}async importPeer(e,t){try{if(!AC(e))throw h(new Error(`Invalid key name '${e}'`),VT.ERR_INVALID_KEY_NAME);if(null==t)throw h(new Error("PeerId is required"),VT.ERR_MISSING_PRIVATE_KEY);if(null==t.privateKey)throw h(new Error("PeerId.privKey is required"),VT.ERR_MISSING_PRIVATE_KEY);const r=await(0,dr.unmarshalPrivateKey)(t.privateKey),s=PC(e),n=await this.components.getDatastore().has(s);if(n)throw await CC(),h(new Error(`Key '${e}' already exists`),VT.ERR_KEY_ALREADY_EXISTS);const i=kC.get(this);if(null==i)throw h(new Error("dek missing"),VT.ERR_INVALID_PARAMETERS);const o=i.dek,a=await r.export(o),c={name:e,id:t.toString()},l=this.components.getDatastore().batch();return l.put(s,(0,ze.m)(a)),l.put(DC(e),(0,ze.m)(JSON.stringify(c))),await l.commit(),c}catch(mu){throw await CC(),mu}}async getPrivateKey(e){if(!AC(e))throw await CC(),h(new Error(`Invalid key name '${e}'`),VT.ERR_INVALID_KEY_NAME);try{const t=PC(e),r=await this.components.getDatastore().get(t);return(0,Ye.B)(r)}catch(mu){throw await CC(),vC.error(mu),h(new Error(`Key '${e}' does not exist.`),VT.ERR_KEY_NOT_FOUND)}}async rotateKeychainPass(e,t){if("string"!==typeof e)throw await CC(),h(new Error(`Invalid old pass type '${typeof e}'`),VT.ERR_INVALID_OLD_PASS_TYPE);if("string"!==typeof t)throw await CC(),h(new Error(`Invalid new pass type '${typeof t}'`),VT.ERR_INVALID_NEW_PASS_TYPE);if(t.length<20)throw await CC(),h(new Error(`Invalid pass length ${t.length}`),VT.ERR_INVALID_PASS_LENGTH);vC("recreating keychain");const r=kC.get(this);if(null==r)throw h(new Error("dek missing"),VT.ERR_INVALID_PARAMETERS);const s=r.dek;this.init.pass=t;const n=null!=t&&null!=this.init.dek?.salt?(0,gS.nk)(t,this.init.dek.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";kC.set(this,{dek:n});const i=await this.listKeys();for(const o of i){const e=await this.components.getDatastore().get(PC(o.name)),t=(0,Ye.B)(e),r=await(0,dr.importKey)(t,s),i=n.toString(),a=await r.export(i),c=this.components.getDatastore().batch(),l={name:o.name,id:o.id};c.put(PC(o.name),(0,ze.m)(a)),c.put(DC(o.name),(0,ze.m)(JSON.stringify(l))),await c.commit()}vC("keychain reconstructed")}}var OC=r(4321);const LC=3e4,xC=3e4,MC=100,BC=4,UC=25,jC={computeThrottleMaxQueueSize:1e3,computeThrottleTimeout:2e3,movingAverageIntervals:[6e4,3e5,9e5],maxOldPeersRetention:50};class VC{constructor(e){if("number"!==typeof e)throw new Error("must provide a timespan to the moving average constructor");if(e<=0)throw new Error("must provide a timespan > 0 to the moving average constructor");this.timespan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timespan)}push(e,t){if(null!=this.previousTime){const r=this.alpha(e,this.previousTime),s=t-this.movingAverage,n=r*s;this.movingAverage=r*t+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+s*n),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*s}else this.movingAverage=t;this.previousTime=e}}function zC(e){return new VC(e)}class FC extends HE.v{constructor(e){super(),this.enabled=e.enabled,this.queue=[],this.stats={dataReceived:0n,dataSent:0n},this.frequencyLastTime=Date.now(),this.frequencyAccumulators={},this.movingAverages={dataReceived:[],dataSent:[]},this.computeThrottleMaxQueueSize=e.computeThrottleMaxQueueSize,this.computeThrottleTimeout=e.computeThrottleTimeout,this._update=this._update.bind(this),this.movingAverageIntervals=e.movingAverageIntervals;for(let t=0;t<e.initialCounters.length;t++){const r=e.initialCounters[t];this.stats[r]=0n,this.movingAverages[r]=[];for(let e=0;e<this.movingAverageIntervals.length;e++){const t=this.movingAverageIntervals[e],s=this.movingAverages[r][t]=zC(t);s.push(this.frequencyLastTime,0)}}}start(){this.enabled&&this.queue.length>0&&this._resetComputeTimeout()}stop(){null!=this.timeout&&(this.timeout.clear(),this.timeout=null)}getSnapshot(){return Object.assign({},this.stats)}getMovingAverages(){return Object.assign({},this.movingAverages)}push(e,t){this.queue.push([e,t,Date.now()]),this._resetComputeTimeout()}_resetComputeTimeout(){this.timeout=iA(this._update,this._nextTimeout())}_nextTimeout(){const e=this.queue.length/this.computeThrottleMaxQueueSize,t=Math.max(this.computeThrottleTimeout*(1-e),0);return t}_update(){if(this.timeout=null,this.queue.length>0){let e=["",0,0];for(e of this.queue)this._applyOp(e);this.queue=[],e.length>2&&""!==e[0]&&this._updateFrequency(e[2]),this.dispatchEvent(new HE.A("update",{detail:this.stats}))}}_updateFrequency(e){const t=e-this.frequencyLastTime;this._updateFrequencyFor("dataReceived",t,e),this._updateFrequencyFor("dataSent",t,e),this.frequencyLastTime=e}_updateFrequencyFor(e,t,r){const s=this.frequencyAccumulators[e]??0;this.frequencyAccumulators[e]=0;const n=t??1,i=s/n*1e3;let o=this.movingAverages[e];null==o&&(o=this.movingAverages[e]=[]);const a=this.movingAverageIntervals;for(let c=0;c<a.length;c++){const e=a[c];let t=o[e];null==t&&(t=o[e]=zC(e)),t.push(r,i)}}_applyOp(e){const t=e[0],r=e[1];if("number"!==typeof r)throw new Error("invalid increment number");let s;s=Object.prototype.hasOwnProperty.call(this.stats,t)?this.stats[t]:this.stats[t]=0n,this.stats[t]=s+BigInt(r),null==this.frequencyAccumulators[t]&&(this.frequencyAccumulators[t]=0),this.frequencyAccumulators[t]+=r}}const $C=["dataReceived","dataSent"],KC={in:"dataReceived",out:"dataSent"};class HC{constructor(e){this.enabled=e.enabled,this.statsInit={...e,initialCounters:$C},this.globalStats=new FC(this.statsInit),this.peerStats=new Map,this.protocolStats=new Map,this.oldPeers=Nt(e.maxOldPeersRetention??jC.maxOldPeersRetention),this.running=!1,this._onMessage=this._onMessage.bind(this),this.systems=new Map}isStarted(){return this.running}async start(){this.enabled&&(this.running=!0)}async stop(){if(this.running){this.running=!1,this.globalStats.stop();for(const e of this.peerStats.values())e.stop();for(const e of this.protocolStats.values())e.stop()}}getGlobal(){return this.globalStats}getPeers(){return Array.from(this.peerStats.keys())}getComponentMetrics(){return this.systems}updateComponentMetric(e){const{system:t="libp2p",component:r,metric:s,value:n,label:i,help:o}=e;this.systems.has(t)||this.systems.set(t,new Map);const a=this.systems.get(t);if(null==a)throw new Error("Unknown metric system");a.has(r)||a.set(r,new Map);const c=a.get(r);if(null==c)throw new Error("Unknown metric component");c.set(s,{label:i,help:o,calculate:"function"!==typeof n?()=>n:n})}forPeer(e){const t=e.toString();return this.peerStats.get(t)??this.oldPeers.get(t)}getProtocols(){return Array.from(this.protocolStats.keys())}forProtocol(e){return this.protocolStats.get(e)}onPeerDisconnected(e){const t=e.toString(),r=this.peerStats.get(t);null!=r&&(r.stop(),this.peerStats.delete(t),this.oldPeers.set(t,r))}_onMessage(e){if(!this.running)return;const{remotePeer:t,protocol:r,direction:s,dataLength:n}=e,i=KC[s];let o=this.forPeer(t);if(null==o){const e=new FC(this.statsInit);this.peerStats.set(t.toString(),e),o=e}if(o.push(i,n),this.globalStats.push(i,n),null!=r){let e=this.forProtocol(r);if(null==e){const t=new FC(this.statsInit);this.protocolStats.set(r,t),e=t}e.push(i,n)}}updatePlaceholder(e,t){if(!this.running)return;const r=e.toString(),s=this.peerStats.get(r)??this.oldPeers.get(r),n=t.toString(),i=this.peerStats.get(n)??this.oldPeers.get(n);let o=s;null!=i&&(o=qC(i,o),this.oldPeers.remove(n)),this.peerStats.delete(e.toString()),this.peerStats.set(n,o),o.start()}trackStream(e){const{stream:t,remotePeer:r,protocol:s}=e;if(!this.running)return;const n=t.source;t.source=OC(n,(e=>this._onMessage({remotePeer:r,protocol:s,direction:"in",dataLength:e.byteLength})));const i=t.sink;t.sink=async e=>await(0,Cs.zG)(e,(e=>OC(e,(e=>{this._onMessage({remotePeer:r,protocol:s,direction:"out",dataLength:e.byteLength})}))),i)}}function qC(e,t){return e.stop(),t.stop(),e.queue=[...e.queue,...t.queue],e}async function GC(e){try{const t=await e;return{status:"fulfilled",value:t,isFulfilled:!0,isRejected:!1}}catch(t){return{status:"rejected",reason:t,isFulfilled:!1,isRejected:!0}}}class WC{value;next;constructor(e){this.value=e}}class YC{#e;#t;#r;constructor(){this.clear()}enqueue(e){const t=new WC(e);this.#e?(this.#t.next=t,this.#t=t):(this.#e=t,this.#t=t),this.#r++}dequeue(){const e=this.#e;if(e)return this.#e=this.#e.next,this.#r--,e.value}clear(){this.#e=void 0,this.#t=void 0,this.#r=0}get size(){return this.#r}*[Symbol.iterator](){let e=this.#e;while(e)yield e.value,e=e.next}}function QC(e){if(!Number.isInteger(e)&&e!==Number.POSITIVE_INFINITY||!(e>0))throw new TypeError("Expected `concurrency` to be a number from 1 and up");const t=new YC;let r=0;const s=()=>{r--,t.size>0&&t.dequeue()()},n=async(e,t,n)=>{r++;const i=(async()=>e(...n))();t(i);try{await i}catch{}s()},i=(s,i,o)=>{t.enqueue(n.bind(void 0,s,i,o)),(async()=>{await Promise.resolve(),r<e&&t.size>0&&t.dequeue()()})()},o=(e,...t)=>new Promise((r=>{i(e,r,t)}));return Object.defineProperties(o,{activeCount:{get:()=>r},pendingCount:{get:()=>t.size},clearQueue:{value:()=>{t.clear()}}}),o}async function ZC(e,t={}){const{concurrency:r=Number.POSITIVE_INFINITY}=t,s=QC(r);return Promise.all(e.map((e=>e&&"function"===typeof e.then?GC(e):GC("function"===typeof e?s((()=>e())):Promise.resolve(e)))))}class XC extends Map{constructor(e){super();const{system:t,component:r,metric:s,metrics:n}=e;this.system=t??"libp2p",this.component=r,this.metric=s,this.metrics=n,this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metrics.updateComponentMetric({system:this.system,component:this.component,metric:this.metric,value:this.size})}}function JC(e){const{system:t,component:r,metric:s,metrics:n}=e;let i;return i=null!=n?new XC({system:t,component:r,metric:s,metrics:n}):new Map,i}const eP=(0,u.kg)("libp2p:transports");class tP extends HE.v{constructor(e,t={}){super(),this.components=e,this.started=!1,this.transports=new Map,this.listeners=JC({component:"transport-manager",metric:"listeners",metrics:this.components.getMetrics()}),this.faultTolerance=t.faultTolerance??rP.FATAL_ALL}add(e){const t=e[Symbol.toStringTag];if(null==t)throw h(new Error("Transport must have a valid tag"),VT.ERR_INVALID_KEY);if(this.transports.has(t))throw h(new Error("There is already a transport with this tag"),VT.ERR_DUPLICATE_TRANSPORT);eP("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}async start(){const e=this.components.getAddressManager().getListenAddrs();await this.listen(e),this.started=!0}async stop(){const e=[];for(const[t,r]of this.listeners){eP("closing listeners for %s",t);while(r.length>0){const t=r.pop();null!=t&&e.push(t.close())}}await Promise.all(e),eP("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const r=this.transportForMultiaddr(e);if(null==r)throw h(new Error(`No transport available for address ${String(e)}`),VT.ERR_TRANSPORT_UNAVAILABLE);try{return await r.dial(e,{...t,upgrader:this.components.getUpgrader()})}catch(mu){throw null==mu.code&&(mu.code=VT.ERR_TRANSPORT_DIAL_FAILED),mu}}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}transportForMultiaddr(e){for(const t of this.transports.values()){const r=t.filter([e]);if(r.length>0)return t}}async listen(e){if(null==e||0===e.length)return void eP("no addresses were provided for listening, this node is dial only");const t=[];for(const[r,s]of this.transports.entries()){const n=s.filter(e),i=[];for(const e of n){eP("creating listener for %s on %s",r,e);const t=s.createListener({upgrader:this.components.getUpgrader()});let n=this.listeners.get(r);null==n&&(n=[],this.listeners.set(r,n)),n.push(t),t.addEventListener("listening",(()=>{this.dispatchEvent(new HE.A("listener:listening",{detail:t}))})),t.addEventListener("close",(()=>{this.dispatchEvent(new HE.A("listener:close",{detail:t}))})),i.push(t.listen(e))}if(0===i.length){t.push(r);continue}const o=await ZC(i),a=o.find((e=>e.isFulfilled));if(null==a&&this.faultTolerance!==rP.NO_FATAL)throw h(new Error(`Transport (${r}) could not listen on any available address`),VT.ERR_NO_VALID_ADDRESSES)}if(t.length===this.transports.size){const e=`no valid addresses were provided for transports [${t.join(", ")}]`;if(this.faultTolerance===rP.FATAL_ALL)throw h(new Error(e),VT.ERR_NO_VALID_ADDRESSES);eP(`libp2p in dial mode only: ${e}`)}}async remove(e){eP("removing %s",e);for(const t of this.listeners.get(e)??[])await t.close();this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}var rP;(function(e){e[e["FATAL_ALL"]=0]="FATAL_ALL",e[e["NO_FATAL"]=1]="NO_FATAL"})(rP||(rP={}));const sP="/multistream/1.0.0";class nP extends Error{constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}}function iP(e){if(null!=e){if("function"===typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"===typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"===typeof e.next)return e}throw new Error("argument is not an iterator or iterable")}function oP(e,t,r){const s=r??{},n=iP(e);async function*i(){let r;const i=()=>{null!=r&&r()};t.addEventListener("abort",i);while(1){let o;try{if(t.aborted){const{abortMessage:e,abortCode:t}=s;throw new nP(e,t)}const e=new Promise(((e,t)=>{r=()=>{const{abortMessage:e,abortCode:r}=s;t(new nP(e,r))}}));o=await Promise.race([e,n.next()]),r=null}catch(mu){t.removeEventListener("abort",i);const o="aborted"===mu.type&&t.aborted;if(o&&null!=s.onAbort&&await s.onAbort(e),"function"===typeof n.return)try{const e=n.return();e instanceof Promise&&e.catch((e=>{null!=s.onReturnError&&s.onReturnError(e)}))}catch(mu){null!=s.onReturnError&&s.onReturnError(mu)}if(o&&!0===s.returnOnAbort)return;throw mu}if(!0===o.done)break;yield o.value}t.removeEventListener("abort",i)}return i()}const aP=(0,ze.m)("\n");function cP(e){const t=new ba.H(e,aP);return PS.c.single(t)}function lP(e,t,r={}){const s=cP(t);!0===r.writeBytes?e.push(s.subarray()):e.push(s)}function uP(e,t,r={}){const s=new ba.H;for(const n of t)s.append(cP(n));!0===r.writeBytes?e.push(s.subarray()):e.push(s)}async function hP(e,t){let r=1;const s={[Symbol.asyncIterator]:()=>s,next:async()=>await e.next(r)};let n=s;null!=t?.signal&&(n=oP(s,t.signal));const i=e=>{r=e},o=await(0,Cs.zG)(n,PS.J({onLength:i}),(async e=>await sy(e)));if(null==o)throw h(new Error("no buffer returned"),"ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");if(o.get(o.byteLength-1)!==aP[0])throw h(new Error("missing newline"),"ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");return o.sublist(0,-1)}async function dP(e,t){const r=await hP(e,t);return(0,Ye.B)(r.subarray())}const pP=(0,u.kg)("libp2p:mss:select");async function fP(e,t,r={}){t=Array.isArray(t)?[...t]:[t];const{reader:s,writer:n,rest:i,stream:o}=(0,OA.Y)(e),a=t.shift();if(null==a)throw new Error("At least one protocol must be specified");pP('select: write ["%s", "%s"]',sP,a);const c=(0,ze.m)(sP),l=(0,ze.m)(a);uP(n,[c,l],r);let u=await dP(s,r);if(pP('select: read "%s"',u),u===sP&&(u=await dP(s,r),pP('select: read "%s"',u)),u===a)return i(),{stream:o,protocol:a};for(const h of t){pP('select: write "%s"',h),lP(n,(0,ze.m)(h),r);const e=await dP(s,r);if(pP('select: read "%s" for "%s"',e,h),e===h)return i(),{stream:o,protocol:h}}throw i(),h(new Error("protocol selection failed"),"ERR_UNSUPPORTED_PROTOCOL")}const yP=(0,u.kg)("libp2p:mss:handle");async function gP(e,t,r){t=Array.isArray(t)?t:[t];const{writer:s,reader:n,rest:i,stream:o}=(0,OA.Y)(e);while(1){const e=await dP(n,r);if(yP('read "%s"',e),e!==sP){if(t.includes(e))return lP(s,(0,ze.m)(e),r),yP('respond with "%s" for "%s"',e,e),i(),{stream:o,protocol:e};"ls"!==e?(lP(s,(0,ze.m)("na"),r),yP('respond with "na" for "%s"',e)):(lP(s,new ba.H(...t.map((e=>cP((0,ze.m)(e))))),r),yP('respond with "%s" for %s',t,e))}else yP('respond with "%s" for "%s"',sP,e),lP(s,(0,ze.m)(sP),r)}}var mP=r(99633);const wP=Symbol.for("@libp2p/connection");const bP=(0,u.kg)("libp2p:connection");class _P{constructor(e){const{remoteAddr:t,remotePeer:r,newStream:s,close:n,getStreams:i,stat:o}=e;this.id=`${parseInt(String(1e9*Math.random())).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=r,this.stat={...o,status:oA},this._newStream=s,this._close=n,this._getStreams=i,this.tags=[],this._closing=!1}get[Symbol.toStringTag](){return"Connection"}get[wP](){return!0}get streams(){return this._getStreams()}async newStream(e,t){if(this.stat.status===aA)throw h(new Error("the connection is being closed"),"ERR_CONNECTION_BEING_CLOSED");if(this.stat.status===cA)throw h(new Error("the connection is closed"),"ERR_CONNECTION_CLOSED");Array.isArray(e)||(e=[e]);const r=await this._newStream(e,t);return r.stat.direction="outbound",r}addStream(e){e.stat.direction="inbound"}removeStream(e){}async close(){if(this.stat.status!==cA&&!this._closing){this.stat.status=aA;try{this.streams.forEach((e=>e.close()))}catch(mu){bP.error(mu)}this._closing=!0,await this._close(),this._closing=!1,this.stat.timeline.close=Date.now(),this.stat.status=cA}}}function EP(e){return new _P(e)}var vP=r(1388);const SP=(0,u.kg)("libp2p:registrar"),IP=32,kP=64;class RP{constructor(e){this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onProtocolChange=this._onProtocolChange.bind(this),this.components.getConnectionManager().addEventListener("peer:disconnect",this._onDisconnect),this.components.getPeerStore().addEventListener("change:protocols",this._onProtocolChange)}getProtocols(){return Array.from(new Set([...this.topologies.keys(),...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(null==t)throw h(new Error(`No handler registered for protocol ${e}`),VT.ERR_NO_HANDLER_FOR_PROTOCOL);return t}getTopologies(e){const t=this.topologies.get(e);return null==t?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e))throw h(new Error(`Handler already registered for protocol ${e}`),VT.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);const s=c.Z.bind({ignoreUndefined:!0})({maxInboundStreams:IP,maxOutboundStreams:kP},r);this.handlers.set(e,{handler:t,options:s}),await this.components.getPeerStore().protoBook.add(this.components.getPeerId(),[e])}async unhandle(e){const t=Array.isArray(e)?e:[e];t.forEach((e=>{this.handlers.delete(e)})),await this.components.getPeerStore().protoBook.remove(this.components.getPeerId(),t)}async register(e,t){if(!(0,vP.w)(t))throw SP.error("topology must be an instance of interfaces/topology"),h(new Error("topology must be an instance of interfaces/topology"),VT.ERR_INVALID_PARAMETERS);const r=`${(1e9*Math.random()).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return null==s&&(s=new Map,this.topologies.set(e,s)),s.set(r,t),await t.setRegistrar(this),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),0===r.size&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.getPeerStore().protoBook.get(t.remotePeer).then((e=>{for(const r of e){const e=this.topologies.get(r);if(null!=e)for(const r of e.values())r.onDisconnect(t.remotePeer)}})).catch((e=>{SP.error(e)}))}_onProtocolChange(e){const{peerId:t,protocols:r,oldProtocols:s}=e.detail,n=s.filter((e=>!r.includes(e))),i=r.filter((e=>!s.includes(e)));for(const o of n){const e=this.topologies.get(o);if(null!=e)for(const r of e.values())r.onDisconnect(t)}for(const o of i){const e=this.topologies.get(o);if(null!=e)for(const r of e.values()){const e=this.components.getConnectionManager().getConnections(t)[0];null!=e&&r.onConnect(t,e)}}}}const TP=(0,u.kg)("libp2p:upgrader");function AP(e,t){try{const{options:r}=t.getHandler(e);return r.maxInboundStreams}catch(mu){if(mu.code!==VT.ERR_NO_HANDLER_FOR_PROTOCOL)throw mu}return IP}function CP(e,t){try{const{options:r}=t.getHandler(e);return r.maxOutboundStreams}catch(mu){if(mu.code!==VT.ERR_NO_HANDLER_FOR_PROTOCOL)throw mu}return kP}function PP(e,t,r){let s=0;return r.streams.forEach((r=>{r.stat.direction===t&&r.stat.protocol===e&&s++})),s}class DP extends HE.v{constructor(e,t){super(),this.components=e,this.connectionEncryption=new Map,t.connectionEncryption.forEach((e=>{this.connectionEncryption.set(e.protocol,e)})),this.muxers=new Map,t.muxers.forEach((e=>{this.muxers.set(e.protocol,e)})),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout}async upgradeInbound(e){let t,r,s,n,i,o,a;const c=this.components.getMetrics(),l=new Fe.TimeoutController(this.inboundUpgradeTimeout);try{(0,qT.setMaxListeners)?.(1/0,l.signal)}catch{}try{const u=YA(e,l.signal);if(e.source=u.source,e.sink=u.sink,await this.components.getConnectionGater().denyInboundConnection(e))throw h(new Error("The multiaddr connection is blocked by gater.acceptConnection"),VT.ERR_CONNECTION_INTERCEPTED);if(null!=c){({setTarget:o,proxy:a}=mP());const t=`${(1e9*Math.random()).toString(36)}${Date.now()}`;o({toString:()=>t}),c.trackStream({stream:e,remotePeer:a})}TP("starting the inbound connection upgrade");let d=e;const p=this.components.getConnectionProtector();null!=p&&(TP("protecting the inbound connection"),d=await p.protect(e));try{if(({conn:t,remotePeer:r,protocol:i}=await this._encryptInbound(d)),await this.components.getConnectionGater().denyInboundEncryptedConnection(r,{...d,...t}))throw h(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"),VT.ERR_CONNECTION_INTERCEPTED);if(this.muxers.size>0){const e=await this._multiplexInbound({...d,...t},this.muxers);n=e.muxerFactory,s=e.stream}else s=t}catch(mu){throw TP.error("Failed to upgrade inbound connection",mu),await e.close(mu),mu}if(await this.components.getConnectionGater().denyInboundUpgradedConnection(r,{...d,...t}))throw h(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"),VT.ERR_CONNECTION_INTERCEPTED);return null!=c&&(c.updatePlaceholder(a,r),o(r)),TP("Successfully upgraded inbound connection"),this._createConnection({cryptoProtocol:i,direction:"inbound",maConn:e,upgradedConn:s,muxerFactory:n,remotePeer:r})}finally{l.clear()}}async upgradeOutbound(e){const t=e.remoteAddr.getPeerId();if(null==t)throw h(new Error("outbound connection must have a peer id"),VT.ERR_INVALID_MULTIADDR);const r=(0,Ht.jE)(t);if(await this.components.getConnectionGater().denyOutboundConnection(r,e))throw h(new Error("The multiaddr connection is blocked by connectionGater.denyOutboundConnection"),VT.ERR_CONNECTION_INTERCEPTED);let s,n,i,o,a,c,l;const u=this.components.getMetrics();if(null!=u){({setTarget:c,proxy:l}=mP());const t=`${(1e9*Math.random()).toString(36)}${Date.now()}`;c({toB58String:()=>t}),u.trackStream({stream:e,remotePeer:l})}TP("Starting the outbound connection upgrade");let d=e;const p=this.components.getConnectionProtector();null!=p&&(d=await p.protect(e));try{if(({conn:s,remotePeer:n,protocol:o}=await this._encryptOutbound(d,r)),await this.components.getConnectionGater().denyOutboundEncryptedConnection(n,{...d,...s}))throw h(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"),VT.ERR_CONNECTION_INTERCEPTED);if(this.muxers.size>0){const e=await this._multiplexOutbound({...d,...s},this.muxers);a=e.muxerFactory,i=e.stream}else i=s}catch(mu){throw TP.error("Failed to upgrade outbound connection",mu),await e.close(mu),mu}if(await this.components.getConnectionGater().denyOutboundUpgradedConnection(n,{...d,...s}))throw h(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"),VT.ERR_CONNECTION_INTERCEPTED);return null!=u&&(u.updatePlaceholder(l,n),c(n)),TP("Successfully upgraded outbound connection"),this._createConnection({cryptoProtocol:o,direction:"outbound",maConn:e,upgradedConn:i,muxerFactory:a,remotePeer:n})}_createConnection(e){const{cryptoProtocol:t,direction:r,maConn:s,upgradedConn:n,remotePeer:i,muxerFactory:o}=e;let a,c,l;null!=o&&(a=o.createStreamMuxer({direction:r,onIncomingStream:e=>{null!=l&&Promise.resolve().then((async()=>{const t=this.components.getRegistrar().getProtocols(),{stream:s,protocol:n}=await gP(e,t);TP("%s: incoming stream opened on %s",r,n);const o=this.components.getMetrics();if(null!=o&&o.trackStream({stream:s,remotePeer:i,protocol:n}),null==l)return;const a=AP(n,this.components.getRegistrar()),c=PP(n,"inbound",l);c!==a?(e.source=s.source,e.sink=s.sink,e.stat.protocol=n,this.components.getPeerStore().protoBook.add(i,[n]).catch((e=>TP.error(e))),l.addStream(e),this._onStream({connection:l,stream:e,protocol:n})):e.abort(h(new Error(`Too many inbound protocol streams for protocol "${n}" - limit ${a}`),VT.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS))})).catch((t=>{TP.error(t),null==e.stat.timeline.close&&e.close()}))},onStreamEnd:e=>{l?.removeStream(e.id)}}),(0,nS.G)(a)&&a.init(this.components),c=async(e,t={})=>{if(null==a)throw h(new Error("Stream is not multiplexed"),VT.ERR_MUXER_UNAVAILABLE);TP("%s: starting new stream on %s",r,e);const s=a.newStream(),n=this.components.getMetrics();let o;try{if(null==t.signal){TP("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout",e),o=new Fe.TimeoutController(3e4),t.signal=o.signal;try{(0,qT.setMaxListeners)?.(1/0,o.signal)}catch{}}const{stream:r,protocol:a}=await fP(s,e,t);null!=n&&n.trackStream({stream:r,remotePeer:i,protocol:a});const c=CP(a,this.components.getRegistrar()),u=PP(a,"outbound",l);if(u===c){const e=h(new Error(`Too many outbound protocol streams for protocol "${a}" - limit ${c}`),VT.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);throw s.abort(e),e}return this.components.getPeerStore().protoBook.add(i,[a]).catch((e=>TP.error(e))),s.source=r.source,s.sink=r.sink,s.stat.protocol=a,s}catch(mu){if(TP.error("could not create new stream",mu),null==s.stat.timeline.close&&s.close(),null!=mu.code)throw mu;throw h(mu,VT.ERR_UNSUPPORTED_PROTOCOL)}finally{null!=o&&o.clear()}},(0,Cs.zG)(n,a,n).catch(TP.error));const u=s.timeline;s.timeline=new Proxy(u,{set:(...e)=>(null!=l&&"close"===e[1]&&null!=e[2]&&null==u.close&&(async()=>{try{"OPEN"===l.stat.status&&await l.close()}catch(mu){TP.error(mu)}finally{this.dispatchEvent(new HE.A("connectionEnd",{detail:l}))}})().catch((e=>{TP.error(e)})),Reflect.set(...e))}),s.timeline.upgraded=Date.now();const d=()=>{throw h(new Error("connection is not multiplexed"),VT.ERR_CONNECTION_NOT_MULTIPLEXED)};return l=EP({remoteAddr:s.remoteAddr,remotePeer:i,stat:{status:"OPEN",direction:r,timeline:s.timeline,multiplexer:a?.protocol,encryption:t},newStream:c??d,getStreams:()=>null!=a?a.streams:d(),close:async()=>{await s.close(),null!=a&&a.close()}}),this.dispatchEvent(new HE.A("connection",{detail:l})),l}_onStream(e){const{connection:t,stream:r,protocol:s}=e,{handler:n}=this.components.getRegistrar().getHandler(s);n({connection:t,stream:r})}async _encryptInbound(e){const t=Array.from(this.connectionEncryption.keys());TP("handling inbound crypto protocol selection",t);try{const{stream:r,protocol:s}=await gP(e,t,{writeBytes:!0}),n=this.connectionEncryption.get(s);if(null==n)throw new Error(`no crypto module found for ${s}`);return TP("encrypting inbound connection..."),{...await n.secureInbound(this.components.getPeerId(),r),protocol:s}}catch(mu){throw h(mu,VT.ERR_ENCRYPTION_FAILED)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncryption.keys());TP("selecting outbound crypto protocol",r);try{const{stream:s,protocol:n}=await fP(e,r,{writeBytes:!0}),i=this.connectionEncryption.get(n);if(null==i)throw new Error(`no crypto module found for ${n}`);return TP("encrypting outbound connection to %p",t),{...await i.secureOutbound(this.components.getPeerId(),s,t),protocol:n}}catch(mu){throw h(mu,VT.ERR_ENCRYPTION_FAILED)}}async _multiplexOutbound(e,t){const r=Array.from(t.keys());TP("outbound selecting muxer %s",r);try{const{stream:s,protocol:n}=await fP(e,r,{writeBytes:!0});TP("%s selected as muxer protocol",n);const i=t.get(n);return{stream:s,muxerFactory:i}}catch(mu){throw TP.error("error multiplexing outbound stream",mu),h(mu,VT.ERR_MUXER_UNAVAILABLE)}}async _multiplexInbound(e,t){const r=Array.from(t.keys());TP("inbound handling muxers %s",r);try{const{stream:s,protocol:n}=await gP(e,r,{writeBytes:!0}),i=t.get(n);return{stream:s,muxerFactory:i}}catch(mu){throw TP.error("error multiplexing inbound stream",mu),h(mu,VT.ERR_MUXER_UNAVAILABLE)}}}var NP;(function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.protocolVersion&&(t.uint32(42),t.string(e.protocolVersion)),null!=e.agentVersion&&(t.uint32(50),t.string(e.agentVersion)),null!=e.publicKey&&(t.uint32(10),t.bytes(e.publicKey)),null==e.listenAddrs)throw new Error('Protocol error: required field "listenAddrs" was not found in object');for(const s of e.listenAddrs)t.uint32(18),t.bytes(s);if(null!=e.observedAddr&&(t.uint32(34),t.bytes(e.observedAddr)),null==e.protocols)throw new Error('Protocol error: required field "protocols" was not found in object');for(const s of e.protocols)t.uint32(26),t.string(s);null!=e.signedPeerRecord&&(t.uint32(66),t.bytes(e.signedPeerRecord)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 5:r.protocolVersion=e.string();break;case 6:r.agentVersion=e.string();break;case 1:r.publicKey=e.bytes();break;case 2:r.listenAddrs=r.listenAddrs??[],r.listenAddrs.push(e.bytes());break;case 4:r.observedAddr=e.bytes();break;case 3:r.protocols=r.protocols??[],r.protocols.push(e.string());break;case 8:r.signedPeerRecord=e.bytes();break;default:e.skipType(7&t);break}}if(r.listenAddrs=r.listenAddrs??[],r.protocols=r.protocols??[],null==r.listenAddrs)throw new Error('Protocol error: value for required field "listenAddrs" was not found in protobuf');if(null==r.protocols)throw new Error('Protocol error: value for required field "protocols" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(NP||(NP={}));const OP="0.0.0",LP="libp2p",xP=`js-libp2p/${OP}`,MP="0.1.0",BP="id",UP="id/push",jP="1.0.0",VP="1.0.0",zP=(0,u.kg)("libp2p:identify"),FP=8192;class $P{constructor(e,t){this.components=e,this.started=!1,this.init=t,this.identifyProtocolStr=`/${t.protocolPrefix}/${BP}/${jP}`,this.identifyPushProtocolStr=`/${t.protocolPrefix}/${UP}/${VP}`,this.host={protocolVersion:`${t.protocolPrefix}/${MP}`,...t.host},this.components.getConnectionManager().addEventListener("peer:connect",(e=>{const t=e.detail;this.identify(t).catch(zP.error)})),this.components.getPeerStore().addEventListener("change:multiaddrs",(e=>{const{peerId:t}=e.detail;this.components.getPeerId().equals(t)&&this.pushToPeerStore().catch((e=>zP.error(e)))})),this.components.getPeerStore().addEventListener("change:protocols",(e=>{const{peerId:t}=e.detail;this.components.getPeerId().equals(t)&&this.pushToPeerStore().catch((e=>zP.error(e)))}))}isStarted(){return this.started}async start(){this.started||(await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(),"AgentVersion",(0,ze.m)(this.host.agentVersion)),await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(),"ProtocolVersion",(0,ze.m)(this.host.protocolVersion)),await this.components.getRegistrar().handle(this.identifyProtocolStr,(e=>{this._handleIdentify(e).catch((e=>{zP.error(e)}))}),{maxInboundStreams:this.init.maxInboundStreams,maxOutboundStreams:this.init.maxOutboundStreams}),await this.components.getRegistrar().handle(this.identifyPushProtocolStr,(e=>{this._handlePush(e).catch((e=>{zP.error(e)}))}),{maxInboundStreams:this.init.maxPushIncomingStreams,maxOutboundStreams:this.init.maxPushOutgoingStreams}),this.started=!0)}async stop(){await this.components.getRegistrar().unhandle(this.identifyProtocolStr),await this.components.getRegistrar().unhandle(this.identifyPushProtocolStr),this.started=!1}async push(e){const t=await this.components.getPeerStore().addressBook.getRawEnvelope(this.components.getPeerId()),r=this.components.getAddressManager().getAddresses().map((e=>e.bytes)),s=await this.components.getPeerStore().protoBook.get(this.components.getPeerId()),n=e.map((async e=>{let n;const i=new Fe.TimeoutController(this.init.timeout);try{(0,qT.setMaxListeners)?.(1/0,i.signal)}catch{}try{n=await e.newStream([this.identifyPushProtocolStr],{signal:i.signal});const o=YA(n,i.signal);await(0,Cs.zG)([NP.encode({listenAddrs:r,signedPeerRecord:t,protocols:s})],PS.c(),o,gs)}catch(mu){zP.error("could not push identify update to peer",mu)}finally{null!=n&&n.close(),i.clear()}}));await Promise.all(n)}async pushToPeerStore(){if(!this.isStarted())return;const e=[];for(const t of this.components.getConnectionManager().getConnections()){const r=t.remotePeer,s=await this.components.getPeerStore().get(r);s.protocols.includes(this.identifyPushProtocolStr)&&e.push(t)}await this.push(e)}async _identify(e,t={}){let r,s,n=t.signal;if(null==n){r=new Fe.TimeoutController(this.init.timeout),n=r.signal;try{(0,qT.setMaxListeners)?.(1/0,r.signal)}catch{}}try{s=await e.newStream([this.identifyProtocolStr],{signal:n});const t=YA(s,n),i=await(0,Cs.zG)([],t,PS.J({maxDataLength:this.init.maxIdentifyMessageSize??FP}),(async e=>await sy(e)));if(null==i)throw h(new Error("No data could be retrieved"),VT.ERR_CONNECTION_ENDED);try{return NP.decode(i)}catch(mu){throw h(mu,VT.ERR_INVALID_MESSAGE)}}finally{null!=r&&r.clear(),null!=s&&s.close()}}async identify(e,t={}){const r=await this._identify(e,t),{publicKey:s,listenAddrs:n,protocols:i,observedAddr:o,signedPeerRecord:a,agentVersion:c,protocolVersion:l}=r;if(null==s)throw h(new Error("public key was missing from identify message"),VT.ERR_MISSING_PUBLIC_KEY);const u=await(0,Ht.y5)(s);if(!e.remotePeer.equals(u))throw h(new Error("identified peer does not match the expected peer"),VT.ERR_INVALID_PEER);if(this.components.getPeerId().equals(u))throw h(new Error("identified peer is our own peer id?"),VT.ERR_INVALID_PEER);const d=$P.getCleanMultiaddr(o);if(null!=a){zP("received signed peer record from %p",u);try{const e=await BE.openAndCertify(a,$E.DOMAIN);if(!e.peerId.equals(u))throw h(new Error("identified peer does not match the expected peer"),VT.ERR_INVALID_PEER);if(await this.components.getPeerStore().addressBook.consumePeerRecord(e))return await this.components.getPeerStore().protoBook.set(u,i),null!=c&&await this.components.getPeerStore().metadataBook.setValue(u,"AgentVersion",(0,ze.m)(c)),null!=l&&await this.components.getPeerStore().metadataBook.setValue(u,"ProtocolVersion",(0,ze.m)(l)),void zP("identify completed for peer %p and protocols %o",u,i)}catch(mu){zP("received invalid envelope, discard it and fallback to listenAddrs is available",mu)}}else zP("no signed peer record received from %p",u);zP("falling back to legacy addresses from %p",u);try{await this.components.getPeerStore().addressBook.set(u,n.map((e=>(0,qe.HM)(e))))}catch(mu){zP.error("received invalid addrs",mu)}await this.components.getPeerStore().protoBook.set(u,i),null!=c&&await this.components.getPeerStore().metadataBook.setValue(u,"AgentVersion",(0,ze.m)(c)),null!=l&&await this.components.getPeerStore().metadataBook.setValue(u,"ProtocolVersion",(0,ze.m)(l)),zP("identify completed for peer %p and protocols %o",u,i),zP("received observed address of %s",d?.toString())}async _handleIdentify(e){const{connection:t,stream:r}=e,s=new Fe.TimeoutController(this.init.timeout);try{(0,qT.setMaxListeners)?.(1/0,s.signal)}catch{}try{const e=this.components.getPeerId().publicKey??new Uint8Array(0),n=await this.components.getPeerStore().get(this.components.getPeerId()),i=this.components.getAddressManager().getAddresses().map((e=>e.decapsulateCode((0,qe.a_)("p2p").code)));let o=n.peerRecordEnvelope;if(i.length>0&&null==o){const e=new $E({peerId:this.components.getPeerId(),multiaddrs:i}),t=await BE.seal(e,this.components.getPeerId());await this.components.getPeerStore().addressBook.consumePeerRecord(t),o=t.marshal().subarray()}const a=NP.encode({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:e,listenAddrs:i.map((e=>e.bytes)),signedPeerRecord:o,observedAddr:t.remoteAddr.bytes,protocols:n.protocols}),c=YA(r,s.signal);await(0,Cs.zG)([a],PS.c(),c,gs)}catch(mu){zP.error("could not respond to identify request",mu)}finally{r.close(),s.clear()}}async _handlePush(e){const{connection:t,stream:r}=e,s=new Fe.TimeoutController(this.init.timeout);try{(0,qT.setMaxListeners)?.(1/0,s.signal)}catch{}let n;try{const e=YA(r,s.signal),t=await(0,Cs.zG)([],e,PS.J({maxDataLength:this.init.maxIdentifyMessageSize??FP}),(async e=>await sy(e)));null!=t&&(n=NP.decode(t))}catch(mu){return zP.error("received invalid message",mu)}finally{r.close(),s.clear()}if(null==n)return zP.error("received invalid message");const i=t.remotePeer;if(this.components.getPeerId().equals(i))zP("received push from ourselves?");else{if(zP("received push from %p",i),null!=n.signedPeerRecord){zP("received signedPeerRecord in push");try{const e=await BE.openAndCertify(n.signedPeerRecord,$E.DOMAIN);if(await this.components.getPeerStore().addressBook.consumePeerRecord(e))return zP("consumed signedPeerRecord sent in push"),void await this.components.getPeerStore().protoBook.set(i,n.protocols);zP("failed to consume signedPeerRecord sent in push")}catch(mu){zP("received invalid envelope, discard it and fallback to listenAddrs is available",mu)}}else zP("did not receive signedPeerRecord in push");try{await this.components.getPeerStore().addressBook.set(i,n.listenAddrs.map((e=>(0,qe.HM)(e))))}catch(mu){zP.error("received invalid addrs",mu)}try{await this.components.getPeerStore().protoBook.set(i,n.protocols)}catch(mu){zP.error("received invalid protocols",mu)}zP("handled push from %p",i)}}static getCleanMultiaddr(e){if(null!=e&&e.length>0)try{return(0,qe.HM)(e)}catch{}}}var KP,HP;(function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.identifier)throw new Error('Protocol error: required field "identifier" was not found in object');t.uint32(10),t.string(e.identifier),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.identifier=e.string();break;default:e.skipType(7&t);break}}if(null==r.identifier)throw new Error('Protocol error: value for required field "identifier" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(KP||(KP={})),function(e){let t,r,s;(function(e){e["OK"]="OK",e["NOT_FOUND"]="NOT_FOUND",e["ERROR"]="ERROR"})(t=e.StatusCode||(e.StatusCode={})),function(e){e[e["OK"]=0]="OK",e[e["NOT_FOUND"]=1]="NOT_FOUND",e[e["ERROR"]=2]="ERROR"}(r||(r={})),function(e){e.codec=()=>(0,Sr.Ji)(r)}(t=e.StatusCode||(e.StatusCode={})),e.codec=()=>(null==s&&(s=(0,Sr.yw)(((t,r,s={})=>{if(!1!==s.lengthDelimited&&r.fork(),null==t.status)throw new Error('Protocol error: required field "status" was not found in object');if(r.uint32(8),e.StatusCode.codec().encode(t.status,r),null==t.data)throw new Error('Protocol error: required field "data" was not found in object');r.uint32(18),r.bytes(t.data),!1!==s.lengthDelimited&&r.ldelim()}),((t,r)=>{const s={},n=null==r?t.len:t.pos+r;while(t.pos<n){const r=t.uint32();switch(r>>>3){case 1:s.status=e.StatusCode.codec().decode(t);break;case 2:s.data=t.bytes();break;default:t.skipType(7&r);break}}if(null==s.status)throw new Error('Protocol error: value for required field "status" was not found in protobuf');if(null==s.data)throw new Error('Protocol error: value for required field "data" was not found in protobuf');return s}))),s),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())}(HP||(HP={}));const qP="0.0.1",GP="fetch",WP=(0,u.kg)("libp2p:fetch");class YP{constructor(e,t){this.started=!1,this.components=e,this.protocol=`/${t.protocolPrefix??"libp2p"}/${GP}/${qP}`,this.lookupFunctions=new Map,this.handleMessage=this.handleMessage.bind(this),this.init=t}async start(){await this.components.getRegistrar().handle(this.protocol,(e=>{this.handleMessage(e).catch((e=>{WP.error(e)})).finally((()=>{e.stream.close()}))}),{maxInboundStreams:this.init.maxInboundStreams,maxOutboundStreams:this.init.maxOutboundStreams}),this.started=!0}async stop(){await this.components.getRegistrar().unhandle(this.protocol),this.started=!1}isStarted(){return this.started}async fetch(e,t,r={}){WP("dialing %s to %p",this.protocol,e);const s=await this.components.getConnectionManager().openConnection(e,r);let n,i,o=r.signal;if(null==o){n=new Fe.TimeoutController(this.init.timeout),o=n.signal;try{(0,qT.setMaxListeners)?.(1/0,n.signal)}catch{}}try{i=await s.newStream([this.protocol],{signal:o});const e=YA(i,o),r=await(0,Cs.zG)([KP.encode({identifier:t})],PS.c(),e,PS.J(),(async function(e){const t=await sy(e);if(null==t)throw h(new Error("No data received"),VT.ERR_INVALID_MESSAGE);const r=HP.decode(t);switch(r.status){case HP.StatusCode.OK:return r.data;case HP.StatusCode.NOT_FOUND:return null;case HP.StatusCode.ERROR:{const e=(new TextDecoder).decode(r.data);throw h(new Error("Error in fetch protocol response: "+e),VT.ERR_INVALID_PARAMETERS)}default:throw h(new Error("Unknown response status"),VT.ERR_INVALID_MESSAGE)}}));return r??null}finally{null!=n&&n.clear(),null!=i&&i.close()}}async handleMessage(e){const{stream:t}=e,r=this;await(0,Cs.zG)(t,PS.J(),(async function*(e){const t=await sy(e);if(null==t)throw h(new Error("No data received"),VT.ERR_INVALID_MESSAGE);const s=KP.decode(t);let n;const i=r._getLookupFunction(s.identifier);if(null!=i){const e=await i(s.identifier);n=null!=e?{status:HP.StatusCode.OK,data:e}:{status:HP.StatusCode.NOT_FOUND,data:new Uint8Array(0)}}else{const e=(new TextEncoder).encode("No lookup function registered for key: "+s.identifier);n={status:HP.StatusCode.ERROR,data:e}}yield HP.encode(n)}),PS.c(),t)}_getLookupFunction(e){for(const t of this.lookupFunctions.keys())if(e.startsWith(t))return this.lookupFunctions.get(t)}registerLookupFunction(e,t){if(this.lookupFunctions.has(e))throw h(new Error("Fetch protocol handler for key prefix '"+e+"' already registered"),VT.ERR_KEY_ALREADY_EXISTS);this.lookupFunctions.set(e,t)}unregisterLookupFunction(e,t){if(null!=t){const r=this.lookupFunctions.get(e);if(r!==t)return}this.lookupFunctions.delete(e)}}const QP=32,ZP="1.0.0",XP="ping",JP=(0,u.kg)("libp2p:ping");class eD{constructor(e,t){this.components=e,this.started=!1,this.protocol=`/${t.protocolPrefix}/${XP}/${ZP}`,this.init=t}async start(){await this.components.getRegistrar().handle(this.protocol,this.handleMessage,{maxInboundStreams:this.init.maxInboundStreams,maxOutboundStreams:this.init.maxOutboundStreams}),this.started=!0}async stop(){await this.components.getRegistrar().unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){const{stream:t}=e;(0,Cs.zG)(t,t).catch((e=>{JP.error(e)}))}async ping(e,t={}){JP("dialing %s to %p",this.protocol,e);const r=Date.now(),s=(0,gS.O6)(QP),n=await this.components.getConnectionManager().openConnection(e,t);let i,o,a=t.signal;if(null==a){i=new Fe.TimeoutController(this.init.timeout),a=i.signal;try{(0,qT.setMaxListeners)?.(1/0,i.signal)}catch{}}try{o=await n.newStream([this.protocol],{signal:a});const e=YA(o,a),t=await(0,Cs.zG)([s],e,(async e=>await sy(e))),c=Date.now();if(null==t||!(0,ur.f)(s,t.subarray()))throw h(new Error("Received wrong ping ack"),VT.ERR_WRONG_PING_ACK);return c-r}finally{null!=i&&i.clear(),null!=o&&o.close()}}}async function tD(){throw new Error("Not supported in browsers")}var rD=r(14560);function sD(e){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(e)||/^::1$/.test(e)}function nD(e){const{address:t}=e.nodeAddress();return sD(t)}const iD=(0,u.kg)("libp2p:nat"),oD=7200;function aD(e=1024,t=65535){return Math.floor(Math.random()*(t-e+1)+e)}class cD{constructor(e,t){if(this.components=e,this.started=!1,this.enabled=t.enabled,this.externalAddress=t.externalAddress,this.localAddress=t.localAddress,this.description=t.description??`${LP}@${OP} ${this.components.getPeerId().toString()}`,this.ttl=t.ttl??oD,this.keepAlive=t.keepAlive??!0,this.gateway=t.gateway,this.ttl<oD)throw h(new Error(`NatManager ttl should be at least ${oD} seconds`),VT.ERR_INVALID_PARAMETERS)}isStarted(){return this.started}start(){}afterStart(){rD.jU||!this.enabled||this.started||(this.started=!0,this._start().catch((e=>{iD.error(e)})))}async _start(){const e=this.components.getTransportManager().getAddrs();for(const t of e){const{family:e,host:r,port:s,transport:n}=t.toOptions();if(!t.isThinWaistAddress()||"tcp"!==n)continue;if(nD(t))continue;if(4!==e)continue;const i=await this._getClient(),o=this.externalAddress??await i.externalIp();if(oC(o))throw new Error(`${o} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);const a=aD();iD(`opening uPnP connection from ${o}:${a} to ${r}:${s}`),await i.map({publicPort:a,localPort:s,localAddress:this.localAddress,protocol:"TCP"===n.toUpperCase()?"TCP":"UDP"}),this.components.getAddressManager().addObservedAddr((0,qe.uv)({family:4,address:o,port:a},n))}}async _getClient(){return null!=this.client||(this.client=await tD({description:this.description,ttl:this.ttl,keepAlive:this.keepAlive,gateway:this.gateway})),this.client}async stop(){if(!rD.jU&&null!=this.client)try{await this.client.close(),this.client=void 0}catch(mu){iD.error(mu)}}}const lD=(0,u.kg)("libp2p:peer-record-updater");class uD{constructor(e){this.components=e,this.started=!1,this.update=this.update.bind(this)}isStarted(){return this.started}async start(){this.started=!0,this.components.getTransportManager().addEventListener("listener:listening",this.update),this.components.getTransportManager().addEventListener("listener:close",this.update),this.components.getAddressManager().addEventListener("change:addresses",this.update)}async stop(){this.started=!1,this.components.getTransportManager().removeEventListener("listener:listening",this.update),this.components.getTransportManager().removeEventListener("listener:close",this.update),this.components.getAddressManager().removeEventListener("change:addresses",this.update)}update(){Promise.resolve().then((async()=>{const e=new $E({peerId:this.components.getPeerId(),multiaddrs:this.components.getAddressManager().getAddresses().map((e=>e.decapsulateCode((0,qe.a_)("p2p").code)))}),t=await BE.seal(e,this.components.getPeerId());await this.components.getPeerStore().addressBook.consumePeerRecord(t)})).catch((e=>{lD.error("Could not update self peer record: %o",e)}))}}class hD{constructor(e){this.dht=e}async findPeer(e,t={}){for await(const r of this.dht.findPeer(e,t))if("FINAL_PEER"===r.name)return r.peer;throw h(new Error(jT.NOT_FOUND),VT.ERR_NOT_FOUND)}async*getClosestPeers(e,t={}){for await(const r of this.dht.getClosestPeers(e,t))"PEER_RESPONSE"===r.name&&(yield*r.closer)}}const dD={ERR_INVALID_PARAMETERS:"ERR_INVALID_PARAMETERS",ERR_NOT_FOUND:"ERR_NOT_FOUND"},pD=(0,u.kg)("libp2p:peer-store:address-book"),fD="change:multiaddrs";async function yD(){return!0}class gD{constructor(e,t,r){this.dispatchEvent=e,this.store=t,this.addressFilter=r??yD}async consumePeerRecord(e){pD.trace("consumePeerRecord await write lock");const t=await this.store.lock.writeLock();let r,s,n;pD.trace("consumePeerRecord got write lock");try{let i;try{i=$E.createFromProtobuf(e.payload)}catch(mu){return pD.error("invalid peer record received"),!1}r=i.peerId;const o=i.multiaddrs;if(!r.equals(e.peerId))return pD("signing key does not match PeerId in the PeerRecord"),!1;if(null==o||0===o.length)return!1;if(await this.store.has(r)&&(s=await this.store.load(r),null!=s.peerRecordEnvelope)){const e=await BE.createFromProtobuf(s.peerRecordEnvelope),t=$E.createFromProtobuf(e.payload);if(t.seqNumber>=i.seqNumber)return pD("sequence number was lower or equal to existing sequence number - stored: %d received: %d",t.seqNumber,i.seqNumber),!1}const a=await mD(r,o,this.addressFilter,!0);n=await this.store.patchOrCreate(r,{addresses:a,peerRecordEnvelope:e.marshal().subarray()}),pD("stored provided peer record for %p",i.peerId)}finally{pD.trace("consumePeerRecord release write lock"),t()}return this.dispatchEvent(new HE.A(fD,{detail:{peerId:r,multiaddrs:n.addresses.map((({multiaddr:e})=>e)),oldMultiaddrs:null==s?[]:s.addresses.map((({multiaddr:e})=>e))}})),!0}async getRawEnvelope(e){pD.trace("getRawEnvelope await read lock");const t=await this.store.lock.readLock();pD.trace("getRawEnvelope got read lock");try{const r=await this.store.load(e);return r.peerRecordEnvelope}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}finally{pD.trace("getRawEnvelope release read lock"),t()}}async getPeerRecord(e){const t=await this.getRawEnvelope(e);if(null!=t)return await BE.createFromProtobuf(t)}async get(e){e=(0,Ht.vL)(e),pD.trace("get wait for read lock");const t=await this.store.lock.readLock();pD.trace("get got read lock");try{const r=await this.store.load(e);return r.addresses}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}finally{pD.trace("get release read lock"),t()}return[]}async set(e,t){if(e=(0,Ht.vL)(e),!Array.isArray(t))throw pD.error("multiaddrs must be an array of Multiaddrs"),h(new Error("multiaddrs must be an array of Multiaddrs"),dD.ERR_INVALID_PARAMETERS);pD.trace("set await write lock");const r=await this.store.lock.writeLock();pD.trace("set got write lock");let s,n,i=!1;try{const o=await mD(e,t,this.addressFilter);if(0===o.length)return;try{if(s=await this.store.load(e),i=!0,new Set([...o.map((({multiaddr:e})=>e.toString())),...s.addresses.map((({multiaddr:e})=>e.toString()))]).size===s.addresses.length&&o.length===s.addresses.length)return}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}n=await this.store.patchOrCreate(e,{addresses:o}),pD("set multiaddrs for %p",e)}finally{pD.trace("set multiaddrs for %p",e),pD("set release write lock"),r()}this.dispatchEvent(new HE.A(fD,{detail:{peerId:e,multiaddrs:n.addresses.map((e=>e.multiaddr)),oldMultiaddrs:null==s?[]:s.addresses.map((({multiaddr:e})=>e))}})),i||this.dispatchEvent(new HE.A("peer",{detail:{id:e,multiaddrs:n.addresses.map((e=>e.multiaddr)),protocols:n.protocols}}))}async add(e,t){if(e=(0,Ht.vL)(e),!Array.isArray(t))throw pD.error("multiaddrs must be an array of Multiaddrs"),h(new Error("multiaddrs must be an array of Multiaddrs"),dD.ERR_INVALID_PARAMETERS);pD.trace("add await write lock");const r=await this.store.lock.writeLock();let s,n,i;pD.trace("add got write lock");try{const o=await mD(e,t,this.addressFilter);if(0===o.length)return;try{if(n=await this.store.load(e),s=!0,new Set([...o.map((({multiaddr:e})=>e.toString())),...n.addresses.map((({multiaddr:e})=>e.toString()))]).size===n.addresses.length)return}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}i=await this.store.mergeOrCreate(e,{addresses:o}),pD("added multiaddrs for %p",e)}finally{pD.trace("set release write lock"),r()}this.dispatchEvent(new HE.A(fD,{detail:{peerId:e,multiaddrs:i.addresses.map((e=>e.multiaddr)),oldMultiaddrs:null==n?[]:n.addresses.map((({multiaddr:e})=>e))}})),!0===s&&this.dispatchEvent(new HE.A("peer",{detail:{id:e,multiaddrs:i.addresses.map((e=>e.multiaddr)),protocols:i.protocols}}))}async delete(e){e=(0,Ht.vL)(e),pD.trace("delete await write lock");const t=await this.store.lock.writeLock();let r;pD.trace("delete got write lock");try{try{r=await this.store.load(e)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}await this.store.patchOrCreate(e,{addresses:[]})}finally{pD.trace("delete release write lock"),t()}null!=r&&this.dispatchEvent(new HE.A(fD,{detail:{peerId:e,multiaddrs:[],oldMultiaddrs:null==r?[]:r.addresses.map((({multiaddr:e})=>e))}}))}}async function mD(e,t,r,s=!1){return await(0,Cs.zG)(t,(e=>OC(e,(e=>{if(!(0,qe.h2)(e))throw pD.error("multiaddr must be an instance of Multiaddr"),h(new Error("multiaddr must be an instance of Multiaddr"),dD.ERR_INVALID_PARAMETERS)}))),(t=>ms(t,(async t=>await r(e,t)))),(e=>As(e,(e=>({multiaddr:e,isCertified:s})))),(async e=>await fs(e)))}const wD=(0,u.kg)("libp2p:peer-store:key-book"),bD="change:pubkey";class _D{constructor(e,t){this.dispatchEvent=e,this.store=t}async set(e,t){if(e=(0,Ht.vL)(e),!(t instanceof Uint8Array))throw wD.error("publicKey must be an instance of Uint8Array to store data"),h(new Error("publicKey must be an instance of PublicKey"),dD.ERR_INVALID_PARAMETERS);wD.trace("set await write lock");const r=await this.store.lock.writeLock();wD.trace("set got write lock");let s,n=!1;try{try{if(s=await this.store.load(e),null!=s.pubKey&&(0,ur.f)(s.pubKey,t))return}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}await this.store.patchOrCreate(e,{pubKey:t}),n=!0}finally{wD.trace("set release write lock"),r()}n&&this.dispatchEvent(new HE.A(bD,{detail:{peerId:e,publicKey:t,oldPublicKey:null==s?void 0:s.pubKey}}))}async get(e){e=(0,Ht.vL)(e),wD.trace("get await write lock");const t=await this.store.lock.readLock();wD.trace("get got write lock");try{const r=await this.store.load(e);return r.pubKey}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}finally{wD("get release write lock"),t()}}async delete(e){e=(0,Ht.vL)(e),wD.trace("delete await write lock");const t=await this.store.lock.writeLock();let r;wD.trace("delete got write lock");try{try{r=await this.store.load(e)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}await this.store.patchOrCreate(e,{pubKey:void 0})}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}finally{wD.trace("delete release write lock"),t()}this.dispatchEvent(new HE.A(bD,{detail:{peerId:e,publicKey:void 0,oldPublicKey:null==r?void 0:r.pubKey}}))}}const ED=(0,u.kg)("libp2p:peer-store:metadata-book"),vD="change:metadata";class SD{constructor(e,t){this.dispatchEvent=e,this.store=t}async get(e){e=(0,Ht.vL)(e),ED.trace("get await read lock");const t=await this.store.lock.readLock();ED.trace("get got read lock");try{const r=await this.store.load(e);return r.metadata}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}finally{ED.trace("get release read lock"),t()}return new Map}async getValue(e,t){e=(0,Ht.vL)(e),ED.trace("getValue await read lock");const r=await this.store.lock.readLock();ED.trace("getValue got read lock");try{const s=await this.store.load(e);return s.metadata.get(t)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}finally{ED.trace("getValue release write lock"),r()}}async set(e,t){if(e=(0,Ht.vL)(e),!(t instanceof Map))throw ED.error("valid metadata must be provided to store data"),h(new Error("valid metadata must be provided"),dD.ERR_INVALID_PARAMETERS);ED.trace("set await write lock");const r=await this.store.lock.writeLock();let s;ED.trace("set got write lock");try{try{s=await this.store.load(e)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}await this.store.mergeOrCreate(e,{metadata:t})}finally{ED.trace("set release write lock"),r()}this.dispatchEvent(new HE.A(vD,{detail:{peerId:e,metadata:t,oldMetadata:null==s?new Map:s.metadata}}))}async setValue(e,t,r){if(e=(0,Ht.vL)(e),"string"!==typeof t||!(r instanceof Uint8Array))throw ED.error("valid key and value must be provided to store data"),h(new Error("valid key and value must be provided"),dD.ERR_INVALID_PARAMETERS);ED.trace("setValue await write lock");const s=await this.store.lock.writeLock();let n,i;ED.trace("setValue got write lock");try{try{n=await this.store.load(e);const s=n.metadata.get(t);if(null!=s&&(0,ur.f)(r,s))return}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}i=await this.store.mergeOrCreate(e,{metadata:new Map([[t,r]])})}finally{ED.trace("setValue release write lock"),s()}this.dispatchEvent(new HE.A(vD,{detail:{peerId:e,metadata:i.metadata,oldMetadata:null==n?new Map:n.metadata}}))}async delete(e){e=(0,Ht.vL)(e),ED.trace("delete await write lock");const t=await this.store.lock.writeLock();let r;ED.trace("delete got write lock");try{try{r=await this.store.load(e)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}null!=r&&await this.store.patch(e,{metadata:new Map})}finally{ED.trace("delete release write lock"),t()}null!=r&&this.dispatchEvent(new HE.A(vD,{detail:{peerId:e,metadata:new Map,oldMetadata:r.metadata}}))}async deleteValue(e,t){e=(0,Ht.vL)(e),ED.trace("deleteValue await write lock");const r=await this.store.lock.writeLock();let s,n;ED.trace("deleteValue got write lock");try{n=await this.store.load(e),s=n.metadata,s.delete(t),await this.store.patch(e,{metadata:s})}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}finally{ED.trace("deleteValue release write lock"),r()}null!=s&&this.dispatchEvent(new HE.A(vD,{detail:{peerId:e,metadata:s,oldMetadata:null==n?new Map:n.metadata}}))}}const ID=(0,u.kg)("libp2p:peer-store:proto-book"),kD="change:protocols";class RD{constructor(e,t){this.dispatchEvent=e,this.store=t}async get(e){ID.trace("get wait for read lock");const t=await this.store.lock.readLock();ID.trace("get got read lock");try{const r=await this.store.load(e);return r.protocols}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}finally{ID.trace("get release read lock"),t()}return[]}async set(e,t){if(e=(0,Ht.vL)(e),!Array.isArray(t))throw ID.error("protocols must be provided to store data"),h(new Error("protocols must be provided"),dD.ERR_INVALID_PARAMETERS);ID.trace("set await write lock");const r=await this.store.lock.writeLock();let s,n;ID.trace("set got write lock");try{try{if(s=await this.store.load(e),new Set([...t]).size===s.protocols.length)return}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}n=await this.store.patchOrCreate(e,{protocols:t}),ID("stored provided protocols for %p",e)}finally{ID.trace("set release write lock"),r()}this.dispatchEvent(new HE.A(kD,{detail:{peerId:e,protocols:n.protocols,oldProtocols:null==s?[]:s.protocols}}))}async add(e,t){if(e=(0,Ht.vL)(e),!Array.isArray(t))throw ID.error("protocols must be provided to store data"),h(new Error("protocols must be provided"),dD.ERR_INVALID_PARAMETERS);ID.trace("add await write lock");const r=await this.store.lock.writeLock();let s,n;ID.trace("add got write lock");try{try{if(s=await this.store.load(e),new Set([...s.protocols,...t]).size===s.protocols.length)return}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}n=await this.store.mergeOrCreate(e,{protocols:t}),ID("added provided protocols for %p",e)}finally{ID.trace("add release write lock"),r()}this.dispatchEvent(new HE.A(kD,{detail:{peerId:e,protocols:n.protocols,oldProtocols:null==s?[]:s.protocols}}))}async remove(e,t){if(e=(0,Ht.vL)(e),!Array.isArray(t))throw ID.error("protocols must be provided to store data"),h(new Error("protocols must be provided"),dD.ERR_INVALID_PARAMETERS);ID.trace("remove await write lock");const r=await this.store.lock.writeLock();let s,n;ID.trace("remove got write lock");try{try{s=await this.store.load(e);const r=new Set(s.protocols);for(const e of t)r.delete(e);if(s.protocols.length===r.size)return;t=Array.from(r)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}n=await this.store.patchOrCreate(e,{protocols:t})}finally{ID.trace("remove release write lock"),r()}this.dispatchEvent(new HE.A(kD,{detail:{peerId:e,protocols:n.protocols,oldProtocols:null==s?[]:s.protocols}}))}async delete(e){e=(0,Ht.vL)(e),ID.trace("delete await write lock");const t=await this.store.lock.writeLock();let r;ID.trace("delete got write lock");try{try{r=await this.store.load(e)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu}await this.store.patchOrCreate(e,{protocols:[]})}finally{ID.trace("delete release write lock"),t()}null!=r&&this.dispatchEvent(new HE.A(kD,{detail:{peerId:e,protocols:[],oldProtocols:r.protocols}}))}}var TD,AD,CD;(function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.addresses)throw new Error('Protocol error: required field "addresses" was not found in object');for(const s of e.addresses)t.uint32(10),AD.codec().encode(s,t);if(null==e.protocols)throw new Error('Protocol error: required field "protocols" was not found in object');for(const s of e.protocols)t.uint32(18),t.string(s);if(null==e.metadata)throw new Error('Protocol error: required field "metadata" was not found in object');for(const s of e.metadata)t.uint32(26),CD.codec().encode(s,t);null!=e.pubKey&&(t.uint32(34),t.bytes(e.pubKey)),null!=e.peerRecordEnvelope&&(t.uint32(42),t.bytes(e.peerRecordEnvelope)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={addresses:[],protocols:[],metadata:[]},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.addresses.push(AD.codec().decode(e,e.uint32()));break;case 2:r.protocols.push(e.string());break;case 3:r.metadata.push(CD.codec().decode(e,e.uint32()));break;case 4:r.pubKey=e.bytes();break;case 5:r.peerRecordEnvelope=e.bytes();break;default:e.skipType(7&t);break}}return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(TD||(TD={})),function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.multiaddr)throw new Error('Protocol error: required field "multiaddr" was not found in object');t.uint32(10),t.bytes(e.multiaddr),null!=e.isCertified&&(t.uint32(16),t.bool(e.isCertified)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={multiaddr:new Uint8Array(0)},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.multiaddr=e.bytes();break;case 2:r.isCertified=e.bool();break;default:e.skipType(7&t);break}}if(null==r.multiaddr)throw new Error('Protocol error: value for required field "multiaddr" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())}(AD||(AD={})),function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.key)throw new Error('Protocol error: required field "key" was not found in object');if(t.uint32(10),t.string(e.key),null==e.value)throw new Error('Protocol error: required field "value" was not found in object');t.uint32(18),t.bytes(e.value),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={key:"",value:new Uint8Array(0)},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.key=e.string();break;case 2:r.value=e.bytes();break;default:e.skipType(7&t);break}}if(null==r.key)throw new Error('Protocol error: value for required field "key" was not found in protobuf');if(null==r.value)throw new Error('Protocol error: value for required field "value" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())}(CD||(CD={}));const PD=(0,u.kg)("libp2p:peer-store:store"),DD="/peers/";class ND{constructor(){this.components=new nS.z,this.lock=Zy({name:"peer-store",singleProcess:!0})}init(e){this.components=e}_peerIdToDatastoreKey(e){if(null==e.type)throw PD.error("peerId must be an instance of peer-id to store data"),h(new Error("peerId must be an instance of peer-id"),dD.ERR_INVALID_PARAMETERS);const t=e.toCID().toString();return new lt.s(`${DD}${t}`)}async has(e){return await this.components.getDatastore().has(this._peerIdToDatastoreKey(e))}async delete(e){await this.components.getDatastore().delete(this._peerIdToDatastoreKey(e))}async load(e){const t=await this.components.getDatastore().get(this._peerIdToDatastoreKey(e)),r=TD.decode(t),s=new Map;for(const n of r.metadata)s.set(n.key,n.value);return{...r,id:e,addresses:r.addresses.map((({multiaddr:e,isCertified:t})=>({multiaddr:(0,qe.HM)(e),isCertified:t??!1}))),metadata:s,pubKey:r.pubKey??void 0,peerRecordEnvelope:r.peerRecordEnvelope??void 0}}async save(e){if(null!=e.pubKey&&null!=e.id.publicKey&&!(0,ur.f)(e.pubKey,e.id.publicKey))throw PD.error("peer publicKey bytes do not match peer id publicKey bytes"),h(new Error("publicKey bytes do not match peer id publicKey bytes"),dD.ERR_INVALID_PARAMETERS);const t=new Set,r=e.addresses.filter((e=>!t.has(e.multiaddr.toString())&&(t.add(e.multiaddr.toString()),!0))).sort(((e,t)=>e.multiaddr.toString().localeCompare(t.multiaddr.toString()))).map((({multiaddr:e,isCertified:t})=>({multiaddr:e.bytes,isCertified:t}))),s=[];[...e.metadata.keys()].sort().forEach((t=>{const r=e.metadata.get(t);null!=r&&s.push({key:t,value:r})}));const n=TD.encode({addresses:r,protocols:e.protocols.sort(),pubKey:e.pubKey,metadata:s,peerRecordEnvelope:e.peerRecordEnvelope});return await this.components.getDatastore().put(this._peerIdToDatastoreKey(e.id),n.subarray()),await this.load(e.id)}async patch(e,t){const r=await this.load(e);return await this._patch(e,t,r)}async patchOrCreate(e,t){let r;try{r=await this.load(e)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu;r={id:e,addresses:[],protocols:[],metadata:new Map}}return await this._patch(e,t,r)}async _patch(e,t,r){return await this.save({...r,...t,id:e})}async merge(e,t){const r=await this.load(e);return await this._merge(e,t,r)}async mergeOrCreate(e,t){let r;try{r=await this.load(e)}catch(mu){if(mu.code!==dD.ERR_NOT_FOUND)throw mu;r={id:e,addresses:[],protocols:[],metadata:new Map}}return await this._merge(e,t,r)}async _merge(e,t,r){const s=new Map;return r.addresses.forEach((e=>{s.set(e.multiaddr.toString(),e.isCertified)})),(t.addresses??[]).forEach((e=>{const t=e.multiaddr.toString(),r=Boolean(s.get(t)),n=r||e.isCertified;s.set(t,n)})),await this.save({id:e,addresses:Array.from(s.entries()).map((([e,t])=>({multiaddr:(0,qe.HM)(e),isCertified:t}))),protocols:Array.from(new Set([...r.protocols??[],...t.protocols??[]])),metadata:new Map([...r.metadata?.entries()??[],...t.metadata?.entries()??[]]),pubKey:t.pubKey??(null!=r?r.pubKey:void 0),peerRecordEnvelope:t.peerRecordEnvelope??(null!=r?r.peerRecordEnvelope:void 0)})}async*all(){for await(const e of this.components.getDatastore().queryKeys({prefix:DD})){const t=e.toString().split("/")[2],r=Ke.base32.decode(t);yield this.load((0,Ht.cv)(r))}}}var OD,LD;(function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.tags)throw new Error('Protocol error: required field "tags" was not found in object');for(const s of e.tags)t.uint32(10),LD.codec().encode(s,t);!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={tags:[]},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.tags.push(LD.codec().decode(e,e.uint32()));break;default:e.skipType(7&t);break}}return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(OD||(OD={})),function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.name)throw new Error('Protocol error: required field "name" was not found in object');t.uint32(10),t.string(e.name),null!=e.value&&(t.uint32(16),t.uint32(e.value)),null!=e.expiry&&(t.uint32(24),t.uint64(e.expiry)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={name:""},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.name=e.string();break;case 2:r.value=e.uint32();break;case 3:r.expiry=e.uint64();break;default:e.skipType(7&t);break}}if(null==r.name)throw new Error('Protocol error: value for required field "name" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())}(LD||(LD={}));const xD=(0,u.kg)("libp2p:peer-store");class MD extends HE.v{constructor(e={}){super(),this.components=new nS.z,this.store=new ND,this.addressBook=new gD(this.dispatchEvent.bind(this),this.store,e.addressFilter),this.keyBook=new _D(this.dispatchEvent.bind(this),this.store),this.metadataBook=new SD(this.dispatchEvent.bind(this),this.store),this.protoBook=new RD(this.dispatchEvent.bind(this),this.store)}init(e){this.components=e,this.store.init(e)}async forEach(e){xD.trace("getPeers await read lock");const t=await this.store.lock.readLock();xD.trace("getPeers got read lock");try{for await(const t of this.store.all())t.id.equals(this.components.getPeerId())||e(t)}finally{xD.trace("getPeers release read lock"),t()}}async all(){const e=[];return await this.forEach((t=>{e.push(t)})),e}async delete(e){xD.trace("delete await write lock");const t=await this.store.lock.writeLock();xD.trace("delete got write lock");try{await this.store.delete(e)}finally{xD.trace("delete release write lock"),t()}}async get(e){xD.trace("get await read lock");const t=await this.store.lock.readLock();xD.trace("get got read lock");try{return await this.store.load(e)}finally{xD.trace("get release read lock"),t()}}async has(e){xD.trace("has await read lock");const t=await this.store.lock.readLock();xD.trace("has got read lock");try{return await this.store.has(e)}finally{xD.trace("has release read lock"),t()}}async tagPeer(e,t,r={}){const s=r.value??0,n=Math.round(s),i=r.ttl??void 0;if(n!==s||n<0||n>100)throw h(new Error("Tag value must be between 0-100"),"ERR_TAG_VALUE_OUT_OF_BOUNDS");const o=await this.metadataBook.getValue(e,"tags");let a=[];null!=o&&(a=OD.decode(o).tags);for(const c of a)if(c.name===t)throw h(new Error("Peer already tagged"),"ERR_DUPLICATE_TAG");a.push({name:t,value:n,expiry:null==i?void 0:BigInt(Date.now()+i)}),await this.metadataBook.setValue(e,"tags",OD.encode({tags:a}).subarray())}async unTagPeer(e,t){const r=await this.metadataBook.getValue(e,"tags");let s=[];null!=r&&(s=OD.decode(r).tags),s=s.filter((e=>e.name!==t)),await this.metadataBook.setValue(e,"tags",OD.encode({tags:s}).subarray())}async getTags(e){const t=await this.metadataBook.getValue(e,"tags");let r=[];null!=t&&(r=OD.decode(t).tags);const s=BigInt(Date.now()),n=r.filter((e=>null==e.expiry||e.expiry>s));return n.length!==r.length&&await this.metadataBook.setValue(e,"tags",OD.encode({tags:n}).subarray()),n.map((e=>({name:e.name,value:e.value??0})))}}class BD{constructor(e){this.dht=e}async provide(e){await gs(this.dht.provide(e))}async*findProviders(e,t={}){for await(const r of this.dht.findProviders(e,t))"PROVIDER"===r.name&&(yield*r.providers)}async put(e,t,r){await gs(this.dht.put(e,t,r))}async get(e,t){for await(const r of this.dht.get(e,t))if("VALUE"===r.name)return r.value;throw h(new Error("Not found"),"ERR_NOT_FOUND")}}const UD=(0,u.kg)("libp2p:dialer:auto-dialer");class jD{constructor(e,t){this.components=e,this.enabled=t.enabled,this.minConnections=t.minConnections,this.dialTimeout=t.dialTimeout}handle(e){const{detail:t}=e;if(!this.enabled)return;const r=this.components.getConnectionManager().getConnections(t.id);if(0===r.length){const e=this.minConnections??0,r=this.components.getConnectionManager().getConnections();if(e>r.length){UD("auto-dialing discovered peer %p with timeout %d",t.id,this.dialTimeout);const e=new Fe.TimeoutController(this.dialTimeout);try{(0,qT.setMaxListeners)?.(1/0,e.signal)}catch{}this.components.getConnectionManager().openConnection(t.id,{signal:e.signal}).catch((e=>{UD.error("could not connect to discovered peer %p with %o",t.id,e)})).finally((()=>{e.clear()}))}}}}var VD=r(20030),zD=r(73692);const FD=globalThis.fetch,$D=globalThis.Headers;globalThis.Request,globalThis.Response;function KD(e,t,r){return`${e}?name=${t}&type=${r}`}async function HD(e,t){const r=await FD(e,{headers:new $D({accept:"application/dns-json"}),signal:t}),s=await r.json();return s}function qD(e,t){return`${t}_${e}`}const GD=Object.assign(Nw("dns-over-http-resolver"),{error:Nw("dns-over-http-resolver:error")});class WD{constructor(e={}){this._cache=new zD({max:e?.maxCache??100}),this._TXTcache=new zD({max:e?.maxCache??100}),this._servers=["https://cloudflare-dns.com/dns-query","https://dns.google/resolve"],this._request=e.request??HD,this._abortControllers=[]}cancel(){this._abortControllers.forEach((e=>e.abort()))}getServers(){return this._servers}_getShuffledServers(){const e=[...this._servers];for(let t=e.length-1;t>0;t--){const r=Math.floor(Math.random()*t),s=e[t];e[t]=e[r],e[r]=s}return e}setServers(e){this._servers=e}async resolve(e,t="A"){switch(t){case"A":return await this.resolve4(e);case"AAAA":return await this.resolve6(e);case"TXT":return await this.resolveTxt(e);default:throw new Error(`${t} is not supported`)}}async resolve4(e){const t="A",r=this._cache.get(qD(e,t));if(null!=r)return r;let s=!1;for(const n of this._getShuffledServers()){const r=new AbortController;this._abortControllers.push(r);try{const s=await this._request(KD(n,e,t),r.signal),i=s.Answer.map((e=>e.data)),o=Math.min(...s.Answer.map((e=>e.TTL)));return this._cache.set(qD(e,t),i,{ttl:o}),i}catch(mu){r.signal.aborted&&(s=!0),GD.error(`${n} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter((e=>e!==r))}}if(s)throw Object.assign(new Error("queryA ECANCELLED"),{code:"ECANCELLED"});throw new Error(`Could not resolve ${e} record ${t}`)}async resolve6(e){const t="AAAA",r=this._cache.get(qD(e,t));if(null!=r)return r;let s=!1;for(const n of this._getShuffledServers()){const r=new AbortController;this._abortControllers.push(r);try{const s=await this._request(KD(n,e,t),r.signal),i=s.Answer.map((e=>e.data)),o=Math.min(...s.Answer.map((e=>e.TTL)));return this._cache.set(qD(e,t),i,{ttl:o}),i}catch(mu){r.signal.aborted&&(s=!0),GD.error(`${n} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter((e=>e!==r))}}if(s)throw Object.assign(new Error("queryAaaa ECANCELLED"),{code:"ECANCELLED"});throw new Error(`Could not resolve ${e} record ${t}`)}async resolveTxt(e){const t="TXT",r=this._TXTcache.get(qD(e,t));if(null!=r)return r;let s=!1;for(const n of this._getShuffledServers()){const r=new AbortController;this._abortControllers.push(r);try{const s=await this._request(KD(n,e,t),r.signal),i=s.Answer.map((e=>[e.data.replace(/['"]+/g,"")])),o=Math.min(...s.Answer.map((e=>e.TTL)));return this._TXTcache.set(qD(e,t),i,{ttl:o}),i}catch(mu){r.signal.aborted&&(s=!0),GD.error(`${n} could not resolve ${e} record ${t}`)}finally{this._abortControllers=this._abortControllers.filter((e=>e!==r))}}if(s)throw Object.assign(new Error("queryTxt ECANCELLED"),{code:"ECANCELLED"});throw new Error(`Could not resolve ${e} record ${t}`)}clearCache(){this._cache.clear(),this._TXTcache.clear()}}var YD=WD,QD=YD;const{code:ZD}=(0,VD.Ev)("dnsaddr");async function XD(e,t={}){const r=new QD;null!=t.signal&&t.signal.addEventListener("abort",(()=>{r.cancel()}));const s=e.getPeerId(),[,n]=e.stringTuples().find((([e])=>e===ZD))??[];if(null==n)throw new Error("No hostname found in multiaddr");const i=await r.resolveTxt(`_dnsaddr.${n}`);let o=i.flat().map((e=>e.split("=")[1]));return null!=s&&(o=o.filter((e=>e.includes(s)))),o}const JD={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:e=>e},connectionManager:{maxConnections:300,minConnections:50,autoDial:!0,autoDialInterval:1e4,maxParallelDials:MC,maxDialsPerPeer:BC,dialTimeout:LC,inboundUpgradeTimeout:xC,resolvers:{dnsaddr:XD},addressSorter:cC},connectionGater:{},transportManager:{faultTolerance:rP.FATAL_ALL},metrics:{enabled:!1,computeThrottleMaxQueueSize:1e3,computeThrottleTimeout:2e3,movingAverageIntervals:[6e4,3e5,9e5],maxOldPeersRetention:50},peerRouting:{refreshManager:{enabled:!0,interval:6e5,bootDelay:1e4}},nat:{enabled:!0,ttl:7200,keepAlive:!0},relay:{enabled:!0,advertise:{bootDelay:eC,enabled:!1,ttl:tC},hop:{enabled:!1,active:!1,timeout:3e4},autoRelay:{enabled:!1,maxListeners:2}},identify:{protocolPrefix:"ipfs",host:{agentVersion:xP},timeout:6e4,maxInboundStreams:1,maxOutboundStreams:1,maxPushIncomingStreams:1,maxPushOutgoingStreams:1},ping:{protocolPrefix:"ipfs",maxInboundStreams:1,maxOutboundStreams:1,timeout:1e4},fetch:{protocolPrefix:"libp2p",maxInboundStreams:1,maxOutboundStreams:1,timeout:1e4}};function eN(e){const t=(0,c.Z)(JD,e);if(null==t.transports||t.transports.length<1)throw h(new Error(jT.ERR_TRANSPORTS_REQUIRED),VT.ERR_TRANSPORTS_REQUIRED);if(null==t.connectionEncryption||0===t.connectionEncryption.length)throw h(new Error(jT.CONN_ENCRYPTION_REQUIRED),VT.CONN_ENCRYPTION_REQUIRED);if(null===t.connectionProtector&&null!=globalThis.process?.env?.LIBP2P_FORCE_PNET)throw h(new Error(jT.ERR_PROTECTOR_REQUIRED),VT.ERR_PROTECTOR_REQUIRED);return t.identify.host.agentVersion===xP&&(rD.UG||rD.$l?t.identify.host.agentVersion+=` UserAgent=${globalThis.process.version}`:(rD.jU||rD.n2||rD.iP||rD.b$)&&(t.identify.host.agentVersion+=` UserAgent=${globalThis.navigator.userAgent}`)),t}var tN;(function(e){let t;e.codec=()=>(null==t&&(t=(0,Sr.yw)(((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null==e.id)throw new Error('Protocol error: required field "id" was not found in object');t.uint32(10),t.bytes(e.id),null!=e.pubKey&&(t.uint32(18),t.bytes(e.pubKey)),null!=e.privKey&&(t.uint32(26),t.bytes(e.privKey)),!1!==r.lengthDelimited&&t.ldelim()}),((e,t)=>{const r={id:new Uint8Array(0)},s=null==t?e.len:e.pos+t;while(e.pos<s){const t=e.uint32();switch(t>>>3){case 1:r.id=e.bytes();break;case 2:r.pubKey=e.bytes();break;case 3:r.privKey=e.bytes();break;default:e.skipType(7&t);break}}if(null==r.id)throw new Error('Protocol error: value for required field "id" was not found in protobuf');return r}))),t),e.encode=t=>(0,Sr.LE)(t,e.codec()),e.decode=t=>(0,Sr.C6)(t,e.codec())})(tN||(tN={}));const rN=async()=>{const e=await(0,dr.generateKeyPair)("Ed25519"),t=await nN(e);if("Ed25519"===t.type)return t;throw new Error(`Generated unexpected PeerId type "${t.type}"`)},sN=async e=>{const t=await(0,dr.generateKeyPair)("RSA",e?.bits??2048),r=await nN(t);if("RSA"===r.type)return r;throw new Error(`Generated unexpected PeerId type "${r.type}"`)};async function nN(e){return await(0,Ht.y5)((0,dr.marshalPublicKey)(e.public),(0,dr.marshalPrivateKey)(e))}var iN=r(59769);class oN extends HE.v{get[iN.N](){return!0}get[Symbol.toStringTag](){return"@libp2p/dummy-dht"}get wan(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}get lan(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}get(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}findProviders(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}findPeer(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}getClosestPeers(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}provide(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}put(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}async getMode(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}async setMode(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}async refreshRoutingTable(){throw h(new Error(jT.DHT_DISABLED),VT.DHT_DISABLED)}}class aN extends HE.v{isStarted(){return!1}start(){}stop(){}get globalSignaturePolicy(){throw h(new Error(jT.PUBSUB_DISABLED),VT.ERR_PUBSUB_DISABLED)}get multicodecs(){throw h(new Error(jT.PUBSUB_DISABLED),VT.ERR_PUBSUB_DISABLED)}getPeers(){throw h(new Error(jT.PUBSUB_DISABLED),VT.ERR_PUBSUB_DISABLED)}getTopics(){throw h(new Error(jT.PUBSUB_DISABLED),VT.ERR_PUBSUB_DISABLED)}subscribe(){throw h(new Error(jT.PUBSUB_DISABLED),VT.ERR_PUBSUB_DISABLED)}unsubscribe(){throw h(new Error(jT.PUBSUB_DISABLED),VT.ERR_PUBSUB_DISABLED)}getSubscribers(){throw h(new Error(jT.PUBSUB_DISABLED),VT.ERR_PUBSUB_DISABLED)}async publish(){throw h(new Error(jT.PUBSUB_DISABLED),VT.ERR_PUBSUB_DISABLED)}}var cN=r(52770),lN=r(35103);const uN=(0,u.kg)("libp2p:dialer:dial-request");class hN{constructor(e){const{addrs:t,dialAction:r,dialer:s}=e;this.addrs=t,this.dialer=s,this.dialAction=r}async run(e={}){const t=this.dialer.getTokens(this.addrs.length);if(t.length<1)throw h(new Error("No dial tokens available"),VT.ERR_NO_DIAL_TOKENS);const r=new lN;for(const o of t)r.push(o).catch((e=>{uN.error(e)}));const s=this.addrs.map((()=>{const e=new AbortController;try{(0,qT.setMaxListeners)?.(1/0,e.signal)}catch{}return e}));if(null!=e.signal)try{(0,qT.setMaxListeners)?.(1/0,e.signal)}catch{}let n=0,i=!1;try{return await Promise.any(this.addrs.map((async(o,a)=>{const c=await r.shift();if(i)throw this.dialer.releaseToken(t.splice(t.indexOf(c),1)[0]),h(new Error("dialAction already succeeded"),VT.ERR_ALREADY_SUCCEEDED);const l=s[a];if(null==l)throw h(new Error("dialAction did not come with an AbortController"),VT.ERR_INVALID_PARAMETERS);let u;try{const i=l.signal;u=await this.dialAction(o,{...e,signal:null!=e.signal?(0,ut.anySignal)([i,e.signal]):i}),s[a]=void 0}finally{n++,this.addrs.length-n>=t.length?r.push(c).catch((e=>{uN.error(e)})):this.dialer.releaseToken(t.splice(t.indexOf(c),1)[0])}if(null==u)throw h(new Error("dialAction led to empty object"),VT.ERR_TRANSPORT_DIAL_FAILED);return i=!0,u})))}finally{s.forEach((e=>{void 0!==e&&e.abort()})),t.forEach((e=>this.dialer.releaseToken(e)))}}}const dN=(0,u.kg)("libp2p:dialer"),pN="dialler",fN="pending-dials",yN="pending-dial-targets";class gN{constructor(e,t={}){this.started=!1,this.addressSorter=t.addressSorter??cC,this.maxAddrsToDial=t.maxAddrsToDial??UC,this.timeout=t.dialTimeout??LC,this.maxDialsPerPeer=t.maxDialsPerPeer??BC,this.tokens=[...new Array(t.maxParallelDials??MC)].map(((e,t)=>t)),this.components=e,this.pendingDials=JC({component:pN,metric:fN,metrics:t.metrics}),this.pendingDialTargets=JC({component:pN,metric:yN,metrics:e.getMetrics()});for(const[r,s]of Object.entries(t.resolvers??{}))qe.s_.set(r,s)}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1;for(const e of this.pendingDials.values())try{e.controller.abort()}catch(mu){dN.error(mu)}this.pendingDials.clear();for(const e of this.pendingDialTargets.values())e.reject(new cN._("Dialer was destroyed"));this.pendingDialTargets.clear()}async dial(e,t={}){const{id:r,multiaddrs:s}=ZT(e);if(this.components.getPeerId().equals(r))throw h(new Error("Tried to dial self"),VT.ERR_DIALED_SELF);if(dN("check multiaddrs %p",r),null!=s&&s.length>0&&(dN("storing multiaddrs %p",r,s),await this.components.getPeerStore().addressBook.add(r,s)),await this.components.getConnectionGater().denyDialPeer(r))throw h(new Error("The dial request is blocked by gater.allowDialPeer"),VT.ERR_PEER_DIAL_INTERCEPTED);dN("creating dial target for %p",r);const n=await this._createCancellableDialTarget(r,t);if(0===n.addrs.length)throw h(new Error("The dial request has no valid addresses"),VT.ERR_NO_VALID_ADDRESSES);const i=this.pendingDials.get(n.id)??this._createPendingDial(n,t);try{const e=await i.promise;return dN("dial succeeded to %s",n.id),e}catch(mu){throw dN("dial failed to %s",n.id,mu),i.controller.signal.aborted&&(mu.code=VT.ERR_TIMEOUT),dN.error(mu),mu}finally{i.destroy()}}async _createCancellableDialTarget(e,t){const r=`${parseInt(String(1e9*Math.random()),10).toString()}${Date.now()}`,s=new Promise(((e,t)=>{this.pendingDialTargets.set(r,{resolve:e,reject:t})}));try{const n=await Promise.race([this._createDialTarget(e,t),s]);return n}finally{this.pendingDialTargets.delete(r)}}async _createDialTarget(e,t){const r=await(0,Cs.zG)(await this.components.getPeerStore().addressBook.get(e),(t=>ms(t,(async t=>!await this.components.getConnectionGater().denyDialMultiaddr(e,t.multiaddr)))),(e=>_E(e,this.addressSorter)),(t=>As(t,(t=>{const r=t.multiaddr;return e.toString()===r.getPeerId()?r:r.encapsulate(`/p2p/${e.toString()}`)}))),(async e=>await fs(e))),s=[];for(const i of r){const e=await this._resolve(i,t);e.forEach((e=>s.push(e)))}const n=s.filter((e=>this.components.getTransportManager().transportForMultiaddr(e)));if(n.length>this.maxAddrsToDial)throw await this.components.getPeerStore().delete(e),h(new Error("dial with more addresses than allowed"),VT.ERR_TOO_MANY_ADDRESSES);return{id:e.toString(),addrs:n}}_createPendingDial(e,t={}){const r=async(e,t={})=>{if(!0===t.signal?.aborted)throw h(new Error("already aborted"),VT.ERR_ALREADY_ABORTED);return await this.components.getTransportManager().dial(e,t).catch((t=>{throw dN.error("dial to %s failed",e,t),t}))},s=new hN({addrs:e.addrs,dialAction:r,dialer:this}),n=new Fe.TimeoutController(this.timeout),i=[n.signal];null!=t.signal&&i.push(t.signal);const o=(0,ut.anySignal)(i);try{(0,qT.setMaxListeners)?.(1/0,o)}catch{}const a={dialRequest:s,controller:n,promise:s.run({...t,signal:o}),destroy:()=>{n.clear(),this.pendingDials.delete(e.id)}};return this.pendingDials.set(e.id,a),a}getTokens(e){const t=Math.min(e,this.maxDialsPerPeer,this.tokens.length),r=this.tokens.splice(0,t);return dN("%d tokens request, returning %d, %d remaining",e,t,this.tokens.length),r}releaseToken(e){this.tokens.includes(e)||(dN("token %d released",e),this.tokens.push(e))}async _resolve(e,t){const r=e.protoNames().includes("dnsaddr");if(!r)return[e];const s=await this._resolveRecord(e,t),n=await Promise.all(s.map((async e=>await this._resolve(e,t)))),i=n.flat();return i.reduce(((e,t)=>(null==e.find((e=>e.equals(t)))&&e.push(t),e)),[])}async _resolveRecord(e,t){try{e=(0,qe.HM)(e.toString());const r=await e.resolve(t);return r}catch(mu){return dN.error(`multiaddr ${e.toString()} could not be resolved`,mu),[]}}}const mN=(0,u.kg)("libp2p");class wN extends HE.v{constructor(e){super(),this.initializables=[],this.started=!1,this.peerId=e.peerId,this.components=new nS.z({peerId:e.peerId,datastore:e.datastore??new Ts,connectionGater:{denyDialPeer:async()=>await Promise.resolve(!1),denyDialMultiaddr:async()=>await Promise.resolve(!1),denyInboundConnection:async()=>await Promise.resolve(!1),denyOutboundConnection:async()=>await Promise.resolve(!1),denyInboundEncryptedConnection:async()=>await Promise.resolve(!1),denyOutboundEncryptedConnection:async()=>await Promise.resolve(!1),denyInboundUpgradedConnection:async()=>await Promise.resolve(!1),denyOutboundUpgradedConnection:async()=>await Promise.resolve(!1),filterMultiaddrForPeer:async()=>await Promise.resolve(!0),...e.connectionGater}}),this.components.setPeerStore(new MD({addressFilter:this.components.getConnectionGater().filterMultiaddrForPeer,...e.peerStore})),this.services=[this.components],e.metrics.enabled&&(this.metrics=this.components.setMetrics(new HC(e.metrics))),this.peerStore=this.components.getPeerStore(),this.peerStore.addEventListener("peer",(e=>{const{detail:t}=e;this.dispatchEvent(new HE.A("peer:discovery",{detail:t}))})),null!=e.connectionProtector&&this.components.setConnectionProtector(e.connectionProtector),this.components.setUpgrader(new DP(this.components,{connectionEncryption:(e.connectionEncryption??[]).map((e=>this.configureComponent(e))),muxers:(e.streamMuxers??[]).map((e=>this.configureComponent(e))),inboundUpgradeTimeout:e.connectionManager.inboundUpgradeTimeout})),this.components.setDialer(new gN(this.components,e.connectionManager)),this.connectionManager=this.components.setConnectionManager(new bA(e.connectionManager)),this.registrar=this.components.setRegistrar(new RP(this.components)),this.components.setTransportManager(new tP(this.components,e.transportManager)),this.components.setAddressManager(new JT(this.components,e.addresses)),this.configureComponent(new uD(this.components)),this.configureComponent(new vA(this.components,{enabled:e.connectionManager.autoDial,minConnections:e.connectionManager.minConnections,autoDialInterval:e.connectionManager.autoDialInterval}));const t=NC.generateOptions();this.keychain=this.configureComponent(new NC(this.components,{...t,...e.keychain})),this.services.push(new cD(this.components,e.nat)),e.transports.forEach((e=>{this.components.getTransportManager().add(this.configureComponent(e))})),null!=e.streamMuxers&&e.streamMuxers.length>0&&(this.identifyService=new $P(this.components,{...e.identify}),this.configureComponent(this.identifyService)),null!=e.dht?this.dht=this.components.setDHT(e.dht):this.dht=new oN,null!=e.pubsub?this.pubsub=this.components.setPubSub(e.pubsub):this.pubsub=new aN;const r=(e.peerRouters??[]).map((e=>this.configureComponent(e)));null!=e.dht&&(r.push(this.configureComponent(new hD(this.dht))),this.dht.addEventListener("peer",(e=>{this.onDiscoveryPeer(e)}))),this.peerRouting=this.components.setPeerRouting(this.configureComponent(new WT(this.components,{...e.peerRouting,routers:r})));const s=(e.contentRouters??[]).map((e=>this.configureComponent(e)));null!=e.dht&&s.push(this.configureComponent(new BD(this.dht))),this.contentRouting=this.components.setContentRouting(this.configureComponent(new YT(this.components,{routers:s}))),e.relay.enabled&&(this.components.getTransportManager().add(this.configureComponent(new ZA(e.relay))),this.configureComponent(new pC(this.components,{addressSorter:e.connectionManager.addressSorter,...e.relay}))),this.fetchService=this.configureComponent(new YP(this.components,{...e.fetch})),this.pingService=this.configureComponent(new eD(this.components,{...e.ping}));const n=this.configureComponent(new jD(this.components,{enabled:!1!==e.connectionManager.autoDial,minConnections:e.connectionManager.minConnections,dialTimeout:e.connectionManager.dialTimeout??3e4}));this.addEventListener("peer:discovery",(e=>{this.isStarted()&&n.handle(e)}));for(const i of e.peerDiscovery??[])this.configureComponent(i),i.addEventListener("peer",(e=>{this.onDiscoveryPeer(e)}))}configureComponent(e){return(0,zT.qK)(e)&&this.services.push(e),(0,nS.G)(e)&&this.initializables.push(e),e}async start(){if(!this.started){this.started=!0,mN("libp2p is starting");try{this.initializables.forEach((e=>{e.init(this.components)})),await Promise.all(this.services.map((async e=>{null!=e.beforeStart&&await e.beforeStart()}))),await Promise.all(this.services.map((e=>e.start()))),await Promise.all(this.services.map((async e=>{null!=e.afterStart&&await e.afterStart()}))),mN("libp2p has started")}catch(mu){throw mN.error("An error occurred starting libp2p",mu),await this.stop(),mu}}}async stop(){this.started&&(mN("libp2p is stopping"),this.started=!1,await Promise.all(this.services.map((async e=>{null!=e.beforeStop&&await e.beforeStop()}))),await Promise.all(this.services.map((e=>e.stop()))),await Promise.all(this.services.map((async e=>{null!=e.afterStop&&await e.afterStop()}))),mN("libp2p has stopped"))}isStarted(){return this.started}getConnections(e){return this.components.getConnectionManager().getConnections(e)}getPeers(){const e=new hA;for(const t of this.components.getConnectionManager().getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){const{id:r,multiaddrs:s}=ZT(e);return await this.components.getPeerStore().addressBook.add(r,s),await this.components.getConnectionManager().openConnection(r,t)}async dialProtocol(e,t,r={}){if(null==t)throw h(new Error("no protocols were provided to open a stream"),VT.ERR_INVALID_PROTOCOLS_FOR_STREAM);if(t=Array.isArray(t)?t:[t],0===t.length)throw h(new Error("no protocols were provided to open a stream"),VT.ERR_INVALID_PROTOCOLS_FOR_STREAM);const s=await this.dial(e,r);return await s.newStream(t,r)}getMultiaddrs(){return this.components.getAddressManager().getAddresses()}async hangUp(e){const{id:t}=ZT(e);await this.components.getConnectionManager().closeConnections(t)}async getPublicKey(e,t={}){if(mN("getPublicKey %p",e),null!=e.publicKey)return e.publicKey;const r=await this.peerStore.get(e);if(null!=r.pubKey)return r.pubKey;if(null==this.dht)throw h(new Error("Public key was not in the peer store and the DHT is not enabled"),VT.ERR_NO_ROUTERS_AVAILABLE);const s=(0,Ir.concat)([(0,ze.m)("/pk/"),e.multihash.digest]);for await(const n of this.dht.get(s,t))if("VALUE"===n.name){const t=(0,dr.unmarshalPublicKey)(n.value);return await this.peerStore.keyBook.set(e,n.value),t.bytes}throw h(new Error(`Node not responding with its public key: ${e.toString()}`),VT.ERR_INVALID_RECORD)}async fetch(e,t,r={}){const{id:s,multiaddrs:n}=ZT(e);return null!=n&&await this.components.getPeerStore().addressBook.add(s,n),await this.fetchService.fetch(s,t,r)}async ping(e,t={}){const{id:r,multiaddrs:s}=ZT(e);return s.length>0&&await this.components.getPeerStore().addressBook.add(r,s),await this.pingService.ping(r,t)}async handle(e,t,r){Array.isArray(e)||(e=[e]),await Promise.all(e.map((async e=>{await this.components.getRegistrar().handle(e,t,r)})))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map((async e=>{await this.components.getRegistrar().unhandle(e)})))}onDiscoveryPeer(e){const{detail:t}=e;t.id.toString()!==this.peerId.toString()?(t.multiaddrs.length>0&&this.components.getPeerStore().addressBook.add(t.id,t.multiaddrs).catch((e=>mN.error(e))),t.protocols.length>0&&this.components.getPeerStore().protoBook.set(t.id,t.protocols).catch((e=>mN.error(e))),this.dispatchEvent(new HE.A("peer:discovery",{detail:t}))):mN.error(new Error(VT.ERR_DISCOVERED_SELF))}}async function bN(e){return null==e.peerId&&(e.peerId=await rN()),new wN(eN(e))}async function _N(e){return await bN(e)}var EN=r(92499);const vN=(0,u.kg)("libp2p:bootstrap");class SN extends HE.v{constructor(e={list:[]}){if(null==e.list||0===e.list.length)throw new Error("Bootstrap requires a list of peer addresses");super(),this.interval=e.interval??1e4,this.list=[];for(const t of e.list){if(!Ge.Ul.matches(t)){vN.error("Invalid multiaddr");continue}const e=(0,qe.HM)(t),r=e.getPeerId();if(null==r){vN.error("Invalid bootstrap multiaddr without peer id");continue}const s={id:(0,Ht.jE)(r),multiaddrs:[e],protocols:[]};this.list.push(s)}}get[iN.N](){return!0}get[Symbol.toStringTag](){return"@libp2p/bootstrap"}isStarted(){return Boolean(this.timer)}start(){null==this.timer&&(this.timer=setInterval((()=>this._discoverBootstrapPeers()),this.interval),vN("Starting bootstrap node discovery"),this._discoverBootstrapPeers())}_discoverBootstrapPeers(){null!=this.timer&&this.list.forEach((e=>{this.dispatchEvent(new HE.A("peer",{detail:e}))}))}stop(){null!=this.timer&&clearInterval(this.timer),this.timer=void 0}}SN.tag="bootstrap";var IN,kN=r(36350);class RN extends Error{constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}}function TN(e){if(null!=e){if("function"===typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"===typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"===typeof e.next)return e}throw new Error("argument is not an iterator or iterable")}function AN(e,t,r){const s=r??{},n=TN(e);async function*i(){let r;const i=()=>{null!=r&&r()};t.addEventListener("abort",i);while(1){let o;try{if(t.aborted){const{abortMessage:e,abortCode:t}=s;throw new RN(e,t)}const e=new Promise(((e,t)=>{r=()=>{const{abortMessage:e,abortCode:r}=s;t(new RN(e,r))}}));o=await Promise.race([e,n.next()]),r=null}catch(mu){t.removeEventListener("abort",i);const o="aborted"===mu.type&&t.aborted;if(o&&null!=s.onAbort&&await s.onAbort(e),"function"===typeof n.return)try{const e=n.return();e instanceof Promise&&e.catch((e=>{null!=s.onReturnError&&s.onReturnError(e)}))}catch(mu){null!=s.onReturnError&&s.onReturnError(mu)}if(o&&!0===s.returnOnAbort)return;throw mu}if(!0===o.done)break;yield o.value}t.removeEventListener("abort",i)}return i()}function CN(e){return new Uint8Array(e)}(function(e){e[e["NEW_STREAM"]=0]="NEW_STREAM",e[e["MESSAGE_RECEIVER"]=1]="MESSAGE_RECEIVER",e[e["MESSAGE_INITIATOR"]=2]="MESSAGE_INITIATOR",e[e["CLOSE_RECEIVER"]=3]="CLOSE_RECEIVER",e[e["CLOSE_INITIATOR"]=4]="CLOSE_INITIATOR",e[e["RESET_RECEIVER"]=5]="RESET_RECEIVER",e[e["RESET_INITIATOR"]=6]="RESET_INITIATOR"})(IN||(IN={}));const PN=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),DN=Object.freeze({NEW_STREAM:IN.NEW_STREAM,MESSAGE:IN.MESSAGE_INITIATOR,CLOSE:IN.CLOSE_INITIATOR,RESET:IN.RESET_INITIATOR}),NN=Object.freeze({MESSAGE:IN.MESSAGE_RECEIVER,CLOSE:IN.CLOSE_RECEIVER,RESET:IN.RESET_RECEIVER}),ON=10240;class LN{constructor(){this._pool=CN(ON),this._poolOffset=0}write(e){const t=this._pool;let r=this._poolOffset;If.encode(e.id<<3|e.type,t,r),r+=If.encode.bytes,e.type!==IN.NEW_STREAM&&e.type!==IN.MESSAGE_INITIATOR&&e.type!==IN.MESSAGE_RECEIVER||null==e.data?If.encode(0,t,r):If.encode(e.data.length,t,r),r+=If.encode.bytes;const s=t.subarray(this._poolOffset,r);return ON-r<100?(this._pool=CN(ON),this._poolOffset=0):this._poolOffset=r,e.type!==IN.NEW_STREAM&&e.type!==IN.MESSAGE_INITIATOR&&e.type!==IN.MESSAGE_RECEIVER||null==e.data?[s]:[s,...e.data instanceof Uint8Array?[e.data]:e.data]}}const xN=new LN;async function*MN(e){for await(const t of e)if(Array.isArray(t))for(const e of t)yield*xN.write(e);else yield*xN.write(t)}class BN{constructor(){this._buffer=new ba.H,this._headerInfo=null}write(e){if(null==e||0===e.length)return[];this._buffer.append(e);const t=[];while(0!==this._buffer.length){if(null==this._headerInfo)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(r){break}const{id:e,type:s,length:n,offset:i}=this._headerInfo,o=this._buffer.length-i;if(o<n)break;const a={id:e,type:s};s!==IN.NEW_STREAM&&s!==IN.MESSAGE_INITIATOR&&s!==IN.MESSAGE_RECEIVER||(a.data=this._buffer.sublist(i,i+n)),t.push(a),this._buffer.consume(i+n),this._headerInfo=null}return t}_decodeHeader(e){const{value:t,offset:r}=VN(e),{value:s,offset:n}=VN(e,r),i=7&t;if(null==PN[i])throw new Error(`Invalid type received: ${i}`);return{id:t>>3,type:i,offset:r+n,length:s}}}const UN=128,jN=127;function VN(e,t=0){let r,s=0,n=0,i=t;const o=e.length;do{if(i>=o||n>49)throw t=0,new RangeError("Could not decode varint");r=e.get(i++),s+=n<28?(r&jN)<<n:(r&jN)*Math.pow(2,n),n+=7}while(r>=UN);return t=i-t,{value:s,offset:t}}async function*zN(e){const t=new BN;for await(const r of e){const e=t.write(r);e.length>0&&(yield e)}}const FN=1<<20;function $N(e){const t=e??FN,r=e=>{if((e.type===IN.NEW_STREAM||e.type===IN.MESSAGE_INITIATOR||e.type===IN.MESSAGE_RECEIVER)&&e.data.byteLength>t)throw Object.assign(new Error("message size too large!"),{code:"ERR_MSG_TOO_BIG"})};return e=>async function*(){for await(const t of e)Array.isArray(t)?(t.forEach(r),yield*t):(r(t),yield t)}()}const KN=(0,u.kg)("libp2p:mplex:stream"),HN="ERR_STREAM_RESET",qN="ERR_STREAM_ABORT",GN="ERR_SINK_ENDED",WN="ERR_DOUBLE_SINK";function YN(e){const{id:t,name:r,send:s,onEnd:n,type:i="initiator",maxMsgSize:o=FN}=e,a=new AbortController,c=new AbortController,l=new AbortController,u="initiator"===i?DN:NN,d="initiator"===i?`i${t}`:`r${t}`,p=`${null==r?t:r}`;let f,y=!1,g=!1,m=!1;const w={open:Date.now()},b=e=>{y||(y=!0,KN.trace("%s stream %s source end - err: %o",i,p,e),null!=e&&null==f&&(f=e),g&&(v.stat.timeline.close=Date.now(),null!=n&&n(f)))},_=e=>{g||(g=!0,KN.trace("%s stream %s sink end - err: %o",i,p,e),null!=e&&null==f&&(f=e),y&&(w.close=Date.now(),null!=n&&n(f)))},E=(0,_s.d)({onEnd:b}),v={close:()=>{KN.trace("%s stream %s close",i,p),v.closeRead(),v.closeWrite()},closeRead:()=>{KN.trace("%s stream %s closeRead",i,p),y||E.end()},closeWrite:()=>{if(KN.trace("%s stream %s closeWrite",i,p),!g){l.abort();try{s({id:t,type:u.CLOSE})}catch(mu){KN.trace("%s stream %s error sending close",i,r,mu)}_()}},abort:e=>{KN.trace("%s stream %s abort",i,p,e),E.end(e),a.abort(),_(e)},reset:()=>{const e=h(new Error("stream reset"),HN);c.abort(),E.end(e),_(e)},sink:async e=>{if(m)throw h(new Error("sink already called on stream"),WN);if(m=!0,g)throw h(new Error("stream closed for writing"),GN);e=AN(e,(0,ut.anySignal)([a.signal,c.signal,l.signal]));try{"initiator"===i&&s({id:t,type:DN.NEW_STREAM,data:new ba.H((0,ze.m)(p))});const r=new ba.H;for await(const n of e)if(n.length<=o)s({id:t,type:u.MESSAGE,data:n instanceof ba.H?n:new ba.H(n)});else{r.append(n);while(0!==r.length){if(r.length<=o){s({id:t,type:u.MESSAGE,data:r.sublist()}),r.consume(r.length);break}s({id:t,type:u.MESSAGE,data:r.sublist(0,o)}),r.consume(o)}}}catch(mu){if("aborted"===mu.type&&"The operation was aborted"===mu.message){if(l.signal.aborted)return;c.signal.aborted&&(mu.message="stream reset",mu.code=HN),a.signal.aborted&&(mu.message="stream aborted",mu.code=qN)}if(mu.code===HN)KN.trace("%s stream %s reset",i,r);else{KN.trace("%s stream %s error",i,r,mu);try{s({id:t,type:u.RESET})}catch(mu){KN.trace("%s stream %s error sending reset",i,r,mu)}}return E.end(mu),void _(mu)}try{s({id:t,type:u.CLOSE})}catch(mu){KN.trace("%s stream %s error sending close",i,r,mu)}_()},source:E,sourcePush:e=>{E.push(e)},sourceReadableLength(){return E.readableLength},stat:{direction:"initiator"===i?"outbound":"inbound",timeline:w},metadata:{},id:d};return v}var QN=r(37466),ZN=r(8558);const XN=(0,u.kg)("libp2p:mplex"),JN=1024,eO=1024,tO=4194304,rO=5;function sO(e){const t={...e,type:`${PN[e.type]} (${e.type})`};return e.type===IN.NEW_STREAM&&(t.data=(0,QN.BB)(e.data instanceof Uint8Array?e.data:e.data.subarray())),e.type!==IN.MESSAGE_INITIATOR&&e.type!==IN.MESSAGE_RECEIVER||(t.data=(0,QN.BB)(e.data instanceof Uint8Array?e.data:e.data.subarray(),"base16")),t}class nO{constructor(e,t){this.protocol="/mplex/6.7.0",t=t??{},this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=t,this.sink=this._createSink();const r=this._createSource();this._source=r,this.source=r,this.closeController=new AbortController,this.rateLimiter=new ZN.RateLimiterMemory({points:t.disconnectThreshold??rO,duration:1})}init(e){}get streams(){const e=[];for(const t of this._streams.initiators.values())e.push(t);for(const t of this._streams.receivers.values())e.push(t);return e}newStream(e){if(this.closeController.signal.aborted)throw new Error("Muxer already closed");const t=this._streamId++;e=null==e?t.toString():e.toString();const r=this._streams.initiators;return this._newStream({id:t,name:e,type:"initiator",registry:r})}close(e){this.closeController.signal.aborted||(null!=e?this.streams.forEach((t=>t.abort(e))):this.streams.forEach((e=>e.close())),this.closeController.abort())}_newReceiverStream(e){const{id:t,name:r}=e,s=this._streams.receivers;return this._newStream({id:t,name:r,type:"receiver",registry:s})}_newStream(e){const{id:t,name:r,type:s,registry:n}=e;if(XN("new %s stream %s %s",s,t),"initiator"===s&&this._streams.initiators.size===(this._init.maxOutboundStreams??eO))throw h(new Error("Too many outbound streams open"),"ERR_TOO_MANY_OUTBOUND_STREAMS");if(n.has(t))throw new Error(`${s} stream ${t} already exists!`);const i=e=>{XN.enabled&&XN.trace("%s stream %s send",s,t,sO(e)),this._source.push(e)},o=()=>{XN("%s stream with id %s and protocol %s ended",s,t,a.stat.protocol),n.delete(t),null!=this._init.onStreamEnd&&this._init.onStreamEnd(a)},a=YN({id:t,name:r,send:i,type:s,onEnd:o,maxMsgSize:this._init.maxMsgSize});return n.set(t,a),a}_createSink(){const e=async e=>{const t=[this.closeController.signal];null!=this._init.signal&&t.push(this._init.signal),e=AN(e,ut(t));try{await(0,Cs.zG)(e,zN,$N(this._init.maxMsgSize),(async e=>{for await(const t of e)await this._handleIncoming(t)})),this._source.end()}catch(mu){XN("error in sink",mu),this._source.end(mu)}};return e}_createSource(){const e=e=>{this.close(e)},t=(0,_s.e)({objectMode:!0,onEnd:e});return Object.assign(MN(t),{push:t.push,end:t.end,return:t.return})}async _handleIncoming(e){const{id:t,type:r}=e;if(XN.enabled&&XN.trace("incoming message",sO(e)),e.type===IN.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??JN)){XN("too many inbound streams open"),this._source.push({id:t,type:IN.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{return XN("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),void this._source.end(new Error("Too many open streams"))}return}const r=this._newReceiverStream({id:t,name:(0,QN.BB)(e.data instanceof Uint8Array?e.data:e.data.subarray())});return void(null!=this._init.onIncomingStream&&this._init.onIncomingStream(r))}const s=1===(1&r)?this._streams.initiators:this._streams.receivers,n=s.get(t);if(null==n)return void XN("missing stream %s for message type %s",t,PN[r]);const i=this._init.maxStreamBufferSize??tO;switch(r){case IN.MESSAGE_INITIATOR:case IN.MESSAGE_RECEIVER:if(n.sourceReadableLength()>i){this._source.push({id:e.id,type:r===IN.MESSAGE_INITIATOR?IN.RESET_RECEIVER:IN.RESET_INITIATOR});const t=h(new Error("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers"),"ERR_STREAM_INPUT_BUFFER_FULL");return void n.abort(t)}n.sourcePush(e.data);break;case IN.CLOSE_INITIATOR:case IN.CLOSE_RECEIVER:n.closeRead();break;case IN.RESET_INITIATOR:case IN.RESET_RECEIVER:n.reset();break;default:XN("unknown message type %s",r)}}}class iO{constructor(e={}){this.protocol="/mplex/6.7.0",this.components=new nS.z,this._init=e}init(e){this.components=e}createStreamMuxer(e={}){return new nO(this.components,{...e,...this._init})}}var oO=r(92410);const aO=c.Z.bind({ignoreUndefined:!0,concatArrays:!0});function cO({options:e={},peerId:t,multiaddrs:r=[],repo:s,keychainConfig:n={},config:i={}}){const{datastore:o}=s,a=lO({options:e,config:i,datastore:o,keychainConfig:n,peerId:t,multiaddrs:r});return"function"===typeof e.libp2p?e.libp2p({libp2pOptions:a,options:e,config:i,datastore:o,peerId:t}):_N(a)}function lO({options:e,config:t,datastore:r,keychainConfig:s,peerId:n,multiaddrs:i}){const o=()=>{const e=Ss(t,"Pubsub.Router")||"gossipsub",r=xS();if(!r[e])throw h(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${e} router.`),"ERR_NOT_SUPPORTED");return r[e]},a={datastore:r,peerId:n},c={addresses:{listen:i.map((e=>e.toString())),announce:Ss(e,"addresses.announce",Ss(t,"Addresses.Announce",[])),noAnnounce:Ss(e,"addresses.noAnnounce",Ss(t,"Addresses.NoAnnounce",[]))},connectionManager:Ss(e,"connectionManager",{maxConnections:Ss(e,"config.Swarm.ConnMgr.HighWater",Ss(t,"Swarm.ConnMgr.HighWater")),minConnections:Ss(e,"config.Swarm.ConnMgr.LowWater",Ss(t,"Swarm.ConnMgr.LowWater"))}),keychain:s,identify:{host:{agentVersion:`js-ipfs/${cf}`}},contentRouters:[],peerRouters:[],peerDiscovery:[],transports:[],streamMuxers:[new iO({maxInboundStreams:256,maxOutboundStreams:1024})],connectionEncryption:[new oO.c],relay:{enabled:Ss(e,"relay.enabled",Ss(t,"relay.enabled",!0)),hop:{enabled:Ss(e,"relay.hop.enabled",Ss(t,"relay.hop.enabled",!1)),active:Ss(e,"relay.hop.active",Ss(t,"relay.hop.active",!1))}},nat:{enabled:!Ss(t,"Swarm.DisableNatPortMap",!1)}};Ss(e,"config.Pubsub.Enabled",Ss(t,"Pubsub.Enabled",!0))&&(c.pubsub=o()),"none"!==Ss(t,"Routing.Type","dhtclient")&&(c.dht=new EN.i({clientMode:"dhtserver"!==Ss(t,"Routing.Type","dht"),kBucketSize:Ss(e,"dht.kBucketSize",20),validators:{ipns:is},selectors:{ipns:Is}}));const l=Ss(e,"config.Bootstrap",Ss(t,"Bootstrap",[]));l.length>0&&c.peerDiscovery?.push(new SN({list:l}));let u=Ss(e,"libp2p",void 0);"function"===typeof u&&(u=void 0);const d=aO(a,UT(),c,u),p=Ss(e,"config.Addresses.Delegates",Ss(t,"Addresses.Delegates",[]));if(p.length>0){const e=p[Math.floor(Math.random()*p.length)],t=(0,qe.HM)(e).toOptions(),r={host:t.host,protocol:443===parseInt(t.port)?"https":"http",port:t.port},s=MT(r);d.contentRouters?.push(new HS(s)),d.peerRouters?.push(new VS(s))}return Ss(e,"config.Discovery.MDNS.Enabled",Ss(t,"Discovery.MDNS.Enabled",!0))||(d.peerDiscovery=d.peerDiscovery?.filter((e=>null!=e&&"@libp2p/mdns"!==e[Symbol.toStringTag]))),null==d.transports&&(d.transports=[]),null==d.transports.find((e=>"@libp2p/websockets"===e[Symbol.toStringTag]))&&d.transports.push(new kN.C),d}const uO=c.Z.bind({ignoreUndefined:!0}),hO=(0,u.kg)("ipfs:components:peer:storage");class dO{constructor(e,t,r,s,n){this.print=s,this.peerId=e,this.keychain=t,this.repo=r,this.print=s,this.isNew=n}static async start(e,t,r){const{repoAutoMigrate:s,repo:n,onMigrationProgress:i}=r,o="string"===typeof n||null==n?OE(e,t,{path:n,autoMigrate:s,onMigrationProgress:i}):n,{peerId:a,keychain:c,isNew:l}=await pO(e,o,r);return new dO(a,c,o,e,l)}}const pO=async(e,t,r)=>{if(!t.closed)return{...await wO(t,r),isNew:!1};try{return await t.open(),{...await wO(t,r),isNew:!1}}catch(mu){if(mu.code!==E_)throw mu;if(r.init&&!1===r.init.allowNew)throw new Ve("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");return{...await fO(e,t,r),isNew:!0}}},fO=async(e,t,r)=>{const s=r.init||{},n=await t.exists();if(hO("repo exists?",n),!0===n)throw new Error("repo already exists");const i=s.privateKey?await yO(s.privateKey):await gO(e,s),o=mO(i);hO("peer identity: %s",o.PeerID);const a={...uO(_O(An(),s.profiles),r.config),Identity:o};await t.init(a),await t.open(),hO("repo opened");const c={pass:r.pass};try{c.dek=await t.config.get("Keychain.DEK")}catch(mu){if("ERR_NOT_FOUND"!==mu.code)throw mu}const l=await cO({options:void 0,multiaddrs:void 0,peerId:i,repo:t,config:a,keychainConfig:c});return await t.datastore.has(new lt.s("/info/self"))||await l.keychain.importPeer("self",i),await t.config.set("Keychain",{DEK:l.keychain.init.dek}),{peerId:i,keychain:l.keychain}},yO=async e=>{if(hO("using user-supplied private-key"),(0,ir.I)(e))return e;const t=(0,ze.m)(e,"base64pad"),r=await(0,dr.unmarshalPrivateKey)(t);return await(0,Ht.y5)(r.public.bytes,r.bytes)},gO=(e,{algorithm:t="Ed25519",bits:r=2048})=>{if(e("generating %s keypair...",t),"Ed25519"===t)return rN();if("RSA"===t)return sN({bits:r});throw h(new Error("Unknown PeerId algorithm"),"ERR_UNKNOWN_PEER_ID_ALGORITHM")},mO=e=>{if(null==e.privateKey)throw h(new Error("Private key missing"),"ERR_MISSING_PRIVATE_KEY");return{PeerID:e.toString(),PrivKey:(0,Ye.B)(e.privateKey,"base64pad")}},wO=async(e,t)=>{const r=t.config,s=t.init&&t.init.profiles||[],n=t.pass,i=await e.config.getAll(),o=bO(_O(i,s),r);if(i!==o&&await e.config.replace(o),!o.Identity||!o.Identity.PrivKey)throw new Le("No private key was found in the config, please intialize the repo");const a=(0,ze.m)(o.Identity.PrivKey,"base64pad"),c=await(0,dr.unmarshalPrivateKey)(a),l=await(0,Ht.y5)(c.public.bytes,c.bytes),u=await cO({options:void 0,multiaddrs:void 0,peerId:l,repo:e,config:o,keychainConfig:{pass:n,...o.Keychain}});return{peerId:l,keychain:u.keychain}},bO=(e,t)=>t?uO(e,t):e,_O=(e,t)=>(t||[]).reduce(((e,t)=>{const r=bf[t];if(!r)throw new Error(`Could not find profile with name '${t}'`);return hO("applying profile %s",t),r.transform(e)}),e);var EO=r(82838);function vO(e){let t=new Uint8Array(e.reduce(((e,t)=>e+If.encodingLength(t)),0)),r=0;for(const s of e)t=If.encode(s,t,r),r+=If.encodingLength(s);return t}var SO=vO;class IO{constructor(e,t,r){this._refCounter=1,this.cid=e,this.priority=t||1,this.wantType=r}inc(){this._refCounter+=1}dec(){this._refCounter=Math.max(0,this._refCounter-1)}hasRefs(){return this._refCounter>0}get[Symbol.toStringTag](){const e=this.cid.toString($e.base58btc);return`WantlistEntry <key: ${e}, priority: ${this.priority}, refs: ${this._refCounter}>`}equals(e){return this._refCounter===e._refCounter&&this.cid.equals(e.cid)&&this.priority===e.priority&&this.wantType===e.wantType}}const kO=d.Reader,RO=d.Writer,TO=d.util,AO=d.roots["ipfs-bitswap"]||(d.roots["ipfs-bitswap"]={}),CO=AO.Message=(()=>{function e(e){if(this.blocks=[],this.payload=[],this.blockPresences=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.wantlist=null,e.prototype.blocks=TO.emptyArray,e.prototype.payload=TO.emptyArray,e.prototype.blockPresences=TO.emptyArray,e.prototype.pendingBytes=0,e.encode=function(e,t){if(t||(t=RO.create()),null!=e.wantlist&&Object.hasOwnProperty.call(e,"wantlist")&&AO.Message.Wantlist.encode(e.wantlist,t.uint32(10).fork()).ldelim(),null!=e.blocks&&e.blocks.length)for(var r=0;r<e.blocks.length;++r)t.uint32(18).bytes(e.blocks[r]);if(null!=e.payload&&e.payload.length)for(r=0;r<e.payload.length;++r)AO.Message.Block.encode(e.payload[r],t.uint32(26).fork()).ldelim();if(null!=e.blockPresences&&e.blockPresences.length)for(r=0;r<e.blockPresences.length;++r)AO.Message.BlockPresence.encode(e.blockPresences[r],t.uint32(34).fork()).ldelim();return null!=e.pendingBytes&&Object.hasOwnProperty.call(e,"pendingBytes")&&t.uint32(40).int32(e.pendingBytes),t},e.decode=function(e,t){e instanceof kO||(e=kO.create(e));var r=void 0===t?e.len:e.pos+t,s=new AO.Message;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.wantlist=AO.Message.Wantlist.decode(e,e.uint32());break;case 2:s.blocks&&s.blocks.length||(s.blocks=[]),s.blocks.push(e.bytes());break;case 3:s.payload&&s.payload.length||(s.payload=[]),s.payload.push(AO.Message.Block.decode(e,e.uint32()));break;case 4:s.blockPresences&&s.blockPresences.length||(s.blockPresences=[]),s.blockPresences.push(AO.Message.BlockPresence.decode(e,e.uint32()));break;case 5:s.pendingBytes=e.int32();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof AO.Message)return e;var t=new AO.Message;if(null!=e.wantlist){if("object"!==typeof e.wantlist)throw TypeError(".Message.wantlist: object expected");t.wantlist=AO.Message.Wantlist.fromObject(e.wantlist)}if(e.blocks){if(!Array.isArray(e.blocks))throw TypeError(".Message.blocks: array expected");t.blocks=[];for(var r=0;r<e.blocks.length;++r)"string"===typeof e.blocks[r]?TO.base64.decode(e.blocks[r],t.blocks[r]=TO.newBuffer(TO.base64.length(e.blocks[r])),0):e.blocks[r].length>=0&&(t.blocks[r]=e.blocks[r])}if(e.payload){if(!Array.isArray(e.payload))throw TypeError(".Message.payload: array expected");t.payload=[];for(r=0;r<e.payload.length;++r){if("object"!==typeof e.payload[r])throw TypeError(".Message.payload: object expected");t.payload[r]=AO.Message.Block.fromObject(e.payload[r])}}if(e.blockPresences){if(!Array.isArray(e.blockPresences))throw TypeError(".Message.blockPresences: array expected");t.blockPresences=[];for(r=0;r<e.blockPresences.length;++r){if("object"!==typeof e.blockPresences[r])throw TypeError(".Message.blockPresences: object expected");t.blockPresences[r]=AO.Message.BlockPresence.fromObject(e.blockPresences[r])}}return null!=e.pendingBytes&&(t.pendingBytes=0|e.pendingBytes),t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.blocks=[],r.payload=[],r.blockPresences=[]),t.defaults&&(r.wantlist=null,r.pendingBytes=0),null!=e.wantlist&&e.hasOwnProperty("wantlist")&&(r.wantlist=AO.Message.Wantlist.toObject(e.wantlist,t)),e.blocks&&e.blocks.length){r.blocks=[];for(var s=0;s<e.blocks.length;++s)r.blocks[s]=t.bytes===String?TO.base64.encode(e.blocks[s],0,e.blocks[s].length):t.bytes===Array?Array.prototype.slice.call(e.blocks[s]):e.blocks[s]}if(e.payload&&e.payload.length){r.payload=[];for(s=0;s<e.payload.length;++s)r.payload[s]=AO.Message.Block.toObject(e.payload[s],t)}if(e.blockPresences&&e.blockPresences.length){r.blockPresences=[];for(s=0;s<e.blockPresences.length;++s)r.blockPresences[s]=AO.Message.BlockPresence.toObject(e.blockPresences[s],t)}return null!=e.pendingBytes&&e.hasOwnProperty("pendingBytes")&&(r.pendingBytes=e.pendingBytes),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(e){return void 0===e&&(e="type.googleapis.com"),e+"/Message"},e.Wantlist=function(){function e(e){if(this.entries=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.entries=TO.emptyArray,e.prototype.full=!1,e.encode=function(e,t){if(t||(t=RO.create()),null!=e.entries&&e.entries.length)for(var r=0;r<e.entries.length;++r)AO.Message.Wantlist.Entry.encode(e.entries[r],t.uint32(10).fork()).ldelim();return null!=e.full&&Object.hasOwnProperty.call(e,"full")&&t.uint32(16).bool(e.full),t},e.decode=function(e,t){e instanceof kO||(e=kO.create(e));var r=void 0===t?e.len:e.pos+t,s=new AO.Message.Wantlist;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.entries&&s.entries.length||(s.entries=[]),s.entries.push(AO.Message.Wantlist.Entry.decode(e,e.uint32()));break;case 2:s.full=e.bool();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof AO.Message.Wantlist)return e;var t=new AO.Message.Wantlist;if(e.entries){if(!Array.isArray(e.entries))throw TypeError(".Message.Wantlist.entries: array expected");t.entries=[];for(var r=0;r<e.entries.length;++r){if("object"!==typeof e.entries[r])throw TypeError(".Message.Wantlist.entries: object expected");t.entries[r]=AO.Message.Wantlist.Entry.fromObject(e.entries[r])}}return null!=e.full&&(t.full=Boolean(e.full)),t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.entries=[]),t.defaults&&(r.full=!1),e.entries&&e.entries.length){r.entries=[];for(var s=0;s<e.entries.length;++s)r.entries[s]=AO.Message.Wantlist.Entry.toObject(e.entries[s],t)}return null!=e.full&&e.hasOwnProperty("full")&&(r.full=e.full),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(e){return void 0===e&&(e="type.googleapis.com"),e+"/Message.Wantlist"},e.WantType=function(){const e={},t=Object.create(e);return t[e[0]="Block"]=0,t[e[1]="Have"]=1,t}(),e.Entry=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.block=TO.newBuffer([]),e.prototype.priority=0,e.prototype.cancel=!1,e.prototype.wantType=0,e.prototype.sendDontHave=!1,e.encode=function(e,t){return t||(t=RO.create()),null!=e.block&&Object.hasOwnProperty.call(e,"block")&&t.uint32(10).bytes(e.block),null!=e.priority&&Object.hasOwnProperty.call(e,"priority")&&t.uint32(16).int32(e.priority),null!=e.cancel&&Object.hasOwnProperty.call(e,"cancel")&&t.uint32(24).bool(e.cancel),null!=e.wantType&&Object.hasOwnProperty.call(e,"wantType")&&t.uint32(32).int32(e.wantType),null!=e.sendDontHave&&Object.hasOwnProperty.call(e,"sendDontHave")&&t.uint32(40).bool(e.sendDontHave),t},e.decode=function(e,t){e instanceof kO||(e=kO.create(e));var r=void 0===t?e.len:e.pos+t,s=new AO.Message.Wantlist.Entry;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.block=e.bytes();break;case 2:s.priority=e.int32();break;case 3:s.cancel=e.bool();break;case 4:s.wantType=e.int32();break;case 5:s.sendDontHave=e.bool();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof AO.Message.Wantlist.Entry)return e;var t=new AO.Message.Wantlist.Entry;switch(null!=e.block&&("string"===typeof e.block?TO.base64.decode(e.block,t.block=TO.newBuffer(TO.base64.length(e.block)),0):e.block.length>=0&&(t.block=e.block)),null!=e.priority&&(t.priority=0|e.priority),null!=e.cancel&&(t.cancel=Boolean(e.cancel)),e.wantType){case"Block":case 0:t.wantType=0;break;case"Have":case 1:t.wantType=1;break}return null!=e.sendDontHave&&(t.sendDontHave=Boolean(e.sendDontHave)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(t.bytes===String?r.block="":(r.block=[],t.bytes!==Array&&(r.block=TO.newBuffer(r.block))),r.priority=0,r.cancel=!1,r.wantType=t.enums===String?"Block":0,r.sendDontHave=!1),null!=e.block&&e.hasOwnProperty("block")&&(r.block=t.bytes===String?TO.base64.encode(e.block,0,e.block.length):t.bytes===Array?Array.prototype.slice.call(e.block):e.block),null!=e.priority&&e.hasOwnProperty("priority")&&(r.priority=e.priority),null!=e.cancel&&e.hasOwnProperty("cancel")&&(r.cancel=e.cancel),null!=e.wantType&&e.hasOwnProperty("wantType")&&(r.wantType=t.enums===String?AO.Message.Wantlist.WantType[e.wantType]:e.wantType),null!=e.sendDontHave&&e.hasOwnProperty("sendDontHave")&&(r.sendDontHave=e.sendDontHave),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(e){return void 0===e&&(e="type.googleapis.com"),e+"/Message.Wantlist.Entry"},e}(),e}(),e.Block=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.prefix=TO.newBuffer([]),e.prototype.data=TO.newBuffer([]),e.encode=function(e,t){return t||(t=RO.create()),null!=e.prefix&&Object.hasOwnProperty.call(e,"prefix")&&t.uint32(10).bytes(e.prefix),null!=e.data&&Object.hasOwnProperty.call(e,"data")&&t.uint32(18).bytes(e.data),t},e.decode=function(e,t){e instanceof kO||(e=kO.create(e));var r=void 0===t?e.len:e.pos+t,s=new AO.Message.Block;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.prefix=e.bytes();break;case 2:s.data=e.bytes();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof AO.Message.Block)return e;var t=new AO.Message.Block;return null!=e.prefix&&("string"===typeof e.prefix?TO.base64.decode(e.prefix,t.prefix=TO.newBuffer(TO.base64.length(e.prefix)),0):e.prefix.length>=0&&(t.prefix=e.prefix)),null!=e.data&&("string"===typeof e.data?TO.base64.decode(e.data,t.data=TO.newBuffer(TO.base64.length(e.data)),0):e.data.length>=0&&(t.data=e.data)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(t.bytes===String?r.prefix="":(r.prefix=[],t.bytes!==Array&&(r.prefix=TO.newBuffer(r.prefix))),t.bytes===String?r.data="":(r.data=[],t.bytes!==Array&&(r.data=TO.newBuffer(r.data)))),null!=e.prefix&&e.hasOwnProperty("prefix")&&(r.prefix=t.bytes===String?TO.base64.encode(e.prefix,0,e.prefix.length):t.bytes===Array?Array.prototype.slice.call(e.prefix):e.prefix),null!=e.data&&e.hasOwnProperty("data")&&(r.data=t.bytes===String?TO.base64.encode(e.data,0,e.data.length):t.bytes===Array?Array.prototype.slice.call(e.data):e.data),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(e){return void 0===e&&(e="type.googleapis.com"),e+"/Message.Block"},e}(),e.BlockPresenceType=function(){const e={},t=Object.create(e);return t[e[0]="Have"]=0,t[e[1]="DontHave"]=1,t}(),e.BlockPresence=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.cid=TO.newBuffer([]),e.prototype.type=0,e.encode=function(e,t){return t||(t=RO.create()),null!=e.cid&&Object.hasOwnProperty.call(e,"cid")&&t.uint32(10).bytes(e.cid),null!=e.type&&Object.hasOwnProperty.call(e,"type")&&t.uint32(16).int32(e.type),t},e.decode=function(e,t){e instanceof kO||(e=kO.create(e));var r=void 0===t?e.len:e.pos+t,s=new AO.Message.BlockPresence;while(e.pos<r){var n=e.uint32();switch(n>>>3){case 1:s.cid=e.bytes();break;case 2:s.type=e.int32();break;default:e.skipType(7&n);break}}return s},e.fromObject=function(e){if(e instanceof AO.Message.BlockPresence)return e;var t=new AO.Message.BlockPresence;switch(null!=e.cid&&("string"===typeof e.cid?TO.base64.decode(e.cid,t.cid=TO.newBuffer(TO.base64.length(e.cid)),0):e.cid.length>=0&&(t.cid=e.cid)),e.type){case"Have":case 0:t.type=0;break;case"DontHave":case 1:t.type=1;break}return t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(t.bytes===String?r.cid="":(r.cid=[],t.bytes!==Array&&(r.cid=TO.newBuffer(r.cid))),r.type=t.enums===String?"Have":0),null!=e.cid&&e.hasOwnProperty("cid")&&(r.cid=t.bytes===String?TO.base64.encode(e.cid,0,e.cid.length):t.bytes===Array?Array.prototype.slice.call(e.cid):e.cid),null!=e.type&&e.hasOwnProperty("type")&&(r.type=t.enums===String?AO.Message.BlockPresenceType[e.type]:e.type),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(e){return void 0===e&&(e="type.googleapis.com"),e+"/Message.BlockPresence"},e}(),e})(),PO={Block:CO.Wantlist.WantType.Block,Have:CO.Wantlist.WantType.Have},DO=(e,t)=>Array.prototype.slice.call(t,0).sort(((t,r)=>{const s=e(t),n=e(r);return s<n?-1:s>n?1:0}));class NO{constructor(e,t){this.set=t?JC({system:"ipfs",component:"bitswap",metric:"wantlist",metrics:t.metrics}):new Map,this._stats=e}get length(){return this.set.size}add(e,t,r){const s=e.toString($e.base58btc),n=this.set.get(s);n?(n.inc(),n.priority=t,n.wantType===PO.Have&&r===PO.Block&&(n.wantType=r)):(this.set.set(s,new IO(e,t,r)),this._stats&&this._stats.push(null,"wantListSize",1))}remove(e){const t=e.toString($e.base58btc),r=this.set.get(t);r&&(r.dec(),r.hasRefs()||(this.set.delete(t),this._stats&&this._stats.push(null,"wantListSize",-1)))}removeForce(e){this.set.has(e)&&this.set.delete(e)}forEach(e){return this.set.forEach(e)}entries(){return this.set.entries()}sortedEntries(){return new Map(DO((e=>e[1].key),Array.from(this.set.entries())))}contains(e){const t=e.toString($e.base58btc);return this.set.has(t)}get(e){const t=e.toString($e.base58btc);return this.set.get(t)}}NO.Entry=IO;const OO=NO.Entry;class LO{constructor(e,t,r,s,n){this.entry=new OO(e,t,r),this.cancel=Boolean(s),this.sendDontHave=Boolean(n)}get cid(){return this.entry.cid}set cid(e){this.entry.cid=e}get priority(){return this.entry.priority}set priority(e){this.entry.priority=e}get wantType(){return this.entry.wantType}set wantType(e){this.entry.wantType=e}get[Symbol.toStringTag](){const e=this.cid.toString($e.base58btc);return`BitswapMessageEntry ${e} <cancel: ${this.cancel}, priority: ${this.priority}>`}equals(e){return this.cancel===e.cancel&&this.sendDontHave===e.sendDontHave&&this.wantType===e.wantType&&this.entry.equals(e.entry)}}const xO=(e,t)=>{const r=["bitswap"];return t&&r.push(t),e&&r.push(`${e.toString().slice(0,8)}`),Object.assign(Nw(r.join(":")),{error:Nw(r.concat(["error"]).join(":"))})},MO=(e,t)=>{if(e.size!==t.size)return!1;for(const[r,s]of e){const e=t.get(r);if(void 0===e)return!1;if(s instanceof Uint8Array&&e instanceof Uint8Array&&!(0,ur.f)(s,e))return!1;if(s instanceof LO&&e instanceof LO&&!s.equals(e))return!1}return!0};class BO{constructor(e){this.full=e,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}get empty(){return 0===this.blocks.size&&0===this.wantlist.size&&0===this.blockPresences.size}addEntry(e,t,r,s,n){null==r&&(r=BO.WantType.Block);const i=e.toString($e.base58btc),o=this.wantlist.get(i);o?(o.wantType===r&&(o.priority=t),s&&(o.cancel=Boolean(s)),n&&(o.sendDontHave=Boolean(n)),r===BO.WantType.Block&&o.wantType===BO.WantType.Have&&(o.wantType=r)):this.wantlist.set(i,new LO(e,t,r,s,n))}addBlock(e,t){const r=e.toString($e.base58btc);this.blocks.set(r,t)}addHave(e){const t=e.toString($e.base58btc);this.blockPresences.has(t)||this.blockPresences.set(t,BO.BlockPresenceType.Have)}addDontHave(e){const t=e.toString($e.base58btc);this.blockPresences.has(t)||this.blockPresences.set(t,BO.BlockPresenceType.DontHave)}cancel(e){const t=e.toString($e.base58btc);this.wantlist.delete(t),this.addEntry(e,0,BO.WantType.Block,!0,!1)}setPendingBytes(e){this.pendingBytes=e}serializeToBitswap100(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),cancel:Boolean(e.cancel)}))),full:!!this.full||void 0},blocks:Array.from(this.blocks.values())};return CO.encode(e).finish()}serializeToBitswap110(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),wantType:e.wantType,cancel:Boolean(e.cancel),sendDontHave:Boolean(e.sendDontHave)}))),full:!!this.full||void 0},blockPresences:[],payload:[],pendingBytes:this.pendingBytes};for(const[t,r]of this.blocks.entries()){const s=A.CID.parse(t),n=s.version,i=s.code,o=s.multihash.code,a=s.multihash.digest.length,c=SO([n,i,o,a]);e.payload.push(new CO.Block({prefix:c,data:r}))}for(const[t,r]of this.blockPresences)e.blockPresences.push(new CO.BlockPresence({cid:A.CID.parse(t).bytes,type:r}));return this.pendingBytes>0&&(e.pendingBytes=this.pendingBytes),CO.encode(e).finish()}equals(e){return!!(this.full===e.full&&this.pendingBytes===e.pendingBytes&&MO(this.wantlist,e.wantlist)&&MO(this.blocks,e.blocks)&&MO(this.blockPresences,e.blockPresences))}get[Symbol.toStringTag](){const e=Array.from(this.wantlist.keys()),t=Array.from(this.blocks.keys());return`BitswapMessage <full: ${this.full}, list: ${e}, blocks: ${t}>`}}BO.deserialize=async(e,t)=>{const r=CO.decode(e),s=r.wantlist&&r.wantlist.full||!1,n=new BO(s);return r.wantlist&&r.wantlist.entries&&r.wantlist.entries.forEach((e=>{if(!e.block)return;const t=A.CID.decode(e.block);n.addEntry(t,e.priority||0,e.wantType,Boolean(e.cancel),Boolean(e.sendDontHave))})),r.blockPresences&&r.blockPresences.forEach((e=>{if(!e.cid)return;const t=A.CID.decode(e.cid);e.type===BO.BlockPresenceType.Have?n.addHave(t):n.addDontHave(t)})),r.blocks.length>0?(await Promise.all(r.blocks.map((async e=>{const t=await ti.sha256.digest(e),r=A.CID.createV0(t);n.addBlock(r,e)}))),n):r.payload.length>0?(await Promise.all(r.payload.map((async e=>{if(!e.prefix||!e.data)return;const r=EO(e.prefix),s=r[0],i=r[1],o=r[2],a=o===ti.sha256.code?ti.sha256:t&&await t.getHasher(o);if(!a)throw h(new Error("Unknown hash algorithm"),"ERR_UNKNOWN_HASH_ALG");const c=await a.digest(e.data),l=A.CID.create(s,i,c);n.addBlock(l,e.data)}))),n.setPendingBytes(r.pendingBytes),n):n},BO.blockPresenceSize=e=>e.bytes.length+1,BO.Entry=LO,BO.WantType={Block:CO.Wantlist.WantType.Block,Have:CO.Wantlist.WantType.Have},BO.BlockPresenceType={Have:CO.BlockPresenceType.Have,DontHave:CO.BlockPresenceType.DontHave};const UO=3,jO=Math.pow(2,31)-1,VO=1e3,zO=1;var FO=$O;function $O(e,t,r){var s=null,n=null,i=function(){s&&(clearTimeout(s),n=null,s=null)},o=function(){var e=n;i(),e&&e()},a=function(){if(!t)return e.apply(this,arguments);var o=this,a=arguments,c=r&&!s;return i(),n=function(){e.apply(o,a)},s=setTimeout((function(){if(s=null,!c){var e=n;return n=null,e()}}),t),c?n():void 0};return a.cancel=i,a.flush=o,a}class KO{constructor(e,t,r){this.peerId=t,this.network=r,this.refcnt=1,this._entries=[],this._log=xO(e,"msgqueue"),this.sendEntries=FO(this._sendEntries.bind(this),zO)}addMessage(e){e.empty||this.send(e)}addEntries(e){this._entries=this._entries.concat(e),this.sendEntries()}_sendEntries(){if(!this._entries.length)return;const e=new BO(!1);this._entries.forEach((t=>{t.cancel?e.cancel(t.cid):e.addEntry(t.cid,t.priority)})),this._entries=[],this.addMessage(e)}async send(e){try{await this.network.connectTo(this.peerId)}catch(mu){return void this._log.error("cant connect to peer %s: %s",this.peerId.toString(),mu.message)}this._log("sending message to peer %s",this.peerId.toString()),this.network.sendMessage(this.peerId,e).catch((e=>{this._log.error("send error: %s",e.message)}))}}class HO{constructor(e,t,r,s){this.peers=JC({system:"ipfs",component:"bitswap",metric:"want-manager-peers",metrics:s.metrics}),this.wantlist=new NO(r,s),this.network=t,this._stats=r,this._peerId=e,this._log=xO(e,"want")}_addEntries(e,t,r){const s=e.map(((e,r)=>new BO.Entry(e,jO-r,BO.WantType.Block,t)));s.forEach((e=>{e.cancel?r?this.wantlist.removeForce(e.cid.toString($e.base58btc)):this.wantlist.remove(e.cid):(this._log("adding to wl"),this.wantlist.add(e.cid,e.priority))}));for(const n of this.peers.values())n.addEntries(s)}_startPeerHandler(e){let t=this.peers.get(e.toString());if(t)return void t.refcnt++;t=new KO(this._peerId,e,this.network);const r=new BO(!0);for(const s of this.wantlist.entries())r.addEntry(s[1].cid,s[1].priority);return t.addMessage(r),this.peers.set(e.toString(),t),t}_stopPeerHandler(e){const t=this.peers.get(e.toString());t&&(t.refcnt--,t.refcnt>0||this.peers.delete(e.toString()))}wantBlocks(e,t={}){this._addEntries(e,!1),t&&t.signal&&t.signal.addEventListener("abort",(()=>{this.cancelWants(e)}))}unwantBlocks(e){this._log("unwant blocks: %s",e.length),this._addEntries(e,!0,!0)}cancelWants(e){this._log("cancel wants: %s",e.length),this._addEntries(e,!0)}connectedPeers(){return Array.from(this.peers.keys())}connected(e){this._startPeerHandler(e)}disconnected(e){this._stopPeerHandler(e)}start(){}stop(){this.peers.forEach((e=>this.disconnected(e.peerId)))}}class qO extends Error{constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}}function GO(e){if(null!=e){if("function"===typeof e[Symbol.iterator])return e[Symbol.iterator]();if("function"===typeof e[Symbol.asyncIterator])return e[Symbol.asyncIterator]();if("function"===typeof e.next)return e}throw new Error("argument is not an iterator or iterable")}function WO(e,t,r){const s=r??{},n=GO(e);async function*i(){let r;const i=()=>{null!=r&&r()};t.addEventListener("abort",i);while(1){let o;try{if(t.aborted){const{abortMessage:e,abortCode:t}=s;throw new qO(e,t)}const e=new Promise(((e,t)=>{r=()=>{const{abortMessage:e,abortCode:r}=s;t(new qO(e,r))}}));o=await Promise.race([e,n.next()]),r=null}catch(mu){t.removeEventListener("abort",i);const o="aborted"===mu.type&&t.aborted;if(o&&null!=s.onAbort&&await s.onAbort(e),"function"===typeof n.return)try{const e=n.return();e instanceof Promise&&e.catch((e=>{null!=s.onReturnError&&s.onReturnError(e)}))}catch(mu){null!=s.onReturnError&&s.onReturnError(mu)}if(o&&!0===s.returnOnAbort)return;throw mu}if(!0===o.done)break;yield o.value}t.removeEventListener("abort",i)}return i()}const YO="/ipfs/bitswap/1.0.0",QO="/ipfs/bitswap/1.1.0",ZO="/ipfs/bitswap/1.2.0",XO=32,JO=128,eL=3e4;class tL{constructor(e,t,r,s={}){this._log=xO(e.peerId,"network"),this._libp2p=e,this._bitswap=t,this._protocols=[YO],s.b100Only||(this._protocols.unshift(QO),this._protocols.unshift(ZO)),this._stats=r,this._running=!1,this._onPeerConnect=this._onPeerConnect.bind(this),this._onPeerDisconnect=this._onPeerDisconnect.bind(this),this._onConnection=this._onConnection.bind(this),this._hashLoader=s.hashLoader,this._maxInboundStreams=s.maxInboundStreams??XO,this._maxOutboundStreams=s.maxOutboundStreams??JO,this._incomingStreamTimeout=s.incomingStreamTimeout??eL}async start(){this._running=!0,await this._libp2p.handle(this._protocols,this._onConnection,{maxInboundStreams:this._maxInboundStreams,maxOutboundStreams:this._maxOutboundStreams});const e=(0,KE.a)({onConnect:this._onPeerConnect,onDisconnect:this._onPeerDisconnect});this._registrarIds=[];for(const t of this._protocols)this._registrarIds.push(await this._libp2p.registrar.register(t,e));this._libp2p.getConnections().forEach((e=>{this._onPeerConnect(e.remotePeer)}))}async stop(){if(this._running=!1,await this._libp2p.unhandle(this._protocols),null!=this._registrarIds){for(const e of this._registrarIds)this._libp2p.registrar.unregister(e);this._registrarIds=[]}}_onConnection({stream:e,connection:t}){if(!this._running)return;const r=new Fe.TimeoutController(this._incomingStreamTimeout);Promise.resolve().then((async()=>{this._log("incoming new bitswap %s connection from %p",e.stat.protocol,t.remotePeer),await(0,Cs.zG)(WO(e.source,r.signal),PS.J(),(async e=>{for await(const s of e){try{const e=await BO.deserialize(s.subarray(),this._hashLoader);await this._bitswap._receiveMessage(t.remotePeer,e)}catch(mu){this._bitswap._receiveError(mu);break}r.reset()}}))})).catch((t=>{this._log(t),e.abort(t)})).finally((()=>{r.clear(),e.close()}))}_onPeerConnect(e){this._bitswap._onPeerConnected(e)}_onPeerDisconnect(e){this._bitswap._onPeerDisconnected(e)}findProviders(e,t={}){return this._libp2p.contentRouting.findProviders(e,t)}async findAndConnect(e,t){const r=[];let s=0;for await(const n of this.findProviders(e,t))if(this._log(`connecting to provider ${n.id}`),r.push(this.connectTo(n.id,t).catch((e=>{this._log.error(e)}))),s++,s===UO)break;await Promise.all(r)}async provide(e,t){await this._libp2p.contentRouting.provide(e,t)}async sendMessage(e,t){if(!this._running)throw new Error("network isn't running");const r=e.toString();this._log("sendMessage to %s",r,t);const s=await this._libp2p.dial(e),n=await s.newStream([ZO,QO,YO]);await rL(n,t,this._log),this._updateSentStats(e,t.blocks)}async connectTo(e,t){if(!this._running)throw new Error("network isn't running");return this._libp2p.dial(e,t)}_updateSentStats(e,t){const r=e.toString();if(this._stats){for(const e of t.values())this._stats.push(r,"dataSent",e.length);this._stats.push(r,"blocksSent",t.size)}}}async function rL(e,t,r){try{let r;switch(e.stat.protocol){case YO:r=t.serializeToBitswap100();break;case QO:case ZO:r=t.serializeToBitswap110();break;default:throw new Error("Unknown protocol: "+e.stat.protocol)}await(0,Cs.zG)([r],PS.c(),e)}catch(mu){r(mu)}finally{e.close()}}class sL{constructor(e){this.partner=e,this.wantlist=new NO,this.exchangeCount=0,this.sentToPeer=new Map,this.accounting={bytesSent:0,bytesRecv:0}}sentBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesSent+=e}receivedBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesRecv+=e}wants(e,t,r){this.wantlist.add(e,t,r)}cancelWant(e){this.wantlist.remove(e)}wantlistContains(e){return this.wantlist.get(e)}debtRatio(){return this.accounting.bytesSent/(this.accounting.bytesRecv+1)}}class nL extends Map{constructor(e,t){super(),this._cmp=t||this._defaultSort,this._keys=[];for(const[r,s]of e||[])this.set(r,s)}update(e){if(e<0||e>=this._keys.length)return;const t=this._keys[e];this._keys.splice(e,1);const r=this._find(t);this._keys.splice(r,0,t)}set(e,t){if(this.has(e)){const t=this.indexOf(e);this._keys.splice(t,1)}super.set(e,t);const r=this._find(e);return this._keys.splice(r,0,e),this}clear(){super.clear(),this._keys=[]}delete(e){if(!this.has(e))return!1;const t=this.indexOf(e);return this._keys.splice(t,1),super.delete(e)}indexOf(e){if(!this.has(e))return-1;const t=this._find(e);if(this._keys[t]===e)return t;for(let r=1;r<this._keys.length;r++){if(this._keys[t+r]===e)return t+r;if(this._keys[t-r]===e)return t-r}return-1}_find(e){let t=0,r=this._keys.length;while(t<r){const s=t+r>>>1,n=this._kCmp(this._keys[s],e);if(n<0)t=s+1;else{if(!(n>0))return s;r=s}}return t}*keys(){for(const e of this._keys)yield e}*values(){for(const e of this._keys)yield this.get(e)}*entries(){for(const e of this._keys)yield[e,this.get(e)]}*[Symbol.iterator](){yield*this.entries()}forEach(e,t){if(e)for(const r of this._keys)e.apply(t,[[r,this.get(r)]])}_defaultSort(e,t){return e[0]<t[0]?-1:t[0]<e[0]?1:0}_kCmp(e,t){return this._cmp([e,this.get(e)],[t,this.get(t)])}}const iL={hasNewInfo(){return!1},merge(){}};class oL{constructor(e=iL){this._taskMerger=e,this._byPeer=new nL([],aL.compare)}pushTasks(e,t){let r=this._byPeer.get(e.toString());r||(r=new aL(e,this._taskMerger)),r.pushTasks(t),this._byPeer.set(e.toString(),r)}popTasks(e){const t=this._head();if(void 0===t)return{tasks:[],pendingSize:0};const{tasks:r,pendingSize:s}=t.popTasks(e);if(0===r.length)return{tasks:r,pendingSize:s};const n=t.peerId;return t.isIdle()?this._byPeer.delete(n.toString()):this._byPeer.update(0),{peerId:n,tasks:r,pendingSize:s}}_head(){if(0!==this._byPeer.size)for(const[,e]of this._byPeer)return e}remove(e,t){const r=this._byPeer.get(t.toString());r&&r.remove(e)}tasksDone(e,t){const r=this._byPeer.get(e.toString());if(!r)return;const s=this._byPeer.indexOf(e.toString());for(const n of t)r.taskDone(n);this._byPeer.update(s)}}class aL{constructor(e,t){this.peerId=e,this._taskMerger=t,this._activeTotalSize=0,this._pending=new cL,this._active=new Set}pushTasks(e){for(const t of e)this._pushTask(t)}_pushTask(e){if(!this._taskHasMoreInfoThanActiveTasks(e))return;const t=this._pending.get(e.topic);if(t)return e.priority>t.priority&&this._pending.updatePriority(e.topic,e.priority),void this._taskMerger.merge(e,t);this._pending.add(e)}_taskHasMoreInfoThanActiveTasks(e){const t=[];for(const r of this._active)r.topic===e.topic&&t.push(r);return 0===t.length||this._taskMerger.hasNewInfo(e,t)}popTasks(e){let t=0;const r=[],s=this._pending.tasks();for(let n=0;n<s.length&&t<e;n++){const e=s[n];r.push(e),t+=e.size,this._pending.delete(e.topic),this._activeTotalSize+=e.size,this._active.add(e)}return{tasks:r,pendingSize:this._pending.totalSize}}taskDone(e){this._active.has(e)&&(this._activeTotalSize-=e.size,this._active.delete(e))}remove(e){this._pending.delete(e)}isIdle(){return 0===this._pending.length&&0===this._active.size}static compare(e,t){return 0===e[1]._pending.length?1:0===t[1]._pending.length?-1:e[1]._activeTotalSize===t[1]._activeTotalSize?t[1]._pending.length-e[1]._pending.length:e[1]._activeTotalSize-t[1]._activeTotalSize}}class cL{constructor(){this._tasks=new nL([],this._compare)}get length(){return this._tasks.size}get totalSize(){return[...this._tasks.values()].reduce(((e,t)=>e+t.task.size),0)}get(e){return(this._tasks.get(e)||{}).task}add(e){this._tasks.set(e.topic,{created:Date.now(),task:e})}delete(e){this._tasks.delete(e)}tasks(){return[...this._tasks.values()].map((e=>e.task))}updatePriority(e,t){const r=this._tasks.get(e);if(!r)return;const s=this._tasks.indexOf(e);r.task.priority=t,this._tasks.update(s)}_compare(e,t){return e[1].task.priority===t[1].task.priority?e[1].created-t[1].created:t[1].task.priority-e[1].task.priority}}const lL={hasNewInfo(e,t){let r=!1,s=!1;for(const n of t)n.data.haveBlock&&(r=!0),n.data.isWantBlock&&(s=!0);return!(s||!e.data.isWantBlock)||!(r||!e.data.haveBlock)},merge(e,t){const r=e.data,s=t.data;!s.haveBlock&&r.haveBlock&&(s.haveBlock=r.haveBlock,s.blockSize=r.blockSize),!s.isWantBlock&&r.isWantBlock&&(s.isWantBlock=!0,s.haveBlock&&!r.haveBlock||(s.haveBlock=r.haveBlock,t.size=e.size)),s.isWantBlock&&s.haveBlock&&(t.size=s.blockSize)}},uL=BO.WantType,hL=16384,dL=1024;class pL{constructor(e,t,r,s,n,i={}){this._log=xO(e,"engine"),this.blockstore=t,this.network=r,this._stats=s,this._opts=this._processOpts(i),this.ledgerMap=JC({system:"ipfs",component:"bitswap",metric:"ledger-map",metrics:n.metrics}),this._running=!1,this._requestQueue=new oL(lL)}_processOpts(e){return{maxSizeReplaceHasWithBlock:dL,targetMessageSize:hL,...e}}_scheduleProcessTasks(){setTimeout((()=>{this._processTasks()}))}async _processTasks(){if(!this._running)return;const{peerId:e,tasks:t,pendingSize:r}=this._requestQueue.popTasks(this._opts.targetMessageSize);if(0===t.length)return;const s=new BO(!1);s.setPendingBytes(r);const n=[],i=new Map;for(const a of t){const e=A.CID.parse(a.topic);a.data.haveBlock?a.data.isWantBlock?(n.push(e),i.set(a.topic,a.data)):s.addHave(e):s.addDontHave(e)}const o=await this._getBlocks(n);for(const[a,c]of i){const e=A.CID.parse(a),t=o.get(a);t?s.addBlock(e,t):c.sendDontHave&&s.addDontHave(e)}if(s.empty)return e&&this._requestQueue.tasksDone(e,t),void this._scheduleProcessTasks();try{e&&await this.network.sendMessage(e,s);for(const[t,r]of o.entries())e&&this.messageSent(e,A.CID.parse(t),r)}catch(mu){this._log.error(mu)}e&&this._requestQueue.tasksDone(e,t),this._scheduleProcessTasks()}wantlistForPeer(e){const t=e.toString(),r=this.ledgerMap.get(t);return r?r.wantlist.sortedEntries():new Map}ledgerForPeer(e){const t=e.toString(),r=this.ledgerMap.get(t);return r?{peer:r.partner,value:r.debtRatio(),sent:r.accounting.bytesSent,recv:r.accounting.bytesRecv,exchanged:r.exchangeCount}:null}peers(){return Array.from(this.ledgerMap.values()).map((e=>e.partner))}receivedBlocks(e){if(e.length){for(const t of this.ledgerMap.values())for(const r of e){const e=t.wantlistContains(r.cid);if(!e)continue;const s=r.data.length,n=this._sendAsBlock(e.wantType,s);let i=s;n||(i=BO.blockPresenceSize(e.cid)),this._requestQueue.pushTasks(t.partner,[{topic:e.cid.toString($e.base58btc),priority:e.priority,size:i,data:{blockSize:s,isWantBlock:n,haveBlock:!0,sendDontHave:!1}}])}this._scheduleProcessTasks()}}async messageReceived(e,t){const r=this._findOrCreate(e);if(t.empty)return;if(t.full&&(r.wantlist=new NO),this._updateBlockAccounting(t.blocks,r),0===t.wantlist.size)return void this._scheduleProcessTasks();const s=[],n=[];t.wantlist.forEach((e=>{e.cancel?(r.cancelWant(e.cid),s.push(e.cid)):(r.wants(e.cid,e.priority,e.wantType),n.push(e))})),this._cancelWants(e,s),await this._addWants(e,n),this._scheduleProcessTasks()}_cancelWants(e,t){for(const r of t)this._requestQueue.remove(r.toString($e.base58btc),e)}async _addWants(e,t){const r=await this._getBlockSizes(t.map((e=>e.cid))),s=[];for(const n of t){const t=n.cid.toString($e.base58btc),i=r.get(t);if(null==i)n.sendDontHave&&s.push({topic:t,priority:n.priority,size:BO.blockPresenceSize(n.cid),data:{isWantBlock:n.wantType===uL.Block,blockSize:0,haveBlock:!1,sendDontHave:n.sendDontHave}});else{const e=this._sendAsBlock(n.wantType,i);let r=i;e||(r=BO.blockPresenceSize(n.cid)),s.push({topic:t,priority:n.priority,size:r,data:{isWantBlock:e,blockSize:i,haveBlock:!0,sendDontHave:n.sendDontHave}})}this._requestQueue.pushTasks(e,s)}}_sendAsBlock(e,t){return e===uL.Block||t<=this._opts.maxSizeReplaceHasWithBlock}async _getBlockSizes(e){const t=await this._getBlocks(e);return new Map([...t].map((([e,t])=>[e,t.length])))}async _getBlocks(e){const t=new Map;return await Promise.all(e.map((async e=>{try{const r=await this.blockstore.get(e);t.set(e.toString($e.base58btc),r)}catch(r){"ERR_NOT_FOUND"!==r.code&&this._log.error("failed to query blockstore for %s: %s",e,r)}}))),t}_updateBlockAccounting(e,t){for(const r of e.values())this._log("got block (%s bytes)",r.length),t.receivedBytes(r.length)}messageSent(e,t,r){const s=this._findOrCreate(e);s.sentBytes(r.length),s.wantlist.remove(t)}numBytesSentTo(e){return this._findOrCreate(e).accounting.bytesSent}numBytesReceivedFrom(e){return this._findOrCreate(e).accounting.bytesRecv}peerDisconnected(e){this.ledgerMap.delete(e.toString())}_findOrCreate(e){const t=e.toString(),r=this.ledgerMap.get(t);if(r)return r;const s=new sL(e);return this.ledgerMap.set(t,s),this._stats&&this._stats.push(t,"peerCount",1),s}start(){this._running=!0}stop(){this._running=!1}}const fL=e=>`unwant:${(0,Ye.B)(e.multihash.bytes,"base64")}`,yL=e=>`block:${(0,Ye.B)(e.multihash.bytes,"base64")}`;class gL extends qT.EventEmitter{constructor(e){super(),this.setMaxListeners(VO),this._log=xO(e,"notif")}hasBlock(e,t){const r=yL(e);this._log(r),this.emit(r,t)}wantBlock(e,t={}){if(!e)throw new Error("Not a valid cid");const r=yL(e),s=fL(e);return this._log(`wantBlock:${e}`),new Promise(((n,i)=>{const o=()=>{this.removeListener(r,a),i(new Error(`Block for ${e} unwanted`))},a=e=>{this.removeListener(s,o),n(e)};this.once(s,o),this.once(r,a),t&&t.signal&&t.signal.addEventListener("abort",(()=>{this.removeListener(r,a),this.removeListener(s,o),i(new Error(`Want for ${e} aborted`))}))}))}unwantBlock(e){const t=fL(e);this._log(t),this.emit(t)}}var mL=r(63573);class wL extends qT.EventEmitter{constructor(e,t){super(),this._options=t,this._queue=[],this._stats={},this._frequencyLastTime=Date.now(),this._frequencyAccumulators={},this._movingAverages={},this._update=this._update.bind(this),e.forEach((e=>{this._stats[e]=BigInt(0),this._movingAverages[e]={},this._options.movingAverageIntervals.forEach((t=>{const r=this._movingAverages[e][t]=mL(t);r.push(this._frequencyLastTime,0)}))})),this._enabled=this._options.enabled}enable(){this._enabled=!0}disable(){this._disabled=!0}stop(){this._timeout&&clearTimeout(this._timeout)}get snapshot(){return Object.assign({},this._stats)}get movingAverages(){return Object.assign({},this._movingAverages)}push(e,t){this._enabled&&(this._queue.push([e,t,Date.now()]),this._resetComputeTimeout())}_resetComputeTimeout(){this._timeout&&clearTimeout(this._timeout),this._timeout=setTimeout(this._update,this._nextTimeout())}_nextTimeout(){const e=this._queue.length/this._options.computeThrottleMaxQueueSize;return Math.max(this._options.computeThrottleTimeout*(1-e),0)}_update(){if(this._timeout=null,this._queue.length){let e;while(this._queue.length){const t=e=this._queue.shift();t&&this._applyOp(t)}e&&this._updateFrequency(e[2]),this.emit("update",this._stats)}}_updateFrequency(e){const t=e-this._frequencyLastTime;t&&Object.keys(this._stats).forEach((r=>{this._updateFrequencyFor(r,t,e)})),this._frequencyLastTime=e}_updateFrequencyFor(e,t,r){const s=this._frequencyAccumulators[e]||0;this._frequencyAccumulators[e]=0;const n=s/t*1e3;let i=this._movingAverages[e];i||(i=this._movingAverages[e]={}),this._options.movingAverageIntervals.forEach((e=>{let t=i[e];t||(t=i[e]=mL(e)),t.push(r,n)}))}_applyOp(e){const t=e[0],r=e[1];if("number"!==typeof r)throw new Error(`invalid increment number: ${r}`);Object.prototype.hasOwnProperty.call(this._stats,t)||(this._stats[t]=BigInt(0)),this._stats[t]=BigInt(this._stats[t])+BigInt(r),this._frequencyAccumulators[t]||(this._frequencyAccumulators[t]=0),this._frequencyAccumulators[t]+=r}}const bL={enabled:!1,computeThrottleTimeout:1e3,computeThrottleMaxQueueSize:1e3,movingAverageIntervals:[6e4,3e5,9e5]};class _L extends qT.EventEmitter{constructor(e,t=[],r=bL){super();const s=Object.assign({},bL,r);if("number"!==typeof s.computeThrottleTimeout)throw new Error("need computeThrottleTimeout");if("number"!==typeof s.computeThrottleMaxQueueSize)throw new Error("need computeThrottleMaxQueueSize");this._initialCounters=t,this._options=s,this._enabled=this._options.enabled,this._global=new wL(t,s),this._global.on("update",(e=>this.emit("update",e))),this._peers=JC({system:"ipfs",component:"bitswap",metric:"stats-peers",metrics:e.metrics})}enable(){this._enabled=!0,this._options.enabled=!0,this._global.enable()}disable(){this._enabled=!1,this._options.enabled=!1,this._global.disable()}stop(){this._enabled=!1,this._global.stop();for(const e of this._peers)e[1].stop()}get snapshot(){return this._global.snapshot}get movingAverages(){return this._global.movingAverages}forPeer(e){const t="string"!==typeof e&&e.toString?e.toString():`${e}`;return this._peers.get(t)}push(e,t,r){if(this._enabled&&(this._global.push(t,r),e)){let s=this._peers.get(e);s||(s=new wL(this._initialCounters,this._options),this._peers.set(e,s)),s.push(t,r)}}disconnected(e){const t=e.toString(),r=this._peers.get(t);r&&(r.stop(),this._peers.delete(t))}}const EL={statsEnabled:!1,statsComputeThrottleTimeout:1e3,statsComputeThrottleMaxQueueSize:1e3},vL=["blocksReceived","dataReceived","dupBlksReceived","dupDataReceived","blocksSent","dataSent","providesBufferLength","wantListLength","peerCount"];class SL extends RE{constructor(e,t,r={}){super(),this._libp2p=e,this._log=xO(this.peerId),this._options=Object.assign({},EL,r),this._stats=new _L(e,vL,{enabled:this._options.statsEnabled,computeThrottleTimeout:this._options.statsComputeThrottleTimeout,computeThrottleMaxQueueSize:this._options.statsComputeThrottleMaxQueueSize}),this.network=new tL(e,this,this._stats,{hashLoader:r.hashLoader,maxInboundStreams:r.maxInboundStreams,maxOutboundStreams:r.maxOutboundStreams,incomingStreamTimeout:r.incomingStreamTimeout}),this.blockstore=t,this.engine=new pL(this.peerId,t,this.network,this._stats,e),this.wm=new HO(this.peerId,this.network,this._stats,e),this.notifications=new gL(this.peerId),this.started=!1}isStarted(){return this.started}get peerId(){return this._libp2p.peerId}async _receiveMessage(e,t){try{await this.engine.messageReceived(e,t)}catch(mu){this._log("failed to receive message",t)}if(0===t.blocks.size)return;const r=[];for(const[s,n]of t.blocks.entries()){const e=A.CID.parse(s);r.push({wasWanted:this.wm.wantlist.contains(e),cid:e,data:n})}this.wm.cancelWants(r.filter((({wasWanted:e})=>e)).map((({cid:e})=>e))),await Promise.all(r.map((({cid:t,wasWanted:r,data:s})=>this._handleReceivedBlock(e,t,s,r))))}async _handleReceivedBlock(e,t,r,s){this._log("received block");const n=await this.blockstore.has(t);this._updateReceiveCounters(e.toString(),t,r,n),s&&await this.put(t,r)}_updateReceiveCounters(e,t,r,s){this._stats.push(e,"blocksReceived",1),this._stats.push(e,"dataReceived",r.length),s&&(this._stats.push(e,"dupBlksReceived",1),this._stats.push(e,"dupDataReceived",r.length))}_receiveError(e){this._log.error("ReceiveError: %s",e.message)}_onPeerConnected(e){this.wm.connected(e)}_onPeerDisconnected(e){this.wm.disconnected(e),this.engine.peerDisconnected(e),this._stats.disconnected(e)}enableStats(){this._stats.enable()}disableStats(){this._stats.disable()}wantlistForPeer(e,t){return this.engine.wantlistForPeer(e)}ledgerForPeer(e){return this.engine.ledgerForPeer(e)}async get(e,t={}){const r=(e,t)=>(this.wm.wantBlocks([e],t),this.notifications.wantBlock(e,t));let s=!1;const n=async(e,t)=>{try{const r=await this.blockstore.get(e,t);return r}catch(mu){if("ERR_NOT_FOUND"!==mu.code)throw mu;return s||(s=!0,this.network.findAndConnect(e,t).catch((e=>this._log.error(e)))),r(e,t)}},i=new AbortController,o=t.signal?(0,ut.anySignal)([t.signal,i.signal]):i.signal;try{const t=await Promise.race([this.notifications.wantBlock(e,{signal:o}),n(e,{signal:o})]);return t}finally{i.abort()}}async*getMany(e,t={}){for await(const r of e)yield this.get(r,t)}unwant(e){const t=Array.isArray(e)?e:[e];this.wm.unwantBlocks(t),t.forEach((e=>this.notifications.unwantBlock(e)))}cancelWants(e){this.wm.cancelWants(Array.isArray(e)?e:[e])}async put(e,t,r){await this.blockstore.put(e,t),this._sendHaveBlockNotifications(e,t)}async*putMany(e,t){for await(const{key:r,value:s}of this.blockstore.putMany(e,t))this._sendHaveBlockNotifications(r,s),yield{key:r,value:s}}_sendHaveBlockNotifications(e,t){this.notifications.hasBlock(e,t),this.engine.receivedBlocks([{cid:e,data:t}]),this.network.provide(e).catch((e=>{this._log.error("Failed to provide: %s",e.message)}))}getWantlist(){return this.wm.wantlist.entries()}peers(){return this.engine.peers()}stat(){return this._stats}async start(){this.wm.start(),await this.network.start(),this.engine.start(),this.started=!0}async stop(){this._stats.stop(),this.wm.stop(),await this.network.stop(),this.engine.stop(),this.started=!1}unwrap(){return this.blockstore}}const IL=(e,t,r={})=>new SL(e,t,r);function kL(e){return e=e||new Error("Not Found"),h(e,"ERR_NOT_FOUND")}function RL(e){return e=e||new Error("Aborted"),h(e,"ERR_ABORTED")}class TL extends RE{constructor(e,t){super(),this.child=e,this.bitswap=t}open(){return this.child.open()}close(){return this.child.close()}unwrap(){return this.child}async put(e,t,r={}){await this.has(e)||(this.bitswap.isStarted()?await this.bitswap.put(e,t,r):await this.child.put(e,t,r))}async*putMany(e,t={}){const r=ms(e,(async({key:e})=>!await this.has(e)));this.bitswap.isStarted()?yield*this.bitswap.putMany(r,t):yield*this.child.putMany(r,t)}async get(e,t={}){return!await this.has(e)&&this.bitswap.isStarted()?this.bitswap.get(e,t):this.child.get(e,t)}async*getMany(e,t={}){const r=(0,_s.d)({objectMode:!0}),s=(0,_s.d)({objectMode:!0});Promise.resolve().then((async()=>{for await(const t of e)!await this.has(t)&&this.bitswap.isStarted()?r.push(t):s.push(t);r.end(),s.end()})),yield*Ps(this.bitswap.getMany(r,t),this.child.getMany(s,t))}async delete(e,t){await this.child.delete(e,t)}async*deleteMany(e,t){yield*this.child.deleteMany(e,t)}async has(e,t={}){return this.child.has(e,t)}async*query(e,t={}){yield*this.child.query(e,t)}async*queryKeys(e,t={}){yield*this.child.queryKeys(e,t)}}class AL{constructor(e,t,r,s,n){this.peerId=e,this.libp2p=t,this.bitswap=r,this.repo=s,this.blockstore=n}static async start({peerId:e,repo:t,print:r,hashers:s,options:n}){t.closed&&await t.open();const i=await t.config.getAll(),o=await cO({options:n,repo:t,peerId:e,multiaddrs:CL(e,i),config:i,keychainConfig:void 0});await o.start();for(const l of o.getMultiaddrs())r(`Swarm listening on ${l.toString()}`);const a=IL(o,t.blocks,{statsEnabled:!0,hashLoader:s,maxInboundStreams:1024,maxOutboundStreams:1024});await a.start();const c=new TL(t.blocks,a);return t.blocks=c,t.pins.blockstore=c,new AL(e,o,a,t,c)}static async stop(e){e.repo.blocks=e.blockstore.unwrap(),e.repo.pins.blockstore=e.blockstore.unwrap(),await e.bitswap.stop(),await e.libp2p.stop()}}const CL=(e,t)=>{const r=e.toString(),s=[],n=t.Addresses&&t.Addresses.Swarm||[];for(const i of n){let e=(0,qe.HM)(i);if(e.protoCodes().includes(PL))throw h(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"),"ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");const t=e.getPeerId();t&&t!==r&&(e=e.encapsulate(`/p2p/${r}`)),s.push(e)}return s},PL=479;function DL({network:e}){async function t(t={}){const r=[],{libp2p:s}=await e.use(t);return await s.peerStore.forEach((e=>{r.push({id:e.id,addrs:e.addresses.map((e=>e.multiaddr))})})),r}return gt(t)}function NL({network:e}){async function t(t,r={}){const{libp2p:s}=await e.use(r);await s.dial(t,r)}return gt(t)}function OL({network:e}){async function t(t,r={}){const{libp2p:s}=await e.use(r);await s.hangUp(t)}return gt(t)}function LL({network:e}){async function t(t={}){const{libp2p:r}=await e.use(t);return r.getMultiaddrs()}return gt(t)}function xL({network:e}){async function t(t={}){const{libp2p:r}=await e.use(t);if(t.verbose){const e=[];for(const s of r.getConnections()){const r={addr:s.remoteAddr,peer:s.remotePeer};(t.verbose||t.direction)&&(r.direction=s.stat.direction),t.verbose&&(r.muxer=s.stat.multiplexer,r.latency="n/a",r.streams=[]),e.push(r)}return e}const s=new Map;for(const e of r.getConnections()){const t={addr:e.remoteAddr,peer:e.remotePeer};s.set(e.remotePeer.toString(),t)}return Array.from(s.values())}return gt(t)}class ML{constructor({network:e}){this.addrs=DL({network:e}),this.connect=NL({network:e}),this.disconnect=OL({network:e}),this.localAddrs=LL({network:e}),this.peers=xL({network:e})}}const BL={success:!0,time:0,text:""};function UL({network:e}){async function*t(t,r={}){const{libp2p:s}=await e.use();r.count=r.count||10;const n=await s.peerStore.get(t);let i=n&&n.id;if(!i){yield{...BL,text:`Looking up peer ${t}`};const e=await s.peerRouting.findPeer(t);i=e&&e.id}if(!i)throw new Error("Peer was not found");yield{...BL,text:`PING ${i.toString()}`};let o=0,a=0;for(let e=0;e<r.count;e++)try{const e=await s.ping(i);a+=e,o++,yield{...BL,time:e}}catch(mu){yield{...BL,success:!1,text:mu.toString()}}if(o){const e=a/o;yield{...BL,text:`Average latency: ${e}ms`}}}return gt(t)}const jL="/ipns/";function VL(e){let t;if(e.startsWith(jL)&&(e=e.substring(jL.length)),"1"!==e[0]&&"Q"!==e[0]||(e=`z${e}`),"z"===e[0]&&(t=$e.base58btc.decode(e)),"k"===e[0]&&(t=Qs.base36.decode(e)),!t)throw new Error("Could not parse string");if(1!==t[0]&&114!==t[1]&&(t=(0,Ir.concat)([[1,114],t])),40!==t.length)throw new Error("Incorrect length "+t.length);return(0,Ir.concat)([(0,ze.m)(jL),t.subarray(2)])}function zL({network:e,repo:t,peerId:r}){const{get:s,put:n,findProvs:i,findPeer:o,provide:a,query:c}={async*get(t,s={}){const{libp2p:n}=await FL(e,r,s),i=t instanceof Uint8Array?t:VL(t);if(null==n.dht)throw h(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*n.dht.get(i,s)},async*put(t,s,n){const{libp2p:i}=await FL(e,r,n),o=t instanceof Uint8Array?t:VL(t);if(null==i.dht)throw h(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*i.dht.put(o,s,n)},async*findProvs(t,s={}){const{libp2p:n}=await FL(e,r,s);if(null==n.dht)throw h(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*n.dht.findProviders(t,{signal:s.signal})},async*findPeer(t,s={}){const{libp2p:n}=await FL(e,r,s);if(null==n.dht)throw h(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*n.dht.findPeer(t,{signal:s.signal})},async*provide(s,n={recursive:!1}){const{libp2p:i}=await FL(e,r,n),o=await t.blocks.has(s);if(!o)throw h(new Error("block(s) not found locally, cannot provide"),"ERR_BLOCK_NOT_FOUND");if(n.recursive)throw h(new Error("not implemented yet"),"ERR_NOT_IMPLEMENTED_YET");if(null==i.dht)throw h(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*i.dht.provide(s)},async*query(t,s={}){const{libp2p:n}=await FL(e,r,s);let i;const o=A.CID.asCID(t);if(i=null!=o?o.multihash.bytes:(0,Ht.jE)(t.toString()).toBytes(),null==n.dht)throw h(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*n.dht.getClosestPeers(i,s)}};return{get:gt(s),put:gt(n),findProvs:gt(i),findPeer:gt(o),provide:gt(a),query:gt(c)}}const FL=async(e,t,r)=>{const s=await e.use(r);if(null!=s.libp2p.dht)return s;{const e=async function*(){yield{from:t,name:"QUERY_ERROR",type:3,error:new Ve("dht not enabled")}};return{libp2p:{dht:{get:e,put:e,findProviders:e,findPeer:e,provide:e,getClosestPeers:e}}}}};function $L({network:e,config:t}){const r=Ss(t||{},"Pubsub.Enabled",!0),s={};let n;return{subscribe:r?gt(i):KL,unsubscribe:r?gt(o):KL,publish:r?gt(a):KL,ls:r?gt(c):KL,peers:r?gt(l):KL};async function i(t,r,i={}){const{libp2p:o}=await e.use(i);o.pubsub.subscribe(t),null==n&&(n=e=>{const t=e.detail;s[t.topic]&&s[t.topic].forEach((e=>{"function"!==typeof e?null!=e&&null!=e.handleEvent&&e.handleEvent(t):e(t)}))},o.pubsub.addEventListener("message",n)),null!=r&&(null==s[t]&&(s[t]=[]),s[t].push(r))}async function o(t,r,i={}){const{libp2p:o}=await e.use(i);null!=r&&null!=s[t]&&(s[t]=s[t].filter((e=>e!==r)),0===s[t].length&&delete s[t]),"function"!==typeof r&&delete s[t],null==s[t]&&o.pubsub.unsubscribe(t),0===Object.keys(s).length&&(o.pubsub.removeEventListener("message",n),n=void 0)}async function a(t,r,s={}){const{libp2p:n}=await e.use(s);if(!r)throw h(new Error('argument "data" is required'),"ERR_ARG_REQUIRED");await n.pubsub.publish(t,r)}async function c(t={}){const{libp2p:r}=await e.use(t);return r.pubsub.getTopics()}async function l(t,r={}){const{libp2p:s}=await e.use(r);return s.pubsub.getSubscribers(t)}}const KL=async()=>{throw new Ve("pubsub not enabled")};var HL=r(25108);const qL=c.Z.bind({ignoreUndefined:!0}),GL=(0,u.kg)("ipfs"),WL=3e4;class YL{constructor({print:e,storage:t,codecs:r,options:s}){const{peerId:n,repo:i,keychain:o}=t,a=Ct.create(AL),c=Iy(s.preload),l=$t(),u=Kt({network:a}),d=new qs(s),p=Object.values(Ne.kq);(s.ipld&&s.ipld.hashers?s.ipld.hashers:[]).forEach((e=>p.push(e))),this.hashers=new ZS({hashers:p,loadHasher:s.ipld&&s.ipld.loadHasher});const f=Object.values(Ne.gh);(s.ipld&&s.ipld.bases?s.ipld.bases:[]).forEach((e=>f.push(e))),this.bases=new GS({bases:f,loadBase:s.ipld&&s.ipld.loadBase});const y=new nr({repo:i,codecs:r}),g=new jn({codecs:r,hashers:this.hashers,preload:c,repo:i}),m=new cn({dns:l,ipns:d,repo:i,codecs:r,peerId:n,isOnline:u,keychain:o,options:s}),w=qt({repo:i,codecs:r,bases:this.bases,name:m}),b=new gy({repo:i,codecs:r,hashers:this.hashers,preload:c}),_=Object.assign(hn({repo:i,codecs:r,resolve:w,preload:c}),{local:wn({repo:t.repo})}),{add:E,addAll:v,cat:S,get:I,ls:k}=new af({preload:c,repo:i,options:s.EXPERIMENTAL,hashers:this.hashers}),R=Zm({repo:i,preload:c,hashers:this.hashers,options:s}),T=Ry({files:R,preload:c,options:s.preload});this.preload=c,this.name=m,this.ipns=d,this.pin=y,this.resolve=w,this.block=g,this.refs=_,this.start=Pt({network:a,peerId:n,repo:i,preload:c,ipns:d,mfsPreload:T,print:e,keychain:o,hashers:this.hashers,options:s}),this.stop=Dt({network:a,preload:c,mfsPreload:T,ipns:d,repo:i}),this.dht=zL({network:a,repo:i,peerId:n}),this.pubsub=$L({network:a,config:s.config}),this.dns=l,this.isOnline=u,this.id=pf({network:a,peerId:n}),this.version=hf({repo:i}),this.bitswap=new Sn({network:a}),this.bootstrap=new Dn({repo:i}),this.config=Ef({repo:i}),this.ping=UL({network:a}),this.add=E,this.addAll=v,this.cat=S,this.get=I,this.ls=k,this.dag=b,this.files=R,this.key=new aw({keychain:o}),this.object=new _w({preload:c,codecs:r,repo:i}),this.repo=new Rw({repo:i,hashers:this.hashers}),this.stats=new Cw({repo:i,network:a}),this.swarm=new ML({network:a}),Object.defineProperty(this,"libp2p",{get(){const e=a.try();return e?e.libp2p:void 0}});const A=()=>Promise.reject(h(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")),C=async function*(){throw h(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")};this.commands=A,this.diag={cmds:A,net:A,sys:A},this.log={level:A,ls:A,tail:C},this.mount=A,this.codecs=r}async init(){throw new Me}}const QL=async e=>{const t=R.encode({Data:new k({type:"directory"}).marshal(),Links:[]}),r=await e.block.put(t,{mhtype:"sha2-256",format:"dag-pb"});return await e.pin.add(r),r},ZL=()=>({start:!0,EXPERIMENTAL:{},preload:{enabled:!l.isTest,addresses:["/dns4/node0.preload.ipfs.io/https","/dns4/node1.preload.ipfs.io/https","/dns4/node2.preload.ipfs.io/https","/dns4/node3.preload.ipfs.io/https"]}});async function XL(e={}){e=qL(ZL(),e);const t=e.init||{},r={name:De.identity.name,code:De.identity.code,encode:e=>e,decode:e=>e},o=Object.values(Ne.QB);[R,s,n,i,r].concat(e.ipld&&e.ipld.codecs||[]).forEach((e=>o.push(e)));const a=new YS({codecs:o,loadCodec:e.ipld&&e.ipld.loadCodec}),c=e.silent?GL:HL.log;GL("creating repo");const l=await dO.start(c,a,e);GL("getting repo config");const u=await l.repo.config.getAll(),d=new YL({storage:l,print:c,codecs:a,options:{...e,config:u}});if(GL("starting preload"),await d.preload.start(),GL("starting storage"),d.ipns.startOffline(l),l.isNew&&!t.emptyRepo){const e=await QL(d);if(GL("adding default assets"),await Oe({addAll:d.addAll,print:c}),GL("initializing IPNS keyspace"),null==l.peerId.publicKey)throw h(new Error("Public key missing"),"ERR_MISSING_PUBLIC_KEY");const t=new Fe.TimeoutController(WL);try{await d.ipns.initializeKeyspace(l.peerId,(0,ze.m)(`/ipfs/${e}`),{signal:t.signal})}finally{t.clear()}}return!1!==e.start&&(GL("starting node"),await d.start()),d}var JL=r(52596);const ex=XL,tx=JL,rx=xT;function sx(){throw new Error("Not supported in browsers")}const nx=ex,ix=tx,ox=rx,ax=sx}}]);